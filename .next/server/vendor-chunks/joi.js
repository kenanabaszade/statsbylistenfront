"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/joi";
exports.ids = ["vendor-chunks/joi"];
exports.modules = {

/***/ "(rsc)/./node_modules/joi/lib/annotate.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/annotate.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    annotations: Symbol('annotations')\n};\n\n\nexports.error = function (stripColorCodes) {\n\n    if (!this._original ||\n        typeof this._original !== 'object') {\n\n        return this.details[0].message;\n    }\n\n    const redFgEscape = stripColorCodes ? '' : '\\u001b[31m';\n    const redBgEscape = stripColorCodes ? '' : '\\u001b[41m';\n    const endColor = stripColorCodes ? '' : '\\u001b[0m';\n\n    const obj = Clone(this._original);\n\n    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first\n        const pos = i + 1;\n        const error = this.details[i];\n        const path = error.path;\n        let node = obj;\n        for (let j = 0; ; ++j) {\n            const seg = path[j];\n\n            if (Common.isSchema(node)) {\n                node = node.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step\n            }\n\n            if (j + 1 < path.length &&\n                typeof node[seg] !== 'string') {\n\n                node = node[seg];\n            }\n            else {\n                const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };\n                node[internals.annotations] = refAnnotations;\n\n                const cacheKey = seg || error.context.key;\n\n                if (node[seg] !== undefined) {\n                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];\n                    refAnnotations.errors[cacheKey].push(pos);\n                }\n                else {\n                    refAnnotations.missing[cacheKey] = pos;\n                }\n\n                break;\n            }\n        }\n    }\n\n    const replacers = {\n        key: /_\\$key\\$_([, \\d]+)_\\$end\\$_\"/g,\n        missing: /\"_\\$miss\\$_([^|]+)\\|(\\d+)_\\$end\\$_\": \"__missing__\"/g,\n        arrayIndex: /\\s*\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\",?\\n(.*)/g,\n        specials: /\"\\[(NaN|Symbol.*|-?Infinity|function.*|\\(.*)]\"/g\n    };\n\n    let message = internals.safeStringify(obj, 2)\n        .replace(replacers.key, ($0, $1) => `\" ${redFgEscape}[${$1}]${endColor}`)\n        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}\"${$1}\"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)\n        .replace(replacers.arrayIndex, ($0, $1, $2) => `\\n${$2} ${redFgEscape}[${$1}]${endColor}`)\n        .replace(replacers.specials, ($0, $1) => $1);\n\n    message = `${message}\\n${redFgEscape}`;\n\n    for (let i = 0; i < this.details.length; ++i) {\n        const pos = i + 1;\n        message = `${message}\\n[${pos}] ${this.details[i].message}`;\n    }\n\n    message = message + endColor;\n\n    return message;\n};\n\n\n// Inspired by json-stringify-safe\n\ninternals.safeStringify = function (obj, spaces) {\n\n    return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\n\ninternals.serializer = function () {\n\n    const keys = [];\n    const stack = [];\n\n    const cycleReplacer = (key, value) => {\n\n        if (stack[0] === value) {\n            return '[Circular ~]';\n        }\n\n        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n    };\n\n    return function (key, value) {\n\n        if (stack.length > 0) {\n            const thisPos = stack.indexOf(this);\n            if (~thisPos) {\n                stack.length = thisPos + 1;\n                keys.length = thisPos + 1;\n                keys[thisPos] = key;\n            }\n            else {\n                stack.push(this);\n                keys.push(key);\n            }\n\n            if (~stack.indexOf(value)) {\n                value = cycleReplacer.call(this, key, value);\n            }\n        }\n        else {\n            stack.push(value);\n        }\n\n        if (value) {\n            const annotations = value[internals.annotations];\n            if (annotations) {\n                if (Array.isArray(value)) {\n                    const annotated = [];\n\n                    for (let i = 0; i < value.length; ++i) {\n                        if (annotations.errors[i]) {\n                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);\n                        }\n\n                        annotated.push(value[i]);\n                    }\n\n                    value = annotated;\n                }\n                else {\n                    for (const errorKey in annotations.errors) {\n                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];\n                        value[errorKey] = undefined;\n                    }\n\n                    for (const missingKey in annotations.missing) {\n                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';\n                    }\n                }\n\n                return value;\n            }\n        }\n\n        if (value === Infinity ||\n            value === -Infinity ||\n            Number.isNaN(value) ||\n            typeof value === 'function' ||\n            typeof value === 'symbol') {\n\n            return '[' + value.toString() + ']';\n        }\n\n        return value;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9hbm5vdGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsMEVBQXNCOztBQUU1QyxlQUFlLG1CQUFPLENBQUMsd0RBQVU7OztBQUdqQztBQUNBO0FBQ0E7OztBQUdBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUSxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0Esa0VBQWtFO0FBQ2xFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELFlBQVksR0FBRyxHQUFHLEdBQUcsU0FBUztBQUMvRSx1REFBdUQsWUFBWSxHQUFHLEdBQUcsR0FBRyxTQUFTLEVBQUUsYUFBYSxHQUFHLEdBQUcsa0JBQWtCLFNBQVM7QUFDckksNERBQTRELElBQUksRUFBRSxZQUFZLEdBQUcsR0FBRyxHQUFHLFNBQVM7QUFDaEc7O0FBRUEsaUJBQWlCLFFBQVEsSUFBSSxZQUFZOztBQUV6QyxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0EscUJBQXFCLFFBQVEsS0FBSyxJQUFJLElBQUksd0JBQXdCO0FBQ2xFOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQSxxREFBcUQsd0NBQXdDO0FBQzdGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxTQUFTLCtDQUErQztBQUNsRztBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFdBQVcsR0FBRyxnQ0FBZ0M7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL2Fubm90YXRlLmpzPzY3OGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGFubm90YXRpb25zOiBTeW1ib2woJ2Fubm90YXRpb25zJylcbn07XG5cblxuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uIChzdHJpcENvbG9yQ29kZXMpIHtcblxuICAgIGlmICghdGhpcy5fb3JpZ2luYWwgfHxcbiAgICAgICAgdHlwZW9mIHRoaXMuX29yaWdpbmFsICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRldGFpbHNbMF0ubWVzc2FnZTtcbiAgICB9XG5cbiAgICBjb25zdCByZWRGZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMzFtJztcbiAgICBjb25zdCByZWRCZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbNDFtJztcbiAgICBjb25zdCBlbmRDb2xvciA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMG0nO1xuXG4gICAgY29uc3Qgb2JqID0gQ2xvbmUodGhpcy5fb3JpZ2luYWwpO1xuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuZGV0YWlscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyAgICAgICAgLy8gUmV2ZXJzZSBvcmRlciB0byBwcm9jZXNzIGRlZXBlc3QgY2hpbGQgZmlyc3RcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5kZXRhaWxzW2ldO1xuICAgICAgICBjb25zdCBwYXRoID0gZXJyb3IucGF0aDtcbiAgICAgICAgbGV0IG5vZGUgPSBvYmo7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyA7ICsraikge1xuICAgICAgICAgICAgY29uc3Qgc2VnID0gcGF0aFtqXTtcblxuICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShub2RlKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gam9pIHNjaGVtYXMgYXJlIG5vdCBjbG9uZWQgYnkgaG9laywgd2UgaGF2ZSB0byB0YWtlIHRoaXMgZXh0cmEgc3RlcFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaiArIDEgPCBwYXRoLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlW3NlZ10gIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZVtzZWddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmQW5ub3RhdGlvbnMgPSBub2RlW2ludGVybmFscy5hbm5vdGF0aW9uc10gfHwgeyBlcnJvcnM6IHt9LCBtaXNzaW5nOiB7fSB9O1xuICAgICAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxzLmFubm90YXRpb25zXSA9IHJlZkFubm90YXRpb25zO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzZWcgfHwgZXJyb3IuY29udGV4dC5rZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZVtzZWddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XSA9IHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0ucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMubWlzc2luZ1tjYWNoZUtleV0gPSBwb3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXBsYWNlcnMgPSB7XG4gICAgICAgIGtleTogL19cXCRrZXlcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIvZyxcbiAgICAgICAgbWlzc2luZzogL1wiX1xcJG1pc3NcXCRfKFtefF0rKVxcfChcXGQrKV9cXCRlbmRcXCRfXCI6IFwiX19taXNzaW5nX19cIi9nLFxuICAgICAgICBhcnJheUluZGV4OiAvXFxzKlwiX1xcJGlkeFxcJF8oWywgXFxkXSspX1xcJGVuZFxcJF9cIiw/XFxuKC4qKS9nLFxuICAgICAgICBzcGVjaWFsczogL1wiXFxbKE5hTnxTeW1ib2wuKnwtP0luZmluaXR5fGZ1bmN0aW9uLip8XFwoLiopXVwiL2dcbiAgICB9O1xuXG4gICAgbGV0IG1lc3NhZ2UgPSBpbnRlcm5hbHMuc2FmZVN0cmluZ2lmeShvYmosIDIpXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5rZXksICgkMCwgJDEpID0+IGBcIiAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5taXNzaW5nLCAoJDAsICQxLCAkMikgPT4gYCR7cmVkQmdFc2NhcGV9XCIkeyQxfVwiJHtlbmRDb2xvcn0ke3JlZEZnRXNjYXBlfSBbJHskMn1dOiAtLSBtaXNzaW5nIC0tJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuYXJyYXlJbmRleCwgKCQwLCAkMSwgJDIpID0+IGBcXG4keyQyfSAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5zcGVjaWFscywgKCQwLCAkMSkgPT4gJDEpO1xuXG4gICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuJHtyZWRGZ0VzY2FwZX1gO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRldGFpbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcblske3Bvc31dICR7dGhpcy5kZXRhaWxzW2ldLm1lc3NhZ2V9YDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSArIGVuZENvbG9yO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuXG5cbi8vIEluc3BpcmVkIGJ5IGpzb24tc3RyaW5naWZ5LXNhZmVcblxuaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBzcGFjZXMpIHtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGludGVybmFscy5zZXJpYWxpemVyKCksIHNwYWNlcyk7XG59O1xuXG5cbmludGVybmFscy5zZXJpYWxpemVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YWNrID0gW107XG5cbiAgICBjb25zdCBjeWNsZVJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHtcblxuICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhciB+XSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1tDaXJjdWxhciB+LicgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKCcuJykgKyAnXSc7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgIGlmICh+dGhpc1Bvcykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IHRoaXNQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGtleXMubGVuZ3RoID0gdGhpc1BvcyArIDE7XG4gICAgICAgICAgICAgICAga2V5c1t0aGlzUG9zXSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGN5Y2xlUmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IHZhbHVlW2ludGVybmFscy5hbm5vdGF0aW9uc107XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGVkID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmVycm9yc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZC5wdXNoKGBfJGlkeCRfJHthbm5vdGF0aW9ucy5lcnJvcnNbaV0uc29ydCgpLmpvaW4oJywgJyl9XyRlbmQkX2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFubm90YXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3JLZXkgaW4gYW5ub3RhdGlvbnMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtgJHtlcnJvcktleX1fJGtleSRfJHthbm5vdGF0aW9ucy5lcnJvcnNbZXJyb3JLZXldLnNvcnQoKS5qb2luKCcsICcpfV8kZW5kJF9gXSA9IHZhbHVlW2Vycm9yS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2Vycm9yS2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlzc2luZ0tleSBpbiBhbm5vdGF0aW9ucy5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtgXyRtaXNzJF8ke21pc3NpbmdLZXl9fCR7YW5ub3RhdGlvbnMubWlzc2luZ1ttaXNzaW5nS2V5XX1fJGVuZCRfYF0gPSAnX19taXNzaW5nX18nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IC1JbmZpbml0eSB8fFxuICAgICAgICAgICAgTnVtYmVyLmlzTmFOKHZhbHVlKSB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAnWycgKyB2YWx1ZS50b1N0cmluZygpICsgJ10nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/annotate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/base.js":
/*!**************************************!*\
  !*** ./node_modules/joi/lib/base.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"(rsc)/./node_modules/@hapi/hoek/lib/deepEqual.js\");\nconst Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ \"(rsc)/./node_modules/@hapi/hoek/lib/merge.js\");\n\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/joi/lib/cache.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ./compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Extend = __webpack_require__(/*! ./extend */ \"(rsc)/./node_modules/joi/lib/extend.js\");\nconst Manifest = __webpack_require__(/*! ./manifest */ \"(rsc)/./node_modules/joi/lib/manifest.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\nconst Modify = __webpack_require__(/*! ./modify */ \"(rsc)/./node_modules/joi/lib/modify.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst Trace = __webpack_require__(/*! ./trace */ \"(rsc)/./node_modules/joi/lib/trace.js\");\nconst Validator = __webpack_require__(/*! ./validator */ \"(rsc)/./node_modules/joi/lib/validator.js\");\nconst Values = __webpack_require__(/*! ./values */ \"(rsc)/./node_modules/joi/lib/values.js\");\n\n\nconst internals = {};\n\n\ninternals.Base = class {\n\n    constructor(type) {\n\n        // Naming: public, _private, $_extension, $_mutate{action}\n\n        this.type = type;\n\n        this.$_root = null;\n        this._definition = {};\n        this._reset();\n    }\n\n    _reset() {\n\n        this._ids = new Modify.Ids();\n        this._preferences = null;\n        this._refs = new Ref.Manager();\n        this._cache = null;\n\n        this._valids = null;\n        this._invalids = null;\n\n        this._flags = {};\n        this._rules = [];\n        this._singleRules = new Map();              // The rule options passed for non-multi rules\n\n        this.$_terms = {};                          // Hash of arrays of immutable objects (extended by other types)\n\n        this.$_temp = {                             // Runtime state (not cloned)\n            ruleset: null,                          // null: use last, false: error, number: start position\n            whens: {}                               // Runtime cache of generated whens\n        };\n    }\n\n    // Manifest\n\n    describe() {\n\n        Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');\n        return Manifest.describe(this);\n    }\n\n    // Rules\n\n    allow(...values) {\n\n        Common.verifyFlat(values, 'allow');\n        return this._values(values, '_valids');\n    }\n\n    alter(targets) {\n\n        Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');\n        Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');\n\n        const obj = this.clone();\n        obj.$_terms.alterations = obj.$_terms.alterations || [];\n        for (const target in targets) {\n            const adjuster = targets[target];\n            Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');\n            obj.$_terms.alterations.push({ target, adjuster });\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    artifact(id) {\n\n        Assert(id !== undefined, 'Artifact cannot be undefined');\n        Assert(!this._cache, 'Cannot set an artifact with a rule cache');\n\n        return this.$_setFlag('artifact', id);\n    }\n\n    cast(to) {\n\n        Assert(to === false || typeof to === 'string', 'Invalid to value');\n        Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);\n\n        return this.$_setFlag('cast', to === false ? undefined : to);\n    }\n\n    default(value, options) {\n\n        return this._default('default', value, options);\n    }\n\n    description(desc) {\n\n        Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n        return this.$_setFlag('description', desc);\n    }\n\n    empty(schema) {\n\n        const obj = this.clone();\n\n        if (schema !== undefined) {\n            schema = obj.$_compile(schema, { override: false });\n        }\n\n        return obj.$_setFlag('empty', schema, { clone: false });\n    }\n\n    error(err) {\n\n        Assert(err, 'Missing error');\n        Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');\n\n        return this.$_setFlag('error', err);\n    }\n\n    example(example, options = {}) {\n\n        Assert(example !== undefined, 'Missing example');\n        Common.assertOptions(options, ['override']);\n\n        return this._inner('examples', example, { single: true, override: options.override });\n    }\n\n    external(method, description) {\n\n        if (typeof method === 'object') {\n            Assert(!description, 'Cannot combine options with description');\n            description = method.description;\n            method = method.method;\n        }\n\n        Assert(typeof method === 'function', 'Method must be a function');\n        Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');\n\n        return this._inner('externals', { method, description }, { single: true });\n    }\n\n    failover(value, options) {\n\n        return this._default('failover', value, options);\n    }\n\n    forbidden() {\n\n        return this.presence('forbidden');\n    }\n\n    id(id) {\n\n        if (!id) {\n            return this.$_setFlag('id', undefined);\n        }\n\n        Assert(typeof id === 'string', 'id must be a non-empty string');\n        Assert(/^[^\\.]+$/.test(id), 'id cannot contain period character');\n\n        return this.$_setFlag('id', id);\n    }\n\n    invalid(...values) {\n\n        return this._values(values, '_invalids');\n    }\n\n    label(name) {\n\n        Assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n        return this.$_setFlag('label', name);\n    }\n\n    meta(meta) {\n\n        Assert(meta !== undefined, 'Meta cannot be undefined');\n\n        return this._inner('metas', meta, { single: true });\n    }\n\n    note(...notes) {\n\n        Assert(notes.length, 'Missing notes');\n        for (const note of notes) {\n            Assert(note && typeof note === 'string', 'Notes must be non-empty strings');\n        }\n\n        return this._inner('notes', notes);\n    }\n\n    only(mode = true) {\n\n        Assert(typeof mode === 'boolean', 'Invalid mode:', mode);\n\n        return this.$_setFlag('only', mode);\n    }\n\n    optional() {\n\n        return this.presence('optional');\n    }\n\n    prefs(prefs) {\n\n        Assert(prefs, 'Missing preferences');\n        Assert(prefs.context === undefined, 'Cannot override context');\n        Assert(prefs.externals === undefined, 'Cannot override externals');\n        Assert(prefs.warnings === undefined, 'Cannot override warnings');\n        Assert(prefs.debug === undefined, 'Cannot override debug');\n\n        Common.checkPreferences(prefs);\n\n        const obj = this.clone();\n        obj._preferences = Common.preferences(obj._preferences, prefs);\n        return obj;\n    }\n\n    presence(mode) {\n\n        Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);\n\n        return this.$_setFlag('presence', mode);\n    }\n\n    raw(enabled = true) {\n\n        return this.$_setFlag('result', enabled ? 'raw' : undefined);\n    }\n\n    result(mode) {\n\n        Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);\n\n        return this.$_setFlag('result', mode);\n    }\n\n    required() {\n\n        return this.presence('required');\n    }\n\n    strict(enabled) {\n\n        const obj = this.clone();\n\n        const convert = enabled === undefined ? false : !enabled;\n        obj._preferences = Common.preferences(obj._preferences, { convert });\n        return obj;\n    }\n\n    strip(enabled = true) {\n\n        return this.$_setFlag('result', enabled ? 'strip' : undefined);\n    }\n\n    tag(...tags) {\n\n        Assert(tags.length, 'Missing tags');\n        for (const tag of tags) {\n            Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');\n        }\n\n        return this._inner('tags', tags);\n    }\n\n    unit(name) {\n\n        Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n        return this.$_setFlag('unit', name);\n    }\n\n    valid(...values) {\n\n        Common.verifyFlat(values, 'valid');\n\n        const obj = this.allow(...values);\n        obj.$_setFlag('only', !!obj._valids, { clone: false });\n        return obj;\n    }\n\n    when(condition, options) {\n\n        const obj = this.clone();\n\n        if (!obj.$_terms.whens) {\n            obj.$_terms.whens = [];\n        }\n\n        const when = Compile.when(obj, condition, options);\n        if (!['any', 'link'].includes(obj.type)) {\n            const conditions = when.is ? [when] : when.switch;\n            for (const item of conditions) {\n                Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);\n                Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);\n\n            }\n        }\n\n        obj.$_terms.whens.push(when);\n        return obj.$_mutateRebuild();\n    }\n\n    // Helpers\n\n    cache(cache) {\n\n        Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');\n        Assert(!this._cache, 'Cannot override schema cache');\n        Assert(this._flags.artifact === undefined, 'Cannot cache a rule with an artifact');\n\n        const obj = this.clone();\n        obj._cache = cache || Cache.provider.provision();\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    clone() {\n\n        const obj = Object.create(Object.getPrototypeOf(this));\n        return this._assign(obj);\n    }\n\n    concat(source) {\n\n        Assert(Common.isSchema(source), 'Invalid schema object');\n        Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);\n        Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');\n        Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');\n\n        let obj = this.clone();\n\n        if (this.type === 'any' &&\n            source.type !== 'any') {\n\n            // Change obj to match source type\n\n            const tmpObj = source.clone();\n            for (const key of Object.keys(obj)) {\n                if (key !== 'type') {\n                    tmpObj[key] = obj[key];\n                }\n            }\n\n            obj = tmpObj;\n        }\n\n        obj._ids.concat(source._ids);\n        obj._refs.register(source, Ref.toSibling);\n\n        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;\n        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);\n        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);\n\n        // Remove unique rules present in source\n\n        for (const name of source._singleRules.keys()) {\n            if (obj._singleRules.has(name)) {\n                obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);\n                obj._singleRules.delete(name);\n            }\n        }\n\n        // Rules\n\n        for (const test of source._rules) {\n            if (!source._definition.rules[test.method].multi) {\n                obj._singleRules.set(test.name, test);\n            }\n\n            obj._rules.push(test);\n        }\n\n        // Flags\n\n        if (obj._flags.empty &&\n            source._flags.empty) {\n\n            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        }\n        else if (source._flags.empty) {\n            obj._flags.empty = source._flags.empty;\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        }\n        else {\n            Merge(obj._flags, source._flags);\n        }\n\n        // Terms\n\n        for (const key in source.$_terms) {\n            const terms = source.$_terms[key];\n            if (!terms) {\n                if (!obj.$_terms[key]) {\n                    obj.$_terms[key] = terms;\n                }\n\n                continue;\n            }\n\n            if (!obj.$_terms[key]) {\n                obj.$_terms[key] = terms.slice();\n                continue;\n            }\n\n            obj.$_terms[key] = obj.$_terms[key].concat(terms);\n        }\n\n        // Tracing\n\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [this, source]);\n        }\n\n        // Rebuild\n\n        return obj.$_mutateRebuild();\n    }\n\n    extend(options) {\n\n        Assert(!options.base, 'Cannot extend type with another base');\n\n        return Extend.type(this, options);\n    }\n\n    extract(path) {\n\n        path = Array.isArray(path) ? path : path.split('.');\n        return this._ids.reach(path);\n    }\n\n    fork(paths, adjuster) {\n\n        Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');\n\n        let obj = this;                                             // eslint-disable-line consistent-this\n        for (let path of [].concat(paths)) {\n            path = Array.isArray(path) ? path : path.split('.');\n            obj = obj._ids.fork(path, adjuster, obj);\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    rule(options) {\n\n        const def = this._definition;\n        Common.assertOptions(options, Object.keys(def.modifiers));\n\n        Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');\n        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;\n        Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');\n\n        const obj = this.clone();\n\n        for (let i = start; i < obj._rules.length; ++i) {\n            const original = obj._rules[i];\n            const rule = Clone(original);\n\n            for (const name in options) {\n                def.modifiers[name](rule, options[name]);\n                Assert(rule.name === original.name, 'Cannot change rule name');\n            }\n\n            obj._rules[i] = rule;\n\n            if (obj._singleRules.get(rule.name) === original) {\n                obj._singleRules.set(rule.name, rule);\n            }\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n\n    get ruleset() {\n\n        Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');\n\n        const obj = this.clone();\n        obj.$_temp.ruleset = obj._rules.length;\n        return obj;\n    }\n\n    get $() {\n\n        return this.ruleset;\n    }\n\n    tailor(targets) {\n\n        targets = [].concat(targets);\n\n        Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');\n\n        let obj = this;                                                     // eslint-disable-line consistent-this\n\n        if (this.$_terms.alterations) {\n            for (const { target, adjuster } of this.$_terms.alterations) {\n                if (targets.includes(target)) {\n                    obj = adjuster(obj);\n                    Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');\n                }\n            }\n        }\n\n        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n\n    tracer() {\n\n        return Trace.location ? Trace.location(this) : this;                // $lab:coverage:ignore$\n    }\n\n    validate(value, options) {\n\n        return Validator.entry(value, this, options);\n    }\n\n    validateAsync(value, options) {\n\n        return Validator.entryAsync(value, this, options);\n    }\n\n    // Extensions\n\n    $_addRule(options) {\n\n        // Normalize rule\n\n        if (typeof options === 'string') {\n            options = { name: options };\n        }\n\n        Assert(options && typeof options === 'object', 'Invalid options');\n        Assert(options.name && typeof options.name === 'string', 'Invalid rule name');\n\n        for (const key in options) {\n            Assert(key[0] !== '_', 'Cannot set private rule properties');\n        }\n\n        const rule = Object.assign({}, options);        // Shallow cloned\n        rule._resolve = [];\n        rule.method = rule.method || rule.name;\n\n        const definition = this._definition.rules[rule.method];\n        const args = rule.args;\n\n        Assert(definition, 'Unknown rule', rule.method);\n\n        // Args\n\n        const obj = this.clone();\n\n        if (args) {\n            Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);\n\n            for (const key in args) {\n                let arg = args[key];\n\n                if (definition.argsByName) {\n                    const resolver = definition.argsByName.get(key);\n\n                    if (resolver.ref &&\n                        Common.isResolvable(arg)) {\n\n                        rule._resolve.push(key);\n                        obj.$_mutateRegister(arg);\n                    }\n                    else {\n                        if (resolver.normalize) {\n                            arg = resolver.normalize(arg);\n                            args[key] = arg;\n                        }\n\n                        if (resolver.assert) {\n                            const error = Common.validateArg(arg, key, resolver);\n                            Assert(!error, error, 'or reference');\n                        }\n                    }\n                }\n\n                if (arg === undefined) {\n                    delete args[key];\n                    continue;\n                }\n\n                args[key] = arg;\n            }\n        }\n\n        // Unique rules\n\n        if (!definition.multi) {\n            obj._ruleRemove(rule.name, { clone: false });\n            obj._singleRules.set(rule.name, rule);\n        }\n\n        if (obj.$_temp.ruleset === false) {\n            obj.$_temp.ruleset = null;\n        }\n\n        if (definition.priority) {\n            obj._rules.unshift(rule);\n        }\n        else {\n            obj._rules.push(rule);\n        }\n\n        return obj;\n    }\n\n    $_compile(schema, options) {\n\n        return Compile.schema(this.$_root, schema, options);\n    }\n\n    $_createError(code, value, local, state, prefs, options = {}) {\n\n        const flags = options.flags !== false ? this._flags : {};\n        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;\n        return new Errors.Report(code, value, local, flags, messages, state, prefs);\n    }\n\n    $_getFlag(name) {\n\n        return this._flags[name];\n    }\n\n    $_getRule(name) {\n\n        return this._singleRules.get(name);\n    }\n\n    $_mapLabels(path) {\n\n        path = Array.isArray(path) ? path : path.split('.');\n        return this._ids.labels(path);\n    }\n\n    $_match(value, state, prefs, overrides) {\n\n        prefs = Object.assign({}, prefs);       // Shallow cloned\n        prefs.abortEarly = true;\n        prefs._externals = false;\n\n        state.snapshot();\n        const result = !Validator.validate(value, this, state, prefs, overrides).errors;\n        state.restore();\n\n        return result;\n    }\n\n    $_modify(options) {\n\n        Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);\n        return Modify.schema(this, options) || this;\n    }\n\n    $_mutateRebuild() {\n\n        Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');\n\n        this._refs.reset();\n        this._ids.reset();\n\n        const each = (item, { source, name, path, key }) => {\n\n            const family = this._definition[source][name] && this._definition[source][name].register;\n            if (family !== false) {\n                this.$_mutateRegister(item, { family, key });\n            }\n        };\n\n        this.$_modify({ each });\n\n        if (this._definition.rebuild) {\n            this._definition.rebuild(this);\n        }\n\n        this.$_temp.ruleset = false;\n        return this;\n    }\n\n    $_mutateRegister(schema, { family, key } = {}) {\n\n        this._refs.register(schema, family);\n        this._ids.register(schema, { key });\n    }\n\n    $_property(name) {\n\n        return this._definition.properties[name];\n    }\n\n    $_reach(path) {\n\n        return this._ids.reach(path);\n    }\n\n    $_rootReferences() {\n\n        return this._refs.roots();\n    }\n\n    $_setFlag(name, value, options = {}) {\n\n        Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');\n\n        const flag = this._definition.flags[name] || {};\n        if (DeepEqual(value, flag.default)) {\n            value = undefined;\n        }\n\n        if (DeepEqual(value, this._flags[name])) {\n            return this;\n        }\n\n        const obj = options.clone !== false ? this.clone() : this;\n\n        if (value !== undefined) {\n            obj._flags[name] = value;\n            obj.$_mutateRegister(value);\n        }\n        else {\n            delete obj._flags[name];\n        }\n\n        if (name[0] !== '_') {\n            obj.$_temp.ruleset = false;\n        }\n\n        return obj;\n    }\n\n    $_parent(method, ...args) {\n\n        return this[method][Common.symbols.parent].call(this, ...args);\n    }\n\n    $_validate(value, state, prefs) {\n\n        return Validator.validate(value, this, state, prefs);\n    }\n\n    // Internals\n\n    _assign(target) {\n\n        target.type = this.type;\n\n        target.$_root = this.$_root;\n\n        target.$_temp = Object.assign({}, this.$_temp);\n        target.$_temp.whens = {};\n\n        target._ids = this._ids.clone();\n        target._preferences = this._preferences;\n        target._valids = this._valids && this._valids.clone();\n        target._invalids = this._invalids && this._invalids.clone();\n        target._rules = this._rules.slice();\n        target._singleRules = Clone(this._singleRules, { shallow: true });\n        target._refs = this._refs.clone();\n        target._flags = Object.assign({}, this._flags);\n        target._cache = null;\n\n        target.$_terms = {};\n        for (const key in this.$_terms) {\n            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;\n        }\n\n        // Backwards compatibility\n\n        target.$_super = {};\n        for (const override in this.$_super) {\n            target.$_super[override] = this._super[override].bind(target);\n        }\n\n        return target;\n    }\n\n    _bare() {\n\n        const obj = this.clone();\n        obj._reset();\n\n        const terms = obj._definition.terms;\n        for (const name in terms) {\n            const term = terms[name];\n            obj.$_terms[name] = term.init;\n        }\n\n        return obj.$_mutateRebuild();\n    }\n\n    _default(flag, value, options = {}) {\n\n        Common.assertOptions(options, 'literal');\n\n        Assert(value !== undefined, 'Missing', flag, 'value');\n        Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');\n\n        if (typeof value === 'function' &&\n            options.literal) {\n\n            value = {\n                [Common.symbols.literal]: true,\n                literal: value\n            };\n        }\n\n        const obj = this.$_setFlag(flag, value);\n        return obj;\n    }\n\n    _generate(value, state, prefs) {\n\n        if (!this.$_terms.whens) {\n            return { schema: this };\n        }\n\n        // Collect matching whens\n\n        const whens = [];\n        const ids = [];\n        for (let i = 0; i < this.$_terms.whens.length; ++i) {\n            const when = this.$_terms.whens[i];\n\n            if (when.concat) {\n                whens.push(when.concat);\n                ids.push(`${i}.concat`);\n                continue;\n            }\n\n            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;\n            const tests = when.is ? [when] : when.switch;\n            const before = ids.length;\n\n            for (let j = 0; j < tests.length; ++j) {\n                const { is, then, otherwise } = tests[j];\n\n                const baseId = `${i}${when.switch ? '.' + j : ''}`;\n                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {\n                    if (then) {\n                        const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);\n                        const { schema: generated, id } = then._generate(value, localState, prefs);\n                        whens.push(generated);\n                        ids.push(`${baseId}.then${id ? `(${id})` : ''}`);\n                        break;\n                    }\n                }\n                else if (otherwise) {\n                    const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);\n                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);\n                    whens.push(generated);\n                    ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);\n                    break;\n                }\n            }\n\n            if (when.break &&\n                ids.length > before) {          // Something matched\n\n                break;\n            }\n        }\n\n        // Check cache\n\n        const id = ids.join(', ');\n        state.mainstay.tracer.debug(state, 'rule', 'when', id);\n\n        if (!id) {\n            return { schema: this };\n        }\n\n        if (!state.mainstay.tracer.active &&\n            this.$_temp.whens[id]) {\n\n            return { schema: this.$_temp.whens[id], id };\n        }\n\n        // Generate dynamic schema\n\n        let obj = this;                                             // eslint-disable-line consistent-this\n        if (this._definition.generate) {\n            obj = this._definition.generate(this, value, state, prefs);\n        }\n\n        // Apply whens\n\n        for (const when of whens) {\n            obj = obj.concat(when);\n        }\n\n        // Tracing\n\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [this, ...whens]);\n        }\n\n        // Cache result\n\n        this.$_temp.whens[id] = obj;\n        return { schema: obj, id };\n    }\n\n    _inner(type, values, options = {}) {\n\n        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);\n\n        const obj = this.clone();\n        if (!obj.$_terms[type] ||\n            options.override) {\n\n            obj.$_terms[type] = [];\n        }\n\n        if (options.single) {\n            obj.$_terms[type].push(values);\n        }\n        else {\n            obj.$_terms[type].push(...values);\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    _inRuleset() {\n\n        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;\n    }\n\n    _ruleRemove(name, options = {}) {\n\n        if (!this._singleRules.has(name)) {\n            return this;\n        }\n\n        const obj = options.clone !== false ? this.clone() : this;\n\n        obj._singleRules.delete(name);\n\n        const filtered = [];\n        for (let i = 0; i < obj._rules.length; ++i) {\n            const test = obj._rules[i];\n            if (test.name === name &&\n                !test.keep) {\n\n                if (obj._inRuleset() &&\n                    i < obj.$_temp.ruleset) {\n\n                    --obj.$_temp.ruleset;\n                }\n\n                continue;\n            }\n\n            filtered.push(test);\n        }\n\n        obj._rules = filtered;\n        return obj;\n    }\n\n    _values(values, key) {\n\n        Common.verifyFlat(values, key.slice(1, -1));\n\n        const obj = this.clone();\n\n        const override = values[0] === Common.symbols.override;\n        if (override) {\n            values = values.slice(1);\n        }\n\n        if (!obj[key] &&\n            values.length) {\n\n            obj[key] = new Values();\n        }\n        else if (override) {\n            obj[key] = values.length ? new Values() : null;\n            obj.$_mutateRebuild();\n        }\n\n        if (!obj[key]) {\n            return obj;\n        }\n\n        if (override) {\n            obj[key].override();\n        }\n\n        for (const value of values) {\n            Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            Assert(value !== Common.symbols.override, 'Override must be the first value');\n\n            const other = key === '_invalids' ? '_valids' : '_invalids';\n            if (obj[other]) {\n                obj[other].remove(value);\n                if (!obj[other].length) {\n                    Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');\n                    obj[other] = null;\n                }\n            }\n\n            obj[key].add(value, obj._refs);\n        }\n\n        return obj;\n    }\n};\n\n\ninternals.Base.prototype[Common.symbols.any] = {\n    version: Common.version,\n    compile: Compile.compile,\n    root: '$_root'\n};\n\n\ninternals.Base.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects (must be on prototype)\n\n\n// Aliases\n\ninternals.Base.prototype.deny = internals.Base.prototype.invalid;\ninternals.Base.prototype.disallow = internals.Base.prototype.invalid;\ninternals.Base.prototype.equal = internals.Base.prototype.valid;\ninternals.Base.prototype.exist = internals.Base.prototype.required;\ninternals.Base.prototype.not = internals.Base.prototype.invalid;\ninternals.Base.prototype.options = internals.Base.prototype.prefs;\ninternals.Base.prototype.preferences = internals.Base.prototype.prefs;\n\n\nmodule.exports = new internals.Base();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw0RUFBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLDBFQUFzQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBMEI7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLDBFQUFzQjs7QUFFNUMsY0FBYyxtQkFBTyxDQUFDLHNEQUFTO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBVztBQUNuQyxlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTtBQUNqQyxZQUFZLG1CQUFPLENBQUMsa0RBQU87QUFDM0IsY0FBYyxtQkFBTyxDQUFDLHNEQUFTO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDhEQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTs7O0FBR2pDOzs7QUFHQTs7QUFFQTs7QUFFQSwyREFBMkQ7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQsb0RBQW9EOztBQUVwRCxvREFBb0Q7QUFDcEQ7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDs7QUFFQSxnREFBZ0QsY0FBYztBQUM5RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBLGtEQUFrRCwwQ0FBMEM7QUFDNUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxxQkFBcUIsSUFBSSxjQUFjO0FBQ2pGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsY0FBYztBQUMxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrRUFBa0UsU0FBUztBQUMzRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0RUFBNEU7O0FBRTVFO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGtEQUFrRDtBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEVBQTRFO0FBQzVFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIseUJBQXlCOztBQUV2RDtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTs7QUFFQSx3QkFBd0IsTUFBTTs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsY0FBYyxJQUFJOztBQUVqRDtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlO0FBQ3hFO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixFQUFFO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixrQkFBa0I7QUFDOUMsd0JBQXdCLHNCQUFzQjs7QUFFOUMsa0NBQWtDLEVBQUUsRUFBRSwyQkFBMkI7QUFDakUsd0RBQXdELE9BQU87QUFDL0Q7QUFDQSw2RUFBNkUsT0FBTztBQUNwRixnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0Esb0NBQW9DLE9BQU8sT0FBTyxTQUFTLEdBQUcsUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxPQUFPO0FBQ2hGLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQSxnQ0FBZ0MsT0FBTyxZQUFZLFNBQVMsR0FBRyxRQUFRO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUEsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLHFDQUFxQzs7QUFFckMsaURBQWlELE1BQU07O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDREQUE0RDs7O0FBRzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL2Jhc2UuanM/Y2U2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL21lcmdlJyk7XG5cbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuY29uc3QgTWFuaWZlc3QgPSByZXF1aXJlKCcuL21hbmlmZXN0Jyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcbmNvbnN0IE1vZGlmeSA9IHJlcXVpcmUoJy4vbW9kaWZ5Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlJyk7XG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuY29uc3QgVmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuQmFzZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcblxuICAgICAgICAvLyBOYW1pbmc6IHB1YmxpYywgX3ByaXZhdGUsICRfZXh0ZW5zaW9uLCAkX211dGF0ZXthY3Rpb259XG5cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgICAgICB0aGlzLiRfcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSB7fTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9XG5cbiAgICBfcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5faWRzID0gbmV3IE1vZGlmeS5JZHMoKTtcbiAgICAgICAgdGhpcy5fcHJlZmVyZW5jZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWZzID0gbmV3IFJlZi5NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl92YWxpZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2luZ2xlUnVsZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAvLyBUaGUgcnVsZSBvcHRpb25zIHBhc3NlZCBmb3Igbm9uLW11bHRpIHJ1bGVzXG5cbiAgICAgICAgdGhpcy4kX3Rlcm1zID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXNoIG9mIGFycmF5cyBvZiBpbW11dGFibGUgb2JqZWN0cyAoZXh0ZW5kZWQgYnkgb3RoZXIgdHlwZXMpXG5cbiAgICAgICAgdGhpcy4kX3RlbXAgPSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW50aW1lIHN0YXRlIChub3QgY2xvbmVkKVxuICAgICAgICAgICAgcnVsZXNldDogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGw6IHVzZSBsYXN0LCBmYWxzZTogZXJyb3IsIG51bWJlcjogc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgIHdoZW5zOiB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW50aW1lIGNhY2hlIG9mIGdlbmVyYXRlZCB3aGVuc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1hbmlmZXN0XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIE1hbmlmZXN0LmRlc2NyaWJlID09PSAnZnVuY3Rpb24nLCAnTWFuaWZlc3QgZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gTWFuaWZlc3QuZGVzY3JpYmUodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gUnVsZXNcblxuICAgIGFsbG93KC4uLnZhbHVlcykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ2FsbG93Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXModmFsdWVzLCAnX3ZhbGlkcycpO1xuICAgIH1cblxuICAgIGFsdGVyKHRhcmdldHMpIHtcblxuICAgICAgICBBc3NlcnQodGFyZ2V0cyAmJiB0eXBlb2YgdGFyZ2V0cyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0cyksICdJbnZhbGlkIHRhcmdldHMgYXJndW1lbnQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgYWx0ZXJhdGlvbnMgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMgPSBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucyB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgaW4gdGFyZ2V0cykge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZXIgPSB0YXJnZXRzW3RhcmdldF07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGFkanVzdGVyID09PSAnZnVuY3Rpb24nLCAnQWx0ZXJhdGlvbiBhZGp1c3RlciBmb3InLCB0YXJnZXQsICdtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zLnB1c2goeyB0YXJnZXQsIGFkanVzdGVyIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYXJ0aWZhY3QoaWQpIHtcblxuICAgICAgICBBc3NlcnQoaWQgIT09IHVuZGVmaW5lZCwgJ0FydGlmYWN0IGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9jYWNoZSwgJ0Nhbm5vdCBzZXQgYW4gYXJ0aWZhY3Qgd2l0aCBhIHJ1bGUgY2FjaGUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2FydGlmYWN0JywgaWQpO1xuICAgIH1cblxuICAgIGNhc3QodG8pIHtcblxuICAgICAgICBBc3NlcnQodG8gPT09IGZhbHNlIHx8IHR5cGVvZiB0byA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHRvIHZhbHVlJyk7XG4gICAgICAgIEFzc2VydCh0byA9PT0gZmFsc2UgfHwgdGhpcy5fZGVmaW5pdGlvbi5jYXN0W3RvXSwgJ1R5cGUnLCB0aGlzLnR5cGUsICdkb2VzIG5vdCBzdXBwb3J0IGNhc3RpbmcgdG8nLCB0byk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdjYXN0JywgdG8gPT09IGZhbHNlID8gdW5kZWZpbmVkIDogdG8pO1xuICAgIH1cblxuICAgIGRlZmF1bHQodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdCgnZGVmYXVsdCcsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbihkZXNjKSB7XG5cbiAgICAgICAgQXNzZXJ0KGRlc2MgJiYgdHlwZW9mIGRlc2MgPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Rlc2NyaXB0aW9uJywgZGVzYyk7XG4gICAgfVxuXG4gICAgZW1wdHkoc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NoZW1hID0gb2JqLiRfY29tcGlsZShzY2hlbWEsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX3NldEZsYWcoJ2VtcHR5Jywgc2NoZW1hLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBlcnJvcihlcnIpIHtcblxuICAgICAgICBBc3NlcnQoZXJyLCAnTWlzc2luZyBlcnJvcicpO1xuICAgICAgICBBc3NlcnQoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJywgJ011c3QgcHJvdmlkZSBhIHZhbGlkIEVycm9yIG9iamVjdCBvciBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdlcnJvcicsIGVycik7XG4gICAgfVxuXG4gICAgZXhhbXBsZShleGFtcGxlLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQoZXhhbXBsZSAhPT0gdW5kZWZpbmVkLCAnTWlzc2luZyBleGFtcGxlJyk7XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnb3ZlcnJpZGUnXSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdleGFtcGxlcycsIGV4YW1wbGUsIHsgc2luZ2xlOiB0cnVlLCBvdmVycmlkZTogb3B0aW9ucy5vdmVycmlkZSB9KTtcbiAgICB9XG5cbiAgICBleHRlcm5hbChtZXRob2QsIGRlc2NyaXB0aW9uKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBBc3NlcnQoIWRlc2NyaXB0aW9uLCAnQ2Fubm90IGNvbWJpbmUgb3B0aW9ucyB3aXRoIGRlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IG1ldGhvZC5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZC5tZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJywgJ01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgQXNzZXJ0KGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRpb24gJiYgdHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJywgJ0Rlc2NyaXB0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdleHRlcm5hbHMnLCB7IG1ldGhvZCwgZGVzY3JpcHRpb24gfSwgeyBzaW5nbGU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgZmFpbG92ZXIodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdCgnZmFpbG92ZXInLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZm9yYmlkZGVuKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdmb3JiaWRkZW4nKTtcbiAgICB9XG5cbiAgICBpZChpZCkge1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaWQnLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBpZCA9PT0gJ3N0cmluZycsICdpZCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICBBc3NlcnQoL15bXlxcLl0rJC8udGVzdChpZCksICdpZCBjYW5ub3QgY29udGFpbiBwZXJpb2QgY2hhcmFjdGVyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpZCcsIGlkKTtcbiAgICB9XG5cbiAgICBpbnZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXModmFsdWVzLCAnX2ludmFsaWRzJyk7XG4gICAgfVxuXG4gICAgbGFiZWwobmFtZSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ0xhYmVsIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2xhYmVsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgbWV0YShtZXRhKSB7XG5cbiAgICAgICAgQXNzZXJ0KG1ldGEgIT09IHVuZGVmaW5lZCwgJ01ldGEgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignbWV0YXMnLCBtZXRhLCB7IHNpbmdsZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBub3RlKC4uLm5vdGVzKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5vdGVzLmxlbmd0aCwgJ01pc3Npbmcgbm90ZXMnKTtcbiAgICAgICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVzKSB7XG4gICAgICAgICAgICBBc3NlcnQobm90ZSAmJiB0eXBlb2Ygbm90ZSA9PT0gJ3N0cmluZycsICdOb3RlcyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ25vdGVzJywgbm90ZXMpO1xuICAgIH1cblxuICAgIG9ubHkobW9kZSA9IHRydWUpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGUgPT09ICdib29sZWFuJywgJ0ludmFsaWQgbW9kZTonLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ29ubHknLCBtb2RlKTtcbiAgICB9XG5cbiAgICBvcHRpb25hbCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgnb3B0aW9uYWwnKTtcbiAgICB9XG5cbiAgICBwcmVmcyhwcmVmcykge1xuXG4gICAgICAgIEFzc2VydChwcmVmcywgJ01pc3NpbmcgcHJlZmVyZW5jZXMnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmNvbnRleHQgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBjb250ZXh0Jyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5leHRlcm5hbHMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBleHRlcm5hbHMnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLndhcm5pbmdzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgd2FybmluZ3MnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmRlYnVnID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgZGVidWcnKTtcblxuICAgICAgICBDb21tb24uY2hlY2tQcmVmZXJlbmNlcyhwcmVmcyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHByZWZzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBwcmVzZW5jZShtb2RlKSB7XG5cbiAgICAgICAgQXNzZXJ0KFsnb3B0aW9uYWwnLCAncmVxdWlyZWQnLCAnZm9yYmlkZGVuJ10uaW5jbHVkZXMobW9kZSksICdVbmtub3duIHByZXNlbmNlIG1vZGUnLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3ByZXNlbmNlJywgbW9kZSk7XG4gICAgfVxuXG4gICAgcmF3KGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBlbmFibGVkID8gJ3JhdycgOiB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJlc3VsdChtb2RlKSB7XG5cbiAgICAgICAgQXNzZXJ0KFsncmF3JywgJ3N0cmlwJ10uaW5jbHVkZXMobW9kZSksICdVbmtub3duIHJlc3VsdCBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBtb2RlKTtcbiAgICB9XG5cbiAgICByZXF1aXJlZCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgncmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBzdHJpY3QoZW5hYmxlZCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBjb252ZXJ0ID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAhZW5hYmxlZDtcbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IENvbW1vbi5wcmVmZXJlbmNlcyhvYmouX3ByZWZlcmVuY2VzLCB7IGNvbnZlcnQgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RyaXAoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIGVuYWJsZWQgPyAnc3RyaXAnIDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICB0YWcoLi4udGFncykge1xuXG4gICAgICAgIEFzc2VydCh0YWdzLmxlbmd0aCwgJ01pc3NpbmcgdGFncycpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICBBc3NlcnQodGFnICYmIHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnLCAnVGFncyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ3RhZ3MnLCB0YWdzKTtcbiAgICB9XG5cbiAgICB1bml0KG5hbWUpIHtcblxuICAgICAgICBBc3NlcnQobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdVbml0IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3VuaXQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICd2YWxpZCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuYWxsb3coLi4udmFsdWVzKTtcbiAgICAgICAgb2JqLiRfc2V0RmxhZygnb25seScsICEhb2JqLl92YWxpZHMsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHdoZW4oY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICghb2JqLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aGVuID0gQ29tcGlsZS53aGVuKG9iaiwgY29uZGl0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFbJ2FueScsICdsaW5rJ10uaW5jbHVkZXMob2JqLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIWl0ZW0udGhlbiB8fCBpdGVtLnRoZW4udHlwZSA9PT0gJ2FueScgfHwgaXRlbS50aGVuLnR5cGUgPT09IG9iai50eXBlLCAnQ2Fubm90IGNvbWJpbmUnLCBvYmoudHlwZSwgJ3dpdGgnLCBpdGVtLnRoZW4gJiYgaXRlbS50aGVuLnR5cGUpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghaXRlbS5vdGhlcndpc2UgfHwgaXRlbS5vdGhlcndpc2UudHlwZSA9PT0gJ2FueScgfHwgaXRlbS5vdGhlcndpc2UudHlwZSA9PT0gb2JqLnR5cGUsICdDYW5ub3QgY29tYmluZScsIG9iai50eXBlLCAnd2l0aCcsIGl0ZW0ub3RoZXJ3aXNlICYmIGl0ZW0ub3RoZXJ3aXNlLnR5cGUpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZXJtcy53aGVucy5wdXNoKHdoZW4pO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIC8vIEhlbHBlcnNcblxuICAgIGNhY2hlKGNhY2hlKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgY2FjaGluZyBpbnNpZGUgYSBydWxlc2V0Jyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5fY2FjaGUsICdDYW5ub3Qgb3ZlcnJpZGUgc2NoZW1hIGNhY2hlJyk7XG4gICAgICAgIEFzc2VydCh0aGlzLl9mbGFncy5hcnRpZmFjdCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhY2hlIGEgcnVsZSB3aXRoIGFuIGFydGlmYWN0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2NhY2hlID0gY2FjaGUgfHwgQ2FjaGUucHJvdmlkZXIucHJvdmlzaW9uKCk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihvYmopO1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSksICdJbnZhbGlkIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgQXNzZXJ0KHRoaXMudHlwZSA9PT0gJ2FueScgfHwgc291cmNlLnR5cGUgPT09ICdhbnknIHx8IHNvdXJjZS50eXBlID09PSB0aGlzLnR5cGUsICdDYW5ub3QgbWVyZ2UgdHlwZScsIHRoaXMudHlwZSwgJ3dpdGggYW5vdGhlciB0eXBlOicsIHNvdXJjZS50eXBlKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBjb25jYXRlbmF0ZSBvbnRvIGEgc2NoZW1hIHdpdGggb3BlbiBydWxlc2V0Jyk7XG4gICAgICAgIEFzc2VydCghc291cmNlLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBjb25jYXRlbmF0ZSBhIHNjaGVtYSB3aXRoIG9wZW4gcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2FueScgJiZcbiAgICAgICAgICAgIHNvdXJjZS50eXBlICE9PSAnYW55Jykge1xuXG4gICAgICAgICAgICAvLyBDaGFuZ2Ugb2JqIHRvIG1hdGNoIHNvdXJjZSB0eXBlXG5cbiAgICAgICAgICAgIGNvbnN0IHRtcE9iaiA9IHNvdXJjZS5jbG9uZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICB0bXBPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqID0gdG1wT2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9pZHMuY29uY2F0KHNvdXJjZS5faWRzKTtcbiAgICAgICAgb2JqLl9yZWZzLnJlZ2lzdGVyKHNvdXJjZSwgUmVmLnRvU2libGluZyk7XG5cbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IG9iai5fcHJlZmVyZW5jZXMgPyBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgc291cmNlLl9wcmVmZXJlbmNlcykgOiBzb3VyY2UuX3ByZWZlcmVuY2VzO1xuICAgICAgICBvYmouX3ZhbGlkcyA9IFZhbHVlcy5tZXJnZShvYmouX3ZhbGlkcywgc291cmNlLl92YWxpZHMsIHNvdXJjZS5faW52YWxpZHMpO1xuICAgICAgICBvYmouX2ludmFsaWRzID0gVmFsdWVzLm1lcmdlKG9iai5faW52YWxpZHMsIHNvdXJjZS5faW52YWxpZHMsIHNvdXJjZS5fdmFsaWRzKTtcblxuICAgICAgICAvLyBSZW1vdmUgdW5pcXVlIHJ1bGVzIHByZXNlbnQgaW4gc291cmNlXG5cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHNvdXJjZS5fc2luZ2xlUnVsZXMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAob2JqLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvYmouX3J1bGVzID0gb2JqLl9ydWxlcy5maWx0ZXIoKHRhcmdldCkgPT4gdGFyZ2V0LmtlZXAgfHwgdGFyZ2V0Lm5hbWUgIT09IG5hbWUpO1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVsZXNcblxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2Ygc291cmNlLl9ydWxlcykge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX2RlZmluaXRpb24ucnVsZXNbdGVzdC5tZXRob2RdLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQodGVzdC5uYW1lLCB0ZXN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9ydWxlcy5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmxhZ3NcblxuICAgICAgICBpZiAob2JqLl9mbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgc291cmNlLl9mbGFncy5lbXB0eSkge1xuXG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gb2JqLl9mbGFncy5lbXB0eS5jb25jYXQoc291cmNlLl9mbGFncy5lbXB0eSk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgTWVyZ2Uob2JqLl9mbGFncywgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5fZmxhZ3MuZW1wdHkpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3MuZW1wdHkgPSBzb3VyY2UuX2ZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVybXNcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UuJF90ZXJtcykge1xuICAgICAgICAgICAgY29uc3QgdGVybXMgPSBzb3VyY2UuJF90ZXJtc1trZXldO1xuICAgICAgICAgICAgaWYgKCF0ZXJtcykge1xuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gdGVybXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXNba2V5XSkge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zW2tleV0gPSB0ZXJtcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gb2JqLiRfdGVybXNba2V5XS5jb25jYXQodGVybXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2luZ1xuXG4gICAgICAgIGlmICh0aGlzLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLiRfcm9vdC5fdHJhY2VyLl9jb21iaW5lKG9iaiwgW3RoaXMsIHNvdXJjZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVidWlsZFxuXG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgZXh0ZW5kKG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYmFzZSwgJ0Nhbm5vdCBleHRlbmQgdHlwZSB3aXRoIGFub3RoZXIgYmFzZScpO1xuXG4gICAgICAgIHJldHVybiBFeHRlbmQudHlwZSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBleHRyYWN0KHBhdGgpIHtcblxuICAgICAgICBwYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHMucmVhY2gocGF0aCk7XG4gICAgfVxuXG4gICAgZm9yayhwYXRocywgYWRqdXN0ZXIpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGZvcmsgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgW10uY29uY2F0KHBhdGhzKSkge1xuICAgICAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgb2JqID0gb2JqLl9pZHMuZm9yayhwYXRoLCBhZGp1c3Rlciwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJ1bGUob3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZmluaXRpb247XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIE9iamVjdC5rZXlzKGRlZi5tb2RpZmllcnMpKTtcblxuICAgICAgICBBc3NlcnQodGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2UsICdDYW5ub3QgYXBwbHkgcnVsZXMgdG8gZW1wdHkgcnVsZXNldCBvciB0aGUgbGFzdCBydWxlIGFkZGVkIGRvZXMgbm90IHN1cHBvcnQgcnVsZSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy4kX3RlbXAucnVsZXNldCA9PT0gbnVsbCA/IHRoaXMuX3J1bGVzLmxlbmd0aCAtIDEgOiB0aGlzLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICBBc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMuX3J1bGVzLmxlbmd0aCwgJ0Nhbm5vdCBhcHBseSBydWxlcyB0byBlbXB0eSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG9iai5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gb2JqLl9ydWxlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBDbG9uZShvcmlnaW5hbCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVmLm1vZGlmaWVyc1tuYW1lXShydWxlLCBvcHRpb25zW25hbWVdKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQocnVsZS5uYW1lID09PSBvcmlnaW5hbC5uYW1lLCAnQ2Fubm90IGNoYW5nZSBydWxlIG5hbWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9ydWxlc1tpXSA9IHJ1bGU7XG5cbiAgICAgICAgICAgIGlmIChvYmouX3NpbmdsZVJ1bGVzLmdldChydWxlLm5hbWUpID09PSBvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBnZXQgcnVsZXNldCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHN0YXJ0IGEgbmV3IHJ1bGVzZXQgd2l0aG91dCBjbG9zaW5nIHRoZSBwcmV2aW91cyBvbmUnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IG9iai5fcnVsZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGdldCAkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzZXQ7XG4gICAgfVxuXG4gICAgdGFpbG9yKHRhcmdldHMpIHtcblxuICAgICAgICB0YXJnZXRzID0gW10uY29uY2F0KHRhcmdldHMpO1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgdGFpbG9yIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG5cbiAgICAgICAgaWYgKHRoaXMuJF90ZXJtcy5hbHRlcmF0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgYWRqdXN0ZXIgfSBvZiB0aGlzLiRfdGVybXMuYWx0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGFkanVzdGVyKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEob2JqKSwgJ0FsdGVyYXRpb24gYWRqdXN0ZXIgZm9yJywgdGFyZ2V0LCAnZmFpbGVkIHRvIHJldHVybiBhIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBvYmouJF9tb2RpZnkoeyBlYWNoOiAoaXRlbSkgPT4gaXRlbS50YWlsb3IodGFyZ2V0cyksIHJlZjogZmFsc2UgfSk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIHRyYWNlcigpIHtcblxuICAgICAgICByZXR1cm4gVHJhY2UubG9jYXRpb24gPyBUcmFjZS5sb2NhdGlvbih0aGlzKSA6IHRoaXM7ICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIH1cblxuICAgIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci5lbnRyeSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVBc3luYyh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBWYWxpZGF0b3IuZW50cnlBc3luYyh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9uc1xuXG4gICAgJF9hZGRSdWxlKG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBOb3JtYWxpemUgcnVsZVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9ucycpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5uYW1lICYmIHR5cGVvZiBvcHRpb25zLm5hbWUgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBydWxlIG5hbWUnKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBBc3NlcnQoa2V5WzBdICE9PSAnXycsICdDYW5ub3Qgc2V0IHByaXZhdGUgcnVsZSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBydWxlID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBydWxlLl9yZXNvbHZlID0gW107XG4gICAgICAgIHJ1bGUubWV0aG9kID0gcnVsZS5tZXRob2QgfHwgcnVsZS5uYW1lO1xuXG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLl9kZWZpbml0aW9uLnJ1bGVzW3J1bGUubWV0aG9kXTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJ1bGUuYXJncztcblxuICAgICAgICBBc3NlcnQoZGVmaW5pdGlvbiwgJ1Vua25vd24gcnVsZScsIHJ1bGUubWV0aG9kKTtcblxuICAgICAgICAvLyBBcmdzXG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICBBc3NlcnQoT2JqZWN0LmtleXMoYXJncykubGVuZ3RoID09PSAxIHx8IE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA9PT0gdGhpcy5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm5hbWVdLmFyZ3MubGVuZ3RoLCAnSW52YWxpZCBydWxlIGRlZmluaXRpb24gZm9yJywgdGhpcy50eXBlLCBydWxlLm5hbWUpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmFyZ3NCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBkZWZpbml0aW9uLmFyZ3NCeU5hbWUuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyLnJlZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmlzUmVzb2x2YWJsZShhcmcpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuX3Jlc29sdmUucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSByZXNvbHZlci5ub3JtYWxpemUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5hc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IENvbW1vbi52YWxpZGF0ZUFyZyhhcmcsIGtleSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCghZXJyb3IsIGVycm9yLCAnb3IgcmVmZXJlbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5pcXVlIHJ1bGVzXG5cbiAgICAgICAgaWYgKCFkZWZpbml0aW9uLm11bHRpKSB7XG4gICAgICAgICAgICBvYmouX3J1bGVSZW1vdmUocnVsZS5uYW1lLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLiRfdGVtcC5ydWxlc2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnVuc2hpZnQocnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgICRfY29tcGlsZShzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gQ29tcGlsZS5zY2hlbWEodGhpcy4kX3Jvb3QsIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgJF9jcmVhdGVFcnJvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIHN0YXRlLCBwcmVmcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRpb25zLmZsYWdzICE9PSBmYWxzZSA/IHRoaXMuX2ZsYWdzIDoge307XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcyA/IE1lc3NhZ2VzLm1lcmdlKHRoaXMuX2RlZmluaXRpb24ubWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMpIDogdGhpcy5fZGVmaW5pdGlvbi5tZXNzYWdlcztcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcnMuUmVwb3J0KGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgICRfZ2V0RmxhZyhuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzW25hbWVdO1xuICAgIH1cblxuICAgICRfZ2V0UnVsZShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZVJ1bGVzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAkX21hcExhYmVscyhwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5faWRzLmxhYmVscyhwYXRoKTtcbiAgICB9XG5cbiAgICAkX21hdGNoKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcykge1xuXG4gICAgICAgIHByZWZzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJlZnMpOyAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBwcmVmcy5hYm9ydEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgcHJlZnMuX2V4dGVybmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXRlLnNuYXBzaG90KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICFWYWxpZGF0b3IudmFsaWRhdGUodmFsdWUsIHRoaXMsIHN0YXRlLCBwcmVmcywgb3ZlcnJpZGVzKS5lcnJvcnM7XG4gICAgICAgIHN0YXRlLnJlc3RvcmUoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgICRfbW9kaWZ5KG9wdGlvbnMpIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2VhY2gnLCAnb25jZScsICdyZWYnLCAnc2NoZW1hJ10pO1xuICAgICAgICByZXR1cm4gTW9kaWZ5LnNjaGVtYSh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cblxuICAgICRfbXV0YXRlUmVidWlsZCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGFkZCB0aGlzIHJ1bGUgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIHRoaXMuX3JlZnMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5faWRzLnJlc2V0KCk7XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pID0+IHtcblxuICAgICAgICAgICAgY29uc3QgZmFtaWx5ID0gdGhpcy5fZGVmaW5pdGlvbltzb3VyY2VdW25hbWVdICYmIHRoaXMuX2RlZmluaXRpb25bc291cmNlXVtuYW1lXS5yZWdpc3RlcjtcbiAgICAgICAgICAgIGlmIChmYW1pbHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kX211dGF0ZVJlZ2lzdGVyKGl0ZW0sIHsgZmFtaWx5LCBrZXkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy4kX21vZGlmeSh7IGVhY2ggfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluaXRpb24ucmVidWlsZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVmaW5pdGlvbi5yZWJ1aWxkKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAkX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSwgeyBmYW1pbHksIGtleSB9ID0ge30pIHtcblxuICAgICAgICB0aGlzLl9yZWZzLnJlZ2lzdGVyKHNjaGVtYSwgZmFtaWx5KTtcbiAgICAgICAgdGhpcy5faWRzLnJlZ2lzdGVyKHNjaGVtYSwgeyBrZXkgfSk7XG4gICAgfVxuXG4gICAgJF9wcm9wZXJ0eShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24ucHJvcGVydGllc1tuYW1lXTtcbiAgICB9XG5cbiAgICAkX3JlYWNoKHBhdGgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5faWRzLnJlYWNoKHBhdGgpO1xuICAgIH1cblxuICAgICRfcm9vdFJlZmVyZW5jZXMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZnMucm9vdHMoKTtcbiAgICB9XG5cbiAgICAkX3NldEZsYWcobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lWzBdID09PSAnXycgfHwgIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBmbGFnIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBmbGFnID0gdGhpcy5fZGVmaW5pdGlvbi5mbGFnc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgaWYgKERlZXBFcXVhbCh2YWx1ZSwgZmxhZy5kZWZhdWx0KSkge1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRGVlcEVxdWFsKHZhbHVlLCB0aGlzLl9mbGFnc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqLl9mbGFnc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAkX3BhcmVudChtZXRob2QsIC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdW0NvbW1vbi5zeW1ib2xzLnBhcmVudF0uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICAkX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCB0aGlzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIC8vIEludGVybmFsc1xuXG4gICAgX2Fzc2lnbih0YXJnZXQpIHtcblxuICAgICAgICB0YXJnZXQudHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICB0YXJnZXQuJF9yb290ID0gdGhpcy4kX3Jvb3Q7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVtcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJF90ZW1wKTtcbiAgICAgICAgdGFyZ2V0LiRfdGVtcC53aGVucyA9IHt9O1xuXG4gICAgICAgIHRhcmdldC5faWRzID0gdGhpcy5faWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fcHJlZmVyZW5jZXMgPSB0aGlzLl9wcmVmZXJlbmNlcztcbiAgICAgICAgdGFyZ2V0Ll92YWxpZHMgPSB0aGlzLl92YWxpZHMgJiYgdGhpcy5fdmFsaWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5faW52YWxpZHMgPSB0aGlzLl9pbnZhbGlkcyAmJiB0aGlzLl9pbnZhbGlkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX3J1bGVzID0gdGhpcy5fcnVsZXMuc2xpY2UoKTtcbiAgICAgICAgdGFyZ2V0Ll9zaW5nbGVSdWxlcyA9IENsb25lKHRoaXMuX3NpbmdsZVJ1bGVzLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIHRhcmdldC5fcmVmcyA9IHRoaXMuX3JlZnMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9mbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ZsYWdzKTtcbiAgICAgICAgdGFyZ2V0Ll9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVybXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kX3Rlcm1zKSB7XG4gICAgICAgICAgICB0YXJnZXQuJF90ZXJtc1trZXldID0gdGhpcy4kX3Rlcm1zW2tleV0gPyB0aGlzLiRfdGVybXNba2V5XS5zbGljZSgpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgdGFyZ2V0LiRfc3VwZXIgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBpbiB0aGlzLiRfc3VwZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC4kX3N1cGVyW292ZXJyaWRlXSA9IHRoaXMuX3N1cGVyW292ZXJyaWRlXS5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIF9iYXJlKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9yZXNldCgpO1xuXG4gICAgICAgIGNvbnN0IHRlcm1zID0gb2JqLl9kZWZpbml0aW9uLnRlcm1zO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGVybXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtc1tuYW1lXTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW25hbWVdID0gdGVybS5pbml0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBfZGVmYXVsdChmbGFnLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgJ2xpdGVyYWwnKTtcblxuICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ01pc3NpbmcnLCBmbGFnLCAndmFsdWUnKTtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhb3B0aW9ucy5saXRlcmFsLCAnT25seSBmdW5jdGlvbiB2YWx1ZSBzdXBwb3J0cyBsaXRlcmFsIG9wdGlvbicpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdGlvbnMubGl0ZXJhbCkge1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF06IHRydWUsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfc2V0RmxhZyhmbGFnLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xsZWN0IG1hdGNoaW5nIHdoZW5zXG5cbiAgICAgICAgY29uc3Qgd2hlbnMgPSBbXTtcbiAgICAgICAgY29uc3QgaWRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4kX3Rlcm1zLndoZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB3aGVuID0gdGhpcy4kX3Rlcm1zLndoZW5zW2ldO1xuXG4gICAgICAgICAgICBpZiAod2hlbi5jb25jYXQpIHtcbiAgICAgICAgICAgICAgICB3aGVucy5wdXNoKHdoZW4uY29uY2F0KTtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtpfS5jb25jYXRgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB3aGVuLnJlZiA/IHdoZW4ucmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcykgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gaWRzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXMsIHRoZW4sIG90aGVyd2lzZSB9ID0gdGVzdHNbal07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlSWQgPSBgJHtpfSR7d2hlbi5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7YmFzZUlkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgYCR7YmFzZUlkfS50aGVuYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYTogZ2VuZXJhdGVkLCBpZCB9ID0gdGhlbi5fZ2VuZXJhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2Jhc2VJZH0udGhlbiR7aWQgPyBgKCR7aWR9KWAgOiAnJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGAke2Jhc2VJZH0ub3RoZXJ3aXNlYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hOiBnZW5lcmF0ZWQsIGlkIH0gPSBvdGhlcndpc2UuX2dlbmVyYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7YmFzZUlkfS5vdGhlcndpc2Uke2lkID8gYCgke2lkfSlgIDogJyd9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdoZW4uYnJlYWsgJiZcbiAgICAgICAgICAgICAgICBpZHMubGVuZ3RoID4gYmVmb3JlKSB7ICAgICAgICAgIC8vIFNvbWV0aGluZyBtYXRjaGVkXG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGNhY2hlXG5cbiAgICAgICAgY29uc3QgaWQgPSBpZHMuam9pbignLCAnKTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAncnVsZScsICd3aGVuJywgaWQpO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS50cmFjZXIuYWN0aXZlICYmXG4gICAgICAgICAgICB0aGlzLiRfdGVtcC53aGVuc1tpZF0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzLiRfdGVtcC53aGVuc1tpZF0sIGlkIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBkeW5hbWljIHNjaGVtYVxuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKHRoaXMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgd2hlbnNcblxuICAgICAgICBmb3IgKGNvbnN0IHdoZW4gb2Ygd2hlbnMpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQod2hlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjaW5nXG5cbiAgICAgICAgaWYgKHRoaXMuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJF9yb290Ll90cmFjZXIuX2NvbWJpbmUob2JqLCBbdGhpcywgLi4ud2hlbnNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhY2hlIHJlc3VsdFxuXG4gICAgICAgIHRoaXMuJF90ZW1wLndoZW5zW2lkXSA9IG9iajtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBvYmosIGlkIH07XG4gICAgfVxuXG4gICAgX2lubmVyKHR5cGUsIHZhbHVlcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgYENhbm5vdCBzZXQgJHt0eXBlfSBpbnNpZGUgYSBydWxlc2V0YCk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW3R5cGVdIHx8XG4gICAgICAgICAgICBvcHRpb25zLm92ZXJyaWRlKSB7XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zaW5nbGUpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2godmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2goLi4udmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9pblJ1bGVzZXQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IG51bGwgJiYgdGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3J1bGVSZW1vdmUobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdGVzdCA9IG9iai5fcnVsZXNbaV07XG4gICAgICAgICAgICBpZiAodGVzdC5uYW1lID09PSBuYW1lICYmXG4gICAgICAgICAgICAgICAgIXRlc3Qua2VlcCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iai5faW5SdWxlc2V0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA8IG9iai4kX3RlbXAucnVsZXNldCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC0tb2JqLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9ydWxlcyA9IGZpbHRlcmVkO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF92YWx1ZXModmFsdWVzLCBrZXkpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsIGtleS5zbGljZSgxLCAtMSkpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBvdmVycmlkZSA9IHZhbHVlc1swXSA9PT0gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGU7XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvYmpba2V5XSAmJlxuICAgICAgICAgICAgdmFsdWVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBvYmpba2V5XSA9IG5ldyBWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZXMubGVuZ3RoID8gbmV3IFZhbHVlcygpIDogbnVsbDtcbiAgICAgICAgICAgIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG9ialtrZXldLm92ZXJyaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBhbGxvdy92YWxpZC9pbnZhbGlkIHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLCAnT3ZlcnJpZGUgbXVzdCBiZSB0aGUgZmlyc3QgdmFsdWUnKTtcblxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBrZXkgPT09ICdfaW52YWxpZHMnID8gJ192YWxpZHMnIDogJ19pbnZhbGlkcyc7XG4gICAgICAgICAgICBpZiAob2JqW290aGVyXSkge1xuICAgICAgICAgICAgICAgIG9ialtvdGhlcl0ucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9ialtvdGhlcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXkgPT09ICdfdmFsaWRzJyB8fCAhb2JqLl9mbGFncy5vbmx5LCAnU2V0dGluZyBpbnZhbGlkIHZhbHVlJywgdmFsdWUsICdsZWF2ZXMgc2NoZW1hIHJlamVjdGluZyBhbGwgdmFsdWVzIGR1ZSB0byBwcmV2aW91cyB2YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIG9ialtvdGhlcl0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqW2tleV0uYWRkKHZhbHVlLCBvYmouX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5hbnldID0ge1xuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNvbXBpbGU6IENvbXBpbGUuY29tcGlsZSxcbiAgICByb290OiAnJF9yb290J1xufTtcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzIChtdXN0IGJlIG9uIHByb3RvdHlwZSlcblxuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5kZW55ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZGlzYWxsb3cgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5lcXVhbCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5leGlzdCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5yZXF1aXJlZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5ub3QgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5vcHRpb25zID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZlcmVuY2VzID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5CYXNlKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/cache.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/cache.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    max: 1000,\n    supported: new Set(['undefined', 'boolean', 'number', 'string'])\n};\n\n\nexports.provider = {\n\n    provision(options) {\n\n        return new internals.Cache(options);\n    }\n};\n\n\n// Least Recently Used (LRU) Cache\n\ninternals.Cache = class {\n\n    constructor(options = {}) {\n\n        Common.assertOptions(options, ['max']);\n        Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');\n\n        this._max = options.max || internals.max;\n\n        this._map = new Map();                          // Map of nodes by key\n        this._list = new internals.List();              // List of nodes (most recently used in head)\n    }\n\n    get length() {\n\n        return this._map.size;\n    }\n\n    set(key, value) {\n\n        if (key !== null &&\n            !internals.supported.has(typeof key)) {\n\n            return;\n        }\n\n        let node = this._map.get(key);\n        if (node) {\n            node.value = value;\n            this._list.first(node);\n            return;\n        }\n\n        node = this._list.unshift({ key, value });\n        this._map.set(key, node);\n        this._compact();\n    }\n\n    get(key) {\n\n        const node = this._map.get(key);\n        if (node) {\n            this._list.first(node);\n            return Clone(node.value);\n        }\n    }\n\n    _compact() {\n\n        if (this._map.size > this._max) {\n            const node = this._list.pop();\n            this._map.delete(node.key);\n        }\n    }\n};\n\n\ninternals.List = class {\n\n    constructor() {\n\n        this.tail = null;\n        this.head = null;\n    }\n\n    unshift(node) {\n\n        node.next = null;\n        node.prev = this.head;\n\n        if (this.head) {\n            this.head.next = node;\n        }\n\n        this.head = node;\n\n        if (!this.tail) {\n            this.tail = node;\n        }\n\n        return node;\n    }\n\n    first(node) {\n\n        if (node === this.head) {\n            return;\n        }\n\n        this._remove(node);\n        this.unshift(node);\n    }\n\n    pop() {\n\n        return this._remove(this.tail);\n    }\n\n    _remove(node) {\n\n        const { next, prev } = node;\n\n        next.prev = prev;\n\n        if (prev) {\n            prev.next = next;\n        }\n\n        if (node === this.tail) {\n            this.tail = next;\n        }\n\n        node.prev = null;\n        node.next = null;\n\n        return node;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsNEVBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQywwRUFBc0I7O0FBRTVDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBOztBQUVBLHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixhQUFhOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY2FjaGUuanM/OTE3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtYXg6IDEwMDAsXG4gICAgc3VwcG9ydGVkOiBuZXcgU2V0KFsndW5kZWZpbmVkJywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddKVxufTtcblxuXG5leHBvcnRzLnByb3ZpZGVyID0ge1xuXG4gICAgcHJvdmlzaW9uKG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5DYWNoZShvcHRpb25zKTtcbiAgICB9XG59O1xuXG5cbi8vIExlYXN0IFJlY2VudGx5IFVzZWQgKExSVSkgQ2FjaGVcblxuaW50ZXJuYWxzLkNhY2hlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydtYXgnXSk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm1heCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4ICYmIG9wdGlvbnMubWF4ID4gMCAmJiBpc0Zpbml0ZShvcHRpb25zLm1heCksICdJbnZhbGlkIG1heCBjYWNoZSBzaXplJyk7XG5cbiAgICAgICAgdGhpcy5fbWF4ID0gb3B0aW9ucy5tYXggfHwgaW50ZXJuYWxzLm1heDtcblxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXAgb2Ygbm9kZXMgYnkga2V5XG4gICAgICAgIHRoaXMuX2xpc3QgPSBuZXcgaW50ZXJuYWxzLkxpc3QoKTsgICAgICAgICAgICAgIC8vIExpc3Qgb2Ygbm9kZXMgKG1vc3QgcmVjZW50bHkgdXNlZCBpbiBoZWFkKVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgIWludGVybmFscy5zdXBwb3J0ZWQuaGFzKHR5cGVvZiBrZXkpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fbGlzdC5maXJzdChub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSB0aGlzLl9saXN0LnVuc2hpZnQoeyBrZXksIHZhbHVlIH0pO1xuICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbm9kZSk7XG4gICAgICAgIHRoaXMuX2NvbXBhY3QoKTtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3QuZmlyc3Qobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUobm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY29tcGFjdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5fbWFwLnNpemUgPiB0aGlzLl9tYXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9saXN0LnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShub2RlLmtleSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5MaXN0ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB9XG5cbiAgICB1bnNoaWZ0KG5vZGUpIHtcblxuICAgICAgICBub2RlLm5leHQgPSBudWxsO1xuICAgICAgICBub2RlLnByZXYgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkLm5leHQgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcblxuICAgICAgICBpZiAoIXRoaXMudGFpbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGZpcnN0KG5vZGUpIHtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XG4gICAgICAgIHRoaXMudW5zaGlmdChub2RlKTtcbiAgICB9XG5cbiAgICBwb3AoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZSh0aGlzLnRhaWwpO1xuICAgIH1cblxuICAgIF9yZW1vdmUobm9kZSkge1xuXG4gICAgICAgIGNvbnN0IHsgbmV4dCwgcHJldiB9ID0gbm9kZTtcblxuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuXG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucHJldiA9IG51bGw7XG4gICAgICAgIG5vZGUubmV4dCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/common.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/common.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst AssertError = __webpack_require__(/*! @hapi/hoek/lib/error */ \"(rsc)/./node_modules/@hapi/hoek/lib/error.js\");\n\nconst Pkg = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/joi/package.json\");\n\nlet Messages;\nlet Schemas;\n\n\nconst internals = {\n    isoDate: /^(?:[-+]\\d{2})?(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/\n};\n\n\nexports.version = Pkg.version;\n\n\nexports.defaults = {\n    abortEarly: true,\n    allowUnknown: false,\n    artifacts: false,\n    cache: true,\n    context: null,\n    convert: true,\n    dateFormat: 'iso',\n    errors: {\n        escapeHtml: false,\n        label: 'path',\n        language: null,\n        render: true,\n        stack: false,\n        wrap: {\n            label: '\"',\n            array: '[]'\n        }\n    },\n    externals: true,\n    messages: {},\n    nonEnumerables: false,\n    noDefaults: false,\n    presence: 'optional',\n    skipFunctions: false,\n    stripUnknown: false,\n    warnings: false\n};\n\n\nexports.symbols = {\n    any: Symbol.for('@hapi/joi/schema'),            // Used to internally identify any-based types (shared with other joi versions)\n    arraySingle: Symbol('arraySingle'),\n    deepDefault: Symbol('deepDefault'),\n    errors: Symbol('errors'),\n    literal: Symbol('literal'),\n    override: Symbol('override'),\n    parent: Symbol('parent'),\n    prefs: Symbol('prefs'),\n    ref: Symbol('ref'),\n    template: Symbol('template'),\n    values: Symbol('values')\n};\n\n\nexports.assertOptions = function (options, keys, name = 'Options') {\n\n    Assert(options && typeof options === 'object' && !Array.isArray(options), 'Options must be of type object');\n    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));\n    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);\n};\n\n\nexports.checkPreferences = function (prefs) {\n\n    Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/joi/lib/schemas.js\");\n\n    const result = Schemas.preferences.validate(prefs);\n\n    if (result.error) {\n        throw new AssertError([result.error.details[0].message]);\n    }\n};\n\n\nexports.compare = function (a, b, operator) {\n\n    switch (operator) {\n        case '=': return a === b;\n        case '>': return a > b;\n        case '<': return a < b;\n        case '>=': return a >= b;\n        case '<=': return a <= b;\n    }\n};\n\n\nexports[\"default\"] = function (value, defaultValue) {\n\n    return value === undefined ? defaultValue : value;\n};\n\n\nexports.isIsoDate = function (date) {\n\n    return internals.isoDate.test(date);\n};\n\n\nexports.isNumber = function (value) {\n\n    return typeof value === 'number' && !isNaN(value);\n};\n\n\nexports.isResolvable = function (obj) {\n\n    if (!obj) {\n        return false;\n    }\n\n    return obj[exports.symbols.ref] || obj[exports.symbols.template];\n};\n\n\nexports.isSchema = function (schema, options = {}) {\n\n    const any = schema && schema[exports.symbols.any];\n    if (!any) {\n        return false;\n    }\n\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\n    return true;\n};\n\n\nexports.isValues = function (obj) {\n\n    return obj[exports.symbols.values];\n};\n\n\nexports.limit = function (value) {\n\n    return Number.isSafeInteger(value) && value >= 0;\n};\n\n\nexports.preferences = function (target, source) {\n\n    Messages = Messages || __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\n\n    target = target || {};\n    source = source || {};\n\n    const merged = Object.assign({}, target, source);\n    if (source.errors &&\n        target.errors) {\n\n        merged.errors = Object.assign({}, target.errors, source.errors);\n        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);\n    }\n\n    if (source.messages) {\n        merged.messages = Messages.compile(source.messages, target.messages);\n    }\n\n    delete merged[exports.symbols.prefs];\n    return merged;\n};\n\n\nexports.tryWithPath = function (fn, key, options = {}) {\n\n    try {\n        return fn();\n    }\n    catch (err) {\n        if (err.path !== undefined) {\n            err.path = key + '.' + err.path;\n        }\n        else {\n            err.path = key;\n        }\n\n        if (options.append) {\n            err.message = `${err.message} (${err.path})`;\n        }\n\n        throw err;\n    }\n};\n\n\nexports.validateArg = function (value, label, { assert, message }) {\n\n    if (exports.isSchema(assert)) {\n        const result = assert.validate(value);\n        if (!result.error) {\n            return;\n        }\n\n        return result.error.message;\n    }\n    else if (!assert(value)) {\n        return label ? `${label} ${message}` : message;\n    }\n};\n\n\nexports.verifyFlat = function (args, method) {\n\n    for (const arg of args) {\n        Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1QjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBc0I7O0FBRWxELFlBQVksbUJBQU8sQ0FBQyw4REFBaUI7O0FBRXJDO0FBQ0E7OztBQUdBO0FBQ0EseUJBQXlCLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSx5SEFBeUgsRUFBRTtBQUN4Szs7O0FBR0EsZUFBZTs7O0FBR2YsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLHdDQUF3QyxNQUFNLHdCQUF3QixZQUFZO0FBQ2xGOzs7QUFHQSx3QkFBd0I7O0FBRXhCLHlCQUF5QixtQkFBTyxDQUFDLDBEQUFXOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxrQkFBZTs7QUFFZjtBQUNBOzs7QUFHQSxpQkFBaUI7O0FBRWpCO0FBQ0E7OztBQUdBLGdCQUFnQjs7QUFFaEI7QUFDQTs7O0FBR0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsZ0JBQWdCLGlDQUFpQzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7OztBQUdBLGFBQWE7O0FBRWI7QUFDQTs7O0FBR0EsbUJBQW1COztBQUVuQiwyQkFBMkIsbUJBQU8sQ0FBQyw0REFBWTs7QUFFL0M7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQixrQ0FBa0M7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGFBQWEsR0FBRyxTQUFTO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsbUJBQW1CLDZCQUE2QixpQkFBaUI7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU8sRUFBRSxRQUFRO0FBQzNDO0FBQ0E7OztBQUdBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MaXN0ZW4vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21tb24uanM/YTEzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQXNzZXJ0RXJyb3IgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lcnJvcicpO1xuXG5jb25zdCBQa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxubGV0IE1lc3NhZ2VzO1xubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGlzb0RhdGU6IC9eKD86Wy0rXVxcZHsyfSk/KD86XFxkezR9KD8hXFxkezJ9XFxiKSkoPzooLT8pKD86KD86MFsxLTldfDFbMC0yXSkoPzpcXDEoPzpbMTJdXFxkfDBbMS05XXwzWzAxXSkpP3xXKD86WzAtNF1cXGR8NVswLTJdKSg/Oi0/WzEtN10pP3woPzowMFsxLTldfDBbMS05XVxcZHxbMTJdXFxkezJ9fDMoPzpbMC01XVxcZHw2WzEtNl0pKSkoPyFbVF0kfFtUXVtcXGRdK1okKSg/OltUXFxzXSg/Oig/Oig/OlswMV1cXGR8MlswLTNdKSg/Oig6PylbMC01XVxcZCk/fDI0XFw6PzAwKSg/OlsuLF1cXGQrKD8hOikpPykoPzpcXDJbMC01XVxcZCg/OlsuLF1cXGQrKT8pPyg/OltaXXwoPzpbKy1dKSg/OlswMV1cXGR8MlswLTNdKSg/Ojo/WzAtNV1cXGQpPyk/KT8pPyQvXG59O1xuXG5cbmV4cG9ydHMudmVyc2lvbiA9IFBrZy52ZXJzaW9uO1xuXG5cbmV4cG9ydHMuZGVmYXVsdHMgPSB7XG4gICAgYWJvcnRFYXJseTogdHJ1ZSxcbiAgICBhbGxvd1Vua25vd246IGZhbHNlLFxuICAgIGFydGlmYWN0czogZmFsc2UsXG4gICAgY2FjaGU6IHRydWUsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBjb252ZXJ0OiB0cnVlLFxuICAgIGRhdGVGb3JtYXQ6ICdpc28nLFxuICAgIGVycm9yczoge1xuICAgICAgICBlc2NhcGVIdG1sOiBmYWxzZSxcbiAgICAgICAgbGFiZWw6ICdwYXRoJyxcbiAgICAgICAgbGFuZ3VhZ2U6IG51bGwsXG4gICAgICAgIHJlbmRlcjogdHJ1ZSxcbiAgICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgICB3cmFwOiB7XG4gICAgICAgICAgICBsYWJlbDogJ1wiJyxcbiAgICAgICAgICAgIGFycmF5OiAnW10nXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVybmFsczogdHJ1ZSxcbiAgICBtZXNzYWdlczoge30sXG4gICAgbm9uRW51bWVyYWJsZXM6IGZhbHNlLFxuICAgIG5vRGVmYXVsdHM6IGZhbHNlLFxuICAgIHByZXNlbmNlOiAnb3B0aW9uYWwnLFxuICAgIHNraXBGdW5jdGlvbnM6IGZhbHNlLFxuICAgIHN0cmlwVW5rbm93bjogZmFsc2UsXG4gICAgd2FybmluZ3M6IGZhbHNlXG59O1xuXG5cbmV4cG9ydHMuc3ltYm9scyA9IHtcbiAgICBhbnk6IFN5bWJvbC5mb3IoJ0BoYXBpL2pvaS9zY2hlbWEnKSwgICAgICAgICAgICAvLyBVc2VkIHRvIGludGVybmFsbHkgaWRlbnRpZnkgYW55LWJhc2VkIHR5cGVzIChzaGFyZWQgd2l0aCBvdGhlciBqb2kgdmVyc2lvbnMpXG4gICAgYXJyYXlTaW5nbGU6IFN5bWJvbCgnYXJyYXlTaW5nbGUnKSxcbiAgICBkZWVwRGVmYXVsdDogU3ltYm9sKCdkZWVwRGVmYXVsdCcpLFxuICAgIGVycm9yczogU3ltYm9sKCdlcnJvcnMnKSxcbiAgICBsaXRlcmFsOiBTeW1ib2woJ2xpdGVyYWwnKSxcbiAgICBvdmVycmlkZTogU3ltYm9sKCdvdmVycmlkZScpLFxuICAgIHBhcmVudDogU3ltYm9sKCdwYXJlbnQnKSxcbiAgICBwcmVmczogU3ltYm9sKCdwcmVmcycpLFxuICAgIHJlZjogU3ltYm9sKCdyZWYnKSxcbiAgICB0ZW1wbGF0ZTogU3ltYm9sKCd0ZW1wbGF0ZScpLFxuICAgIHZhbHVlczogU3ltYm9sKCd2YWx1ZXMnKVxufTtcblxuXG5leHBvcnRzLmFzc2VydE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywga2V5cywgbmFtZSA9ICdPcHRpb25zJykge1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMpLCAnT3B0aW9ucyBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG4gICAgY29uc3QgdW5rbm93bktleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKGspID0+ICFrZXlzLmluY2x1ZGVzKGspKTtcbiAgICBBc3NlcnQodW5rbm93bktleXMubGVuZ3RoID09PSAwLCBgJHtuYW1lfSBjb250YWluIHVua25vd24ga2V5czogJHt1bmtub3duS2V5c31gKTtcbn07XG5cblxuZXhwb3J0cy5jaGVja1ByZWZlcmVuY2VzID0gZnVuY3Rpb24gKHByZWZzKSB7XG5cbiAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFNjaGVtYXMucHJlZmVyZW5jZXMudmFsaWRhdGUocHJlZnMpO1xuXG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0RXJyb3IoW3Jlc3VsdC5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2VdKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiLCBvcGVyYXRvcikge1xuXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICc9JzogcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIGNhc2UgJz4nOiByZXR1cm4gYSA+IGI7XG4gICAgICAgIGNhc2UgJzwnOiByZXR1cm4gYSA8IGI7XG4gICAgICAgIGNhc2UgJz49JzogcmV0dXJuIGEgPj0gYjtcbiAgICAgICAgY2FzZSAnPD0nOiByZXR1cm4gYSA8PSBiO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59O1xuXG5cbmV4cG9ydHMuaXNJc29EYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuaXNvRGF0ZS50ZXN0KGRhdGUpO1xufTtcblxuXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpO1xufTtcblxuXG5leHBvcnRzLmlzUmVzb2x2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqW2V4cG9ydHMuc3ltYm9scy5yZWZdIHx8IG9ialtleHBvcnRzLnN5bWJvbHMudGVtcGxhdGVdO1xufTtcblxuXG5leHBvcnRzLmlzU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWEgJiYgc2NoZW1hW2V4cG9ydHMuc3ltYm9scy5hbnldO1xuICAgIGlmICghYW55KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBBc3NlcnQob3B0aW9ucy5sZWdhY3kgfHwgYW55LnZlcnNpb24gPT09IGV4cG9ydHMudmVyc2lvbiwgJ0Nhbm5vdCBtaXggZGlmZmVyZW50IHZlcnNpb25zIG9mIGpvaSBzY2hlbWFzJyk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmV4cG9ydHMuaXNWYWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICByZXR1cm4gb2JqW2V4cG9ydHMuc3ltYm9scy52YWx1ZXNdO1xufTtcblxuXG5leHBvcnRzLmxpbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmIHZhbHVlID49IDA7XG59O1xuXG5cbmV4cG9ydHMucHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIE1lc3NhZ2VzID0gTWVzc2FnZXMgfHwgcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICAgIHNvdXJjZSA9IHNvdXJjZSB8fCB7fTtcblxuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgc291cmNlKTtcbiAgICBpZiAoc291cmNlLmVycm9ycyAmJlxuICAgICAgICB0YXJnZXQuZXJyb3JzKSB7XG5cbiAgICAgICAgbWVyZ2VkLmVycm9ycyA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5lcnJvcnMsIHNvdXJjZS5lcnJvcnMpO1xuICAgICAgICBtZXJnZWQuZXJyb3JzLndyYXAgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQuZXJyb3JzLndyYXAsIHNvdXJjZS5lcnJvcnMud3JhcCk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5tZXNzYWdlcykge1xuICAgICAgICBtZXJnZWQubWVzc2FnZXMgPSBNZXNzYWdlcy5jb21waWxlKHNvdXJjZS5tZXNzYWdlcywgdGFyZ2V0Lm1lc3NhZ2VzKTtcbiAgICB9XG5cbiAgICBkZWxldGUgbWVyZ2VkW2V4cG9ydHMuc3ltYm9scy5wcmVmc107XG4gICAgcmV0dXJuIG1lcmdlZDtcbn07XG5cblxuZXhwb3J0cy50cnlXaXRoUGF0aCA9IGZ1bmN0aW9uIChmbiwga2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnIucGF0aCA9IGtleSArICcuJyArIGVyci5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyLnBhdGggPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hcHBlbmQpIHtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9ICgke2Vyci5wYXRofSlgO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy52YWxpZGF0ZUFyZyA9IGZ1bmN0aW9uICh2YWx1ZSwgbGFiZWwsIHsgYXNzZXJ0LCBtZXNzYWdlIH0pIHtcblxuICAgIGlmIChleHBvcnRzLmlzU2NoZW1hKGFzc2VydCkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXNzZXJ0LnZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFzc2VydCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsID8gYCR7bGFiZWx9ICR7bWVzc2FnZX1gIDogbWVzc2FnZTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMudmVyaWZ5RmxhdCA9IGZ1bmN0aW9uIChhcmdzLCBtZXRob2QpIHtcblxuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgQXNzZXJ0KCFBcnJheS5pc0FycmF5KGFyZyksICdNZXRob2Qgbm8gbG9uZ2VyIGFjY2VwdHMgYXJyYXkgYXJndW1lbnRzOicsIG1ldGhvZCk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/compile.js":
/*!*****************************************!*\
  !*** ./node_modules/joi/lib/compile.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\n\n\nconst internals = {};\n\n\nexports.schema = function (Joi, config, options = {}) {\n\n    Common.assertOptions(options, ['appendPath', 'override']);\n\n    try {\n        return internals.schema(Joi, config, options);\n    }\n    catch (err) {\n        if (options.appendPath &&\n            err.path !== undefined) {\n\n            err.message = `${err.message} (${err.path})`;\n        }\n\n        throw err;\n    }\n};\n\n\ninternals.schema = function (Joi, config, options) {\n\n    Assert(config !== undefined, 'Invalid undefined schema');\n\n    if (Array.isArray(config)) {\n        Assert(config.length, 'Invalid empty array schema');\n\n        if (config.length === 1) {\n            config = config[0];\n        }\n    }\n\n    const valid = (base, ...values) => {\n\n        if (options.override !== false) {\n            return base.valid(Joi.override, ...values);\n        }\n\n        return base.valid(...values);\n    };\n\n    if (internals.simple(config)) {\n        return valid(Joi, config);\n    }\n\n    if (typeof config === 'function') {\n        return Joi.custom(config);\n    }\n\n    Assert(typeof config === 'object', 'Invalid schema content:', typeof config);\n\n    if (Common.isResolvable(config)) {\n        return valid(Joi, config);\n    }\n\n    if (Common.isSchema(config)) {\n        return config;\n    }\n\n    if (Array.isArray(config)) {\n        for (const item of config) {\n            if (!internals.simple(item)) {\n                return Joi.alternatives().try(...config);\n            }\n        }\n\n        return valid(Joi, ...config);\n    }\n\n    if (config instanceof RegExp) {\n        return Joi.string().regex(config);\n    }\n\n    if (config instanceof Date) {\n        return valid(Joi.date(), config);\n    }\n\n    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n    return Joi.object().keys(config);\n};\n\n\nexports.ref = function (id, options) {\n\n    return Ref.isRef(id) ? id : Ref.create(id, options);\n};\n\n\nexports.compile = function (root, schema, options = {}) {\n\n    Common.assertOptions(options, ['legacy']);\n\n    // Compiled by any supported version\n\n    const any = schema && schema[Common.symbols.any];\n    if (any) {\n        Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas:', any.version, Common.version);\n        return schema;\n    }\n\n    // Uncompiled root\n\n    if (typeof schema !== 'object' ||\n        !options.legacy) {\n\n        return exports.schema(root, schema, { appendPath: true });          // Will error if schema contains other versions\n    }\n\n    // Scan schema for compiled parts\n\n    const compiler = internals.walk(schema);\n    if (!compiler) {\n        return exports.schema(root, schema, { appendPath: true });\n    }\n\n    return compiler.compile(compiler.root, schema);\n};\n\n\ninternals.walk = function (schema) {\n\n    if (typeof schema !== 'object') {\n        return null;\n    }\n\n    if (Array.isArray(schema)) {\n        for (const item of schema) {\n            const compiler = internals.walk(item);\n            if (compiler) {\n                return compiler;\n            }\n        }\n\n        return null;\n    }\n\n    const any = schema[Common.symbols.any];\n    if (any) {\n        return { root: schema[any.root], compile: any.compile };\n    }\n\n    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n    for (const key in schema) {\n        const compiler = internals.walk(schema[key]);\n        if (compiler) {\n            return compiler;\n        }\n    }\n\n    return null;\n};\n\n\ninternals.simple = function (value) {\n\n    return value === null || ['boolean', 'string', 'number'].includes(typeof value);\n};\n\n\nexports.when = function (schema, condition, options) {\n\n    if (options === undefined) {\n        Assert(condition && typeof condition === 'object', 'Missing options');\n\n        options = condition;\n        condition = Ref.create('.');\n    }\n\n    if (Array.isArray(options)) {\n        options = { switch: options };\n    }\n\n    Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']);\n\n    // Schema condition\n\n    if (Common.isSchema(condition)) {\n        Assert(options.is === undefined, '\"is\" can not be used with a schema condition');\n        Assert(options.not === undefined, '\"not\" can not be used with a schema condition');\n        Assert(options.switch === undefined, '\"switch\" can not be used with a schema condition');\n\n        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });\n    }\n\n    // Single condition\n\n    Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);\n    Assert(options.not === undefined || options.is === undefined, 'Cannot combine \"is\" with \"not\"');\n\n    if (options.switch === undefined) {\n        let rule = options;\n        if (options.not !== undefined) {\n            rule = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };\n        }\n\n        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();\n        Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of \"then\", \"otherwise\", or \"switch\"');\n        Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');\n\n        if (options.is !== undefined &&\n            !Ref.isRef(options.is) &&\n            !Common.isSchema(options.is)) {\n\n            is = is.required();                     // Only apply required if this wasn't already a schema or a ref\n        }\n\n        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule.then, otherwise: rule.otherwise, break: rule.break });\n    }\n\n    // Switch statement\n\n    Assert(Array.isArray(options.switch), '\"switch\" must be an array');\n    Assert(options.is === undefined, 'Cannot combine \"switch\" with \"is\"');\n    Assert(options.not === undefined, 'Cannot combine \"switch\" with \"not\"');\n    Assert(options.then === undefined, 'Cannot combine \"switch\" with \"then\"');\n\n    const rule = {\n        ref: exports.ref(condition),\n        switch: [],\n        break: options.break\n    };\n\n    for (let i = 0; i < options.switch.length; ++i) {\n        const test = options.switch[i];\n        const last = i === options.switch.length - 1;\n\n        Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);\n\n        Assert(test.is !== undefined, 'Switch statement missing \"is\"');\n        Assert(test.then !== undefined, 'Switch statement missing \"then\"');\n\n        const item = {\n            is: schema.$_compile(test.is),\n            then: schema.$_compile(test.then)\n        };\n\n        if (!Ref.isRef(test.is) &&\n            !Common.isSchema(test.is)) {\n\n            item.is = item.is.required();           // Only apply required if this wasn't already a schema or a ref\n        }\n\n        if (last) {\n            Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify \"otherwise\" inside and outside a \"switch\"');\n            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;\n            if (otherwise !== undefined) {\n                Assert(rule.break === undefined, 'Cannot specify both otherwise and break');\n                item.otherwise = schema.$_compile(otherwise);\n            }\n        }\n\n        rule.switch.push(item);\n    }\n\n    return rule;\n};\n\n\ninternals.condition = function (schema, condition) {\n\n    for (const key of ['then', 'otherwise']) {\n        if (condition[key] === undefined) {\n            delete condition[key];\n        }\n        else {\n            condition[key] = schema.$_compile(condition[key]);\n        }\n    }\n\n    return condition;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21waWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw0RUFBdUI7O0FBRTlDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTtBQUNqQyxZQUFZLG1CQUFPLENBQUMsa0RBQU87OztBQUczQjs7O0FBR0EsY0FBYyxzQ0FBc0M7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsYUFBYSxHQUFHLFNBQVM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTs7O0FBR0EsV0FBVzs7QUFFWDtBQUNBOzs7QUFHQSxlQUFlLHVDQUF1Qzs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxrQkFBa0IsWUFBWTtBQUM1RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7OztBQUdBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLHVGQUF1RjtBQUNwSTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDs7QUFFQSw2Q0FBNkMsZ0dBQWdHO0FBQzdJOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL2NvbXBpbGUuanM/ZDE0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnNjaGVtYSA9IGZ1bmN0aW9uIChKb2ksIGNvbmZpZywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FwcGVuZFBhdGgnLCAnb3ZlcnJpZGUnXSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNjaGVtYShKb2ksIGNvbmZpZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwZW5kUGF0aCAmJlxuICAgICAgICAgICAgZXJyLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAoJHtlcnIucGF0aH0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWEgPSBmdW5jdGlvbiAoSm9pLCBjb25maWcsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChjb25maWcgIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgdW5kZWZpbmVkIHNjaGVtYScpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICBBc3NlcnQoY29uZmlnLmxlbmd0aCwgJ0ludmFsaWQgZW1wdHkgYXJyYXkgc2NoZW1hJyk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZ1swXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gKGJhc2UsIC4uLnZhbHVlcykgPT4ge1xuXG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UudmFsaWQoSm9pLm92ZXJyaWRlLCAuLi52YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2UudmFsaWQoLi4udmFsdWVzKTtcbiAgICB9O1xuXG4gICAgaWYgKGludGVybmFscy5zaW1wbGUoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBKb2kuY3VzdG9tKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzY2hlbWEgY29udGVudDonLCB0eXBlb2YgY29uZmlnKTtcblxuICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnNpbXBsZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKb2kuYWx0ZXJuYXRpdmVzKCkudHJ5KC4uLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCAuLi5jb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIEpvaS5zdHJpbmcoKS5yZWdleChjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2kuZGF0ZSgpLCBjb25maWcpO1xuICAgIH1cblxuICAgIEFzc2VydChPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uZmlnKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSwgJ1NjaGVtYSBjYW4gb25seSBjb250YWluIHBsYWluIG9iamVjdHMnKTtcblxuICAgIHJldHVybiBKb2kub2JqZWN0KCkua2V5cyhjb25maWcpO1xufTtcblxuXG5leHBvcnRzLnJlZiA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIFJlZi5pc1JlZihpZCkgPyBpZCA6IFJlZi5jcmVhdGUoaWQsIG9wdGlvbnMpO1xufTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAocm9vdCwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnbGVnYWN5J10pO1xuXG4gICAgLy8gQ29tcGlsZWQgYnkgYW55IHN1cHBvcnRlZCB2ZXJzaW9uXG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWEgJiYgc2NoZW1hW0NvbW1vbi5zeW1ib2xzLmFueV07XG4gICAgaWYgKGFueSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5sZWdhY3kgfHwgYW55LnZlcnNpb24gPT09IENvbW1vbi52ZXJzaW9uLCAnQ2Fubm90IG1peCBkaWZmZXJlbnQgdmVyc2lvbnMgb2Ygam9pIHNjaGVtYXM6JywgYW55LnZlcnNpb24sIENvbW1vbi52ZXJzaW9uKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICAvLyBVbmNvbXBpbGVkIHJvb3RcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhb3B0aW9ucy5sZWdhY3kpIHtcblxuICAgICAgICByZXR1cm4gZXhwb3J0cy5zY2hlbWEocm9vdCwgc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7ICAgICAgICAgIC8vIFdpbGwgZXJyb3IgaWYgc2NoZW1hIGNvbnRhaW5zIG90aGVyIHZlcnNpb25zXG4gICAgfVxuXG4gICAgLy8gU2NhbiBzY2hlbWEgZm9yIGNvbXBpbGVkIHBhcnRzXG5cbiAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKHNjaGVtYSk7XG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zY2hlbWEocm9vdCwgc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGUoY29tcGlsZXIucm9vdCwgc2NoZW1hKTtcbn07XG5cblxuaW50ZXJuYWxzLndhbGsgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hW0NvbW1vbi5zeW1ib2xzLmFueV07XG4gICAgaWYgKGFueSkge1xuICAgICAgICByZXR1cm4geyByb290OiBzY2hlbWFbYW55LnJvb3RdLCBjb21waWxlOiBhbnkuY29tcGlsZSB9O1xuICAgIH1cblxuICAgIEFzc2VydChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2NoZW1hKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSwgJ1NjaGVtYSBjYW4gb25seSBjb250YWluIHBsYWluIG9iamVjdHMnKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKHNjaGVtYVtrZXldKTtcbiAgICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuaW50ZXJuYWxzLnNpbXBsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IFsnYm9vbGVhbicsICdzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy53aGVuID0gZnVuY3Rpb24gKHNjaGVtYSwgY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEFzc2VydChjb25kaXRpb24gJiYgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ29iamVjdCcsICdNaXNzaW5nIG9wdGlvbnMnKTtcblxuICAgICAgICBvcHRpb25zID0gY29uZGl0aW9uO1xuICAgICAgICBjb25kaXRpb24gPSBSZWYuY3JlYXRlKCcuJyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgc3dpdGNoOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpcycsICdub3QnLCAndGhlbicsICdvdGhlcndpc2UnLCAnc3dpdGNoJywgJ2JyZWFrJ10pO1xuXG4gICAgLy8gU2NoZW1hIGNvbmRpdGlvblxuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShjb25kaXRpb24pKSB7XG4gICAgICAgIEFzc2VydChvcHRpb25zLmlzID09PSB1bmRlZmluZWQsICdcImlzXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkLCAnXCJub3RcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuc3dpdGNoID09PSB1bmRlZmluZWQsICdcInN3aXRjaFwiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY29uZGl0aW9uKHNjaGVtYSwgeyBpczogY29uZGl0aW9uLCB0aGVuOiBvcHRpb25zLnRoZW4sIG90aGVyd2lzZTogb3B0aW9ucy5vdGhlcndpc2UsIGJyZWFrOiBvcHRpb25zLmJyZWFrIH0pO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBjb25kaXRpb25cblxuICAgIEFzc2VydChSZWYuaXNSZWYoY29uZGl0aW9uKSB8fCB0eXBlb2YgY29uZGl0aW9uID09PSAnc3RyaW5nJywgJ0ludmFsaWQgY29uZGl0aW9uOicsIGNvbmRpdGlvbik7XG4gICAgQXNzZXJ0KG9wdGlvbnMubm90ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJpc1wiIHdpdGggXCJub3RcIicpO1xuXG4gICAgaWYgKG9wdGlvbnMuc3dpdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5ub3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVsZSA9IHsgaXM6IG9wdGlvbnMubm90LCB0aGVuOiBvcHRpb25zLm90aGVyd2lzZSwgb3RoZXJ3aXNlOiBvcHRpb25zLnRoZW4sIGJyZWFrOiBvcHRpb25zLmJyZWFrIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXMgPSBydWxlLmlzICE9PSB1bmRlZmluZWQgPyBzY2hlbWEuJF9jb21waWxlKHJ1bGUuaXMpIDogc2NoZW1hLiRfcm9vdC5pbnZhbGlkKG51bGwsIGZhbHNlLCAwLCAnJykucmVxdWlyZWQoKTtcbiAgICAgICAgQXNzZXJ0KHJ1bGUudGhlbiAhPT0gdW5kZWZpbmVkIHx8IHJ1bGUub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQsICdvcHRpb25zIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgXCJ0aGVuXCIsIFwib3RoZXJ3aXNlXCIsIG9yIFwic3dpdGNoXCInKTtcbiAgICAgICAgQXNzZXJ0KHJ1bGUuYnJlYWsgPT09IHVuZGVmaW5lZCB8fCBydWxlLnRoZW4gPT09IHVuZGVmaW5lZCB8fCBydWxlLm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgdGhlbiwgb3RoZXJ3aXNlLCBhbmQgYnJlYWsgYWxsIHRvZ2V0aGVyJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIVJlZi5pc1JlZihvcHRpb25zLmlzKSAmJlxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYShvcHRpb25zLmlzKSkge1xuXG4gICAgICAgICAgICBpcyA9IGlzLnJlcXVpcmVkKCk7ICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSByZXF1aXJlZCBpZiB0aGlzIHdhc24ndCBhbHJlYWR5IGEgc2NoZW1hIG9yIGEgcmVmXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNvbmRpdGlvbihzY2hlbWEsIHsgcmVmOiBleHBvcnRzLnJlZihjb25kaXRpb24pLCBpcywgdGhlbjogcnVsZS50aGVuLCBvdGhlcndpc2U6IHJ1bGUub3RoZXJ3aXNlLCBicmVhazogcnVsZS5icmVhayB9KTtcbiAgICB9XG5cbiAgICAvLyBTd2l0Y2ggc3RhdGVtZW50XG5cbiAgICBBc3NlcnQoQXJyYXkuaXNBcnJheShvcHRpb25zLnN3aXRjaCksICdcInN3aXRjaFwiIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICBBc3NlcnQob3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwiaXNcIicpO1xuICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwibm90XCInKTtcbiAgICBBc3NlcnQob3B0aW9ucy50aGVuID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcInN3aXRjaFwiIHdpdGggXCJ0aGVuXCInKTtcblxuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHJlZjogZXhwb3J0cy5yZWYoY29uZGl0aW9uKSxcbiAgICAgICAgc3dpdGNoOiBbXSxcbiAgICAgICAgYnJlYWs6IG9wdGlvbnMuYnJlYWtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLnN3aXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0ZXN0ID0gb3B0aW9ucy5zd2l0Y2hbaV07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBpID09PSBvcHRpb25zLnN3aXRjaC5sZW5ndGggLSAxO1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKHRlc3QsIGxhc3QgPyBbJ2lzJywgJ3RoZW4nLCAnb3RoZXJ3aXNlJ10gOiBbJ2lzJywgJ3RoZW4nXSk7XG5cbiAgICAgICAgQXNzZXJ0KHRlc3QuaXMgIT09IHVuZGVmaW5lZCwgJ1N3aXRjaCBzdGF0ZW1lbnQgbWlzc2luZyBcImlzXCInKTtcbiAgICAgICAgQXNzZXJ0KHRlc3QudGhlbiAhPT0gdW5kZWZpbmVkLCAnU3dpdGNoIHN0YXRlbWVudCBtaXNzaW5nIFwidGhlblwiJyk7XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIGlzOiBzY2hlbWEuJF9jb21waWxlKHRlc3QuaXMpLFxuICAgICAgICAgICAgdGhlbjogc2NoZW1hLiRfY29tcGlsZSh0ZXN0LnRoZW4pXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFSZWYuaXNSZWYodGVzdC5pcykgJiZcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEodGVzdC5pcykpIHtcblxuICAgICAgICAgICAgaXRlbS5pcyA9IGl0ZW0uaXMucmVxdWlyZWQoKTsgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgcmVxdWlyZWQgaWYgdGhpcyB3YXNuJ3QgYWxyZWFkeSBhIHNjaGVtYSBvciBhIHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIEFzc2VydChvcHRpb25zLm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkIHx8IHRlc3Qub3RoZXJ3aXNlID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSBcIm90aGVyd2lzZVwiIGluc2lkZSBhbmQgb3V0c2lkZSBhIFwic3dpdGNoXCInKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyd2lzZSA9IG9wdGlvbnMub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm90aGVyd2lzZSA6IHRlc3Qub3RoZXJ3aXNlO1xuICAgICAgICAgICAgaWYgKG90aGVyd2lzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJ1bGUuYnJlYWsgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggb3RoZXJ3aXNlIGFuZCBicmVhaycpO1xuICAgICAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlID0gc2NoZW1hLiRfY29tcGlsZShvdGhlcndpc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVsZS5zd2l0Y2gucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbmRpdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGNvbmRpdGlvbikge1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgWyd0aGVuJywgJ290aGVyd2lzZSddKSB7XG4gICAgICAgIGlmIChjb25kaXRpb25ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZGl0aW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25kaXRpb25ba2V5XSA9IHNjaGVtYS4kX2NvbXBpbGUoY29uZGl0aW9uW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmRpdGlvbjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/compile.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/errors.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/errors.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Annotate = __webpack_require__(/*! ./annotate */ \"(rsc)/./node_modules/joi/lib/annotate.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Template = __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\n\n\nconst internals = {};\n\n\nexports.Report = class {\n\n    constructor(code, value, local, flags, messages, state, prefs) {\n\n        this.code = code;\n        this.flags = flags;\n        this.messages = messages;\n        this.path = state.path;\n        this.prefs = prefs;\n        this.state = state;\n        this.value = value;\n\n        this.message = null;\n        this.template = null;\n\n        this.local = local || {};\n        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);\n\n        if (this.value !== undefined &&\n            !this.local.hasOwnProperty('value')) {\n\n            this.local.value = this.value;\n        }\n\n        if (this.path.length) {\n            const key = this.path[this.path.length - 1];\n            if (typeof key !== 'object') {\n                this.local.key = key;\n            }\n        }\n    }\n\n    _setTemplate(template) {\n\n        this.template = template;\n\n        if (!this.flags.label &&\n            this.path.length === 0) {\n\n            const localized = this._template(this.template, 'root');\n            if (localized) {\n                this.local.label = localized;\n            }\n        }\n    }\n\n    toString() {\n\n        if (this.message) {\n            return this.message;\n        }\n\n        const code = this.code;\n\n        if (!this.prefs.errors.render) {\n            return this.code;\n        }\n\n        const template = this._template(this.template) ||\n            this._template(this.prefs.messages) ||\n            this._template(this.messages);\n\n        if (template === undefined) {\n            return `Error code \"${code}\" is not defined, your custom type is missing the correct messages definition`;\n        }\n\n        // Render and cache result\n\n        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });\n        if (!this.prefs.errors.label) {\n            this.message = this.message.replace(/^\"\" /, '').trim();\n        }\n\n        return this.message;\n    }\n\n    _template(messages, code) {\n\n        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);\n    }\n};\n\n\nexports.path = function (path) {\n\n    let label = '';\n    for (const segment of path) {\n        if (typeof segment === 'object') {          // Exclude array single path segment\n            continue;\n        }\n\n        if (typeof segment === 'string') {\n            if (label) {\n                label += '.';\n            }\n\n            label += segment;\n        }\n        else {\n            label += `[${segment}]`;\n        }\n    }\n\n    return label;\n};\n\n\nexports.template = function (value, messages, code, state, prefs) {\n\n    if (!messages) {\n        return;\n    }\n\n    if (Template.isTemplate(messages)) {\n        return code !== 'root' ? messages : null;\n    }\n\n    let lang = prefs.errors.language;\n    if (Common.isResolvable(lang)) {\n        lang = lang.resolve(value, state, prefs);\n    }\n\n    if (lang &&\n        messages[lang]) {\n\n        if (messages[lang][code] !== undefined) {\n            return messages[lang][code];\n        }\n\n        if (messages[lang]['*'] !== undefined) {\n            return messages[lang]['*'];\n        }\n    }\n\n    if (!messages[code]) {\n        return messages['*'];\n    }\n\n    return messages[code];\n};\n\n\nexports.label = function (flags, state, prefs, messages) {\n\n    if (!prefs.errors.label) {\n        return '';\n    }\n\n    if (flags.label) {\n        return flags.label;\n    }\n\n    let path = state.path;\n    if (prefs.errors.label === 'key' &&\n        state.path.length > 1) {\n\n        path = state.path.slice(-1);\n    }\n\n    const normalized = exports.path(path);\n    if (normalized) {\n        return normalized;\n    }\n\n    return exports.template(null, prefs.messages, 'root', state, prefs) ||\n        messages && exports.template(null, messages, 'root', state, prefs) ||\n        'value';\n};\n\n\nexports.process = function (errors, original, prefs) {\n\n    if (!errors) {\n        return null;\n    }\n\n    const { override, message, details } = exports.details(errors);\n    if (override) {\n        return override;\n    }\n\n    if (prefs.errors.stack) {\n        return new exports.ValidationError(message, details, original);\n    }\n\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    const validationError = new exports.ValidationError(message, details, original);\n    Error.stackTraceLimit = limit;\n    return validationError;\n};\n\n\nexports.details = function (errors, options = {}) {\n\n    let messages = [];\n    const details = [];\n\n    for (const item of errors) {\n\n        // Override\n\n        if (item instanceof Error) {\n            if (options.override !== false) {\n                return { override: item };\n            }\n\n            const message = item.toString();\n            messages.push(message);\n\n            details.push({\n                message,\n                type: 'override',\n                context: { error: item }\n            });\n\n            continue;\n        }\n\n        // Report\n\n        const message = item.toString();\n        messages.push(message);\n\n        details.push({\n            message,\n            path: item.path.filter((v) => typeof v !== 'object'),\n            type: item.code,\n            context: item.local\n        });\n    }\n\n    if (messages.length > 1) {\n        messages = [...new Set(messages)];\n    }\n\n    return { message: messages.join('. '), details };\n};\n\n\nexports.ValidationError = class extends Error {\n\n    constructor(message, details, original) {\n\n        super(message);\n        this._original = original;\n        this.details = details;\n    }\n\n    static isError(err) {\n\n        return err instanceof exports.ValidationError;\n    }\n};\n\n\nexports.ValidationError.prototype.isJoi = true;\n\nexports.ValidationError.prototype.name = 'ValidationError';\n\nexports.ValidationError.prototype.annotate = Annotate.error;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsNERBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZOzs7QUFHckM7OztBQUdBLGNBQWM7O0FBRWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDOztBQUVBOztBQUVBLHlGQUF5RiwyRUFBMkU7QUFDcEs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxZQUFZOztBQUVaO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7OztBQUdBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZUFBZSxpQ0FBaUM7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixhQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7OztBQUdBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSx1Q0FBdUM7O0FBRXZDLHNDQUFzQzs7QUFFdEMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXJyb3JzLmpzPzk5ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBbm5vdGF0ZSA9IHJlcXVpcmUoJy4vYW5ub3RhdGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLlJlcG9ydCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5wYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgdGhpcy5wcmVmcyA9IHByZWZzO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwgfHwge307XG4gICAgICAgIHRoaXMubG9jYWwubGFiZWwgPSBleHBvcnRzLmxhYmVsKHRoaXMuZmxhZ3MsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMsIHRoaXMubWVzc2FnZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmxvY2FsLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG5cbiAgICAgICAgICAgIHRoaXMubG9jYWwudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmtleSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MubGFiZWwgJiZcbiAgICAgICAgICAgIHRoaXMucGF0aC5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5fdGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgJ3Jvb3QnKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmxhYmVsID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZWZzLmVycm9ycy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlKHRoaXMudGVtcGxhdGUpIHx8XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSh0aGlzLnByZWZzLm1lc3NhZ2VzKSB8fFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUodGhpcy5tZXNzYWdlcyk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgY29kZSBcIiR7Y29kZX1cIiBpcyBub3QgZGVmaW5lZCwgeW91ciBjdXN0b20gdHlwZSBpcyBtaXNzaW5nIHRoZSBjb3JyZWN0IG1lc3NhZ2VzIGRlZmluaXRpb25gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGFuZCBjYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0ZW1wbGF0ZS5yZW5kZXIodGhpcy52YWx1ZSwgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcywgdGhpcy5sb2NhbCwgeyBlcnJvcnM6IHRoaXMucHJlZnMuZXJyb3JzLCBtZXNzYWdlczogW3RoaXMucHJlZnMubWVzc2FnZXMsIHRoaXMubWVzc2FnZXNdIH0pO1xuICAgICAgICBpZiAoIXRoaXMucHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UucmVwbGFjZSgvXlwiXCIgLywgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgX3RlbXBsYXRlKG1lc3NhZ2VzLCBjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUodGhpcy52YWx1ZSwgbWVzc2FnZXMsIGNvZGUgfHwgdGhpcy5jb2RlLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMucGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdvYmplY3QnKSB7ICAgICAgICAgIC8vIEV4Y2x1ZGUgYXJyYXkgc2luZ2xlIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCArPSAnLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsICs9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCArPSBgWyR7c2VnbWVudH1dYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn07XG5cblxuZXhwb3J0cy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIGNvZGUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZXMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlICE9PSAncm9vdCcgPyBtZXNzYWdlcyA6IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGxhbmcgPSBwcmVmcy5lcnJvcnMubGFuZ3VhZ2U7XG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUobGFuZykpIHtcbiAgICAgICAgbGFuZyA9IGxhbmcucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAobGFuZyAmJlxuICAgICAgICBtZXNzYWdlc1tsYW5nXSkge1xuXG4gICAgICAgIGlmIChtZXNzYWdlc1tsYW5nXVtjb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bY29kZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVzc2FnZXNbbGFuZ11bJyonXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bJyonXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWVzc2FnZXNbY29kZV0pIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzWycqJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzW2NvZGVdO1xufTtcblxuXG5leHBvcnRzLmxhYmVsID0gZnVuY3Rpb24gKGZsYWdzLCBzdGF0ZSwgcHJlZnMsIG1lc3NhZ2VzKSB7XG5cbiAgICBpZiAoIXByZWZzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmbGFncy5sYWJlbDtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgaWYgKHByZWZzLmVycm9ycy5sYWJlbCA9PT0gJ2tleScgJiZcbiAgICAgICAgc3RhdGUucGF0aC5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgcGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoLTEpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBleHBvcnRzLnBhdGgocGF0aCk7XG4gICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUobnVsbCwgcHJlZnMubWVzc2FnZXMsICdyb290Jywgc3RhdGUsIHByZWZzKSB8fFxuICAgICAgICBtZXNzYWdlcyAmJiBleHBvcnRzLnRlbXBsYXRlKG51bGwsIG1lc3NhZ2VzLCAncm9vdCcsIHN0YXRlLCBwcmVmcykgfHxcbiAgICAgICAgJ3ZhbHVlJztcbn07XG5cblxuZXhwb3J0cy5wcm9jZXNzID0gZnVuY3Rpb24gKGVycm9ycywgb3JpZ2luYWwsIHByZWZzKSB7XG5cbiAgICBpZiAoIWVycm9ycykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IG92ZXJyaWRlLCBtZXNzYWdlLCBkZXRhaWxzIH0gPSBleHBvcnRzLmRldGFpbHMoZXJyb3JzKTtcbiAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5lcnJvcnMuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpO1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3I7XG59O1xuXG5cbmV4cG9ydHMuZGV0YWlscyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgbGV0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3QgZGV0YWlscyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGVycm9ycykge1xuXG4gICAgICAgIC8vIE92ZXJyaWRlXG5cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcnJpZGU6IGl0ZW0gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHsgZXJyb3I6IGl0ZW0gfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwb3J0XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgICAgICBkZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aC5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ICE9PSAnb2JqZWN0JyksXG4gICAgICAgICAgICB0eXBlOiBpdGVtLmNvZGUsXG4gICAgICAgICAgICBjb250ZXh0OiBpdGVtLmxvY2FsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1lc3NhZ2VzID0gWy4uLm5ldyBTZXQobWVzc2FnZXMpXTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlcy5qb2luKCcuICcpLCBkZXRhaWxzIH07XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCkge1xuXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbCA9IG9yaWdpbmFsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0Vycm9yKGVycikge1xuXG4gICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBleHBvcnRzLlZhbGlkYXRpb25FcnJvcjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5pc0pvaSA9IHRydWU7XG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5hbm5vdGF0ZSA9IEFubm90YXRlLmVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/extend.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/extend.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\n\n\nconst internals = {};\n\n\nexports.type = function (from, options) {\n\n    const base = Object.getPrototypeOf(from);\n    const prototype = Clone(base);\n    const schema = from._assign(Object.create(prototype));\n    const def = Object.assign({}, options);                                 // Shallow cloned\n    delete def.base;\n\n    prototype._definition = def;\n\n    const parent = base._definition || {};\n    def.messages = Messages.merge(parent.messages, def.messages);\n    def.properties = Object.assign({}, parent.properties, def.properties);\n\n    // Type\n\n    schema.type = def.type;\n\n    // Flags\n\n    def.flags = Object.assign({}, parent.flags, def.flags);\n\n    // Terms\n\n    const terms = Object.assign({}, parent.terms);\n    if (def.terms) {\n        for (const name in def.terms) {                                     // Only apply own terms\n            const term = def.terms[name];\n            Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);\n            schema.$_terms[name] = term.init;\n            terms[name] = term;\n        }\n    }\n\n    def.terms = terms;\n\n    // Constructor arguments\n\n    if (!def.args) {\n        def.args = parent.args;\n    }\n\n    // Prepare\n\n    def.prepare = internals.prepare(def.prepare, parent.prepare);\n\n    // Coerce\n\n    if (def.coerce) {\n        if (typeof def.coerce === 'function') {\n            def.coerce = { method: def.coerce };\n        }\n\n        if (def.coerce.from &&\n            !Array.isArray(def.coerce.from)) {\n\n            def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };\n        }\n    }\n\n    def.coerce = internals.coerce(def.coerce, parent.coerce);\n\n    // Validate\n\n    def.validate = internals.validate(def.validate, parent.validate);\n\n    // Rules\n\n    const rules = Object.assign({}, parent.rules);\n    if (def.rules) {\n        for (const name in def.rules) {\n            const rule = def.rules[name];\n            Assert(typeof rule === 'object', 'Invalid rule definition for', def.type, name);\n\n            let method = rule.method;\n            if (method === undefined) {\n                method = function () {\n\n                    return this.$_addRule(name);\n                };\n            }\n\n            if (method) {\n                Assert(!prototype[name], 'Rule conflict in', def.type, name);\n                prototype[name] = method;\n            }\n\n            Assert(!rules[name], 'Rule conflict in', def.type, name);\n            rules[name] = rule;\n\n            if (rule.alias) {\n                const aliases = [].concat(rule.alias);\n                for (const alias of aliases) {\n                    prototype[alias] = rule.method;\n                }\n            }\n\n            if (rule.args) {\n                rule.argsByName = new Map();\n                rule.args = rule.args.map((arg) => {\n\n                    if (typeof arg === 'string') {\n                        arg = { name: arg };\n                    }\n\n                    Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);\n\n                    if (Common.isSchema(arg.assert)) {\n                        arg.assert = arg.assert.strict().label(arg.name);\n                    }\n\n                    rule.argsByName.set(arg.name, arg);\n                    return arg;\n                });\n            }\n        }\n    }\n\n    def.rules = rules;\n\n    // Modifiers\n\n    const modifiers = Object.assign({}, parent.modifiers);\n    if (def.modifiers) {\n        for (const name in def.modifiers) {\n            Assert(!prototype[name], 'Rule conflict in', def.type, name);\n\n            const modifier = def.modifiers[name];\n            Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, name);\n\n            const method = function (arg) {\n\n                return this.rule({ [name]: arg });\n            };\n\n            prototype[name] = method;\n            modifiers[name] = modifier;\n        }\n    }\n\n    def.modifiers = modifiers;\n\n    // Overrides\n\n    if (def.overrides) {\n        prototype._super = base;\n        schema.$_super = {};                                                            // Backwards compatibility\n        for (const override in def.overrides) {\n            Assert(base[override], 'Cannot override missing', override);\n            def.overrides[override][Common.symbols.parent] = base[override];\n            schema.$_super[override] = base[override].bind(schema);                     // Backwards compatibility\n        }\n\n        Object.assign(prototype, def.overrides);\n    }\n\n    // Casts\n\n    def.cast = Object.assign({}, parent.cast, def.cast);\n\n    // Manifest\n\n    const manifest = Object.assign({}, parent.manifest, def.manifest);\n    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);\n    def.manifest = manifest;\n\n    // Rebuild\n\n    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);\n\n    return schema;\n};\n\n\n// Helpers\n\ninternals.build = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (obj, desc) {\n\n        return parent(child(obj, desc), desc);\n    };\n};\n\n\ninternals.coerce = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return {\n        from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,\n        method(value, helpers) {\n\n            let coerced;\n            if (!parent.from ||\n                parent.from.includes(typeof value)) {\n\n                coerced = parent.method(value, helpers);\n                if (coerced) {\n                    if (coerced.errors ||\n                        coerced.value === undefined) {\n\n                        return coerced;\n                    }\n\n                    value = coerced.value;\n                }\n            }\n\n            if (!child.from ||\n                child.from.includes(typeof value)) {\n\n                const own = child.method(value, helpers);\n                if (own) {\n                    return own;\n                }\n            }\n\n            return coerced;\n        }\n    };\n};\n\n\ninternals.prepare = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (value, helpers) {\n\n        const prepared = child(value, helpers);\n        if (prepared) {\n            if (prepared.errors ||\n                prepared.value === undefined) {\n\n                return prepared;\n            }\n\n            value = prepared.value;\n        }\n\n        return parent(value, helpers) || prepared;\n    };\n};\n\n\ninternals.rebuild = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (schema) {\n\n        parent(schema);\n        child(schema);\n    };\n};\n\n\ninternals.validate = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (value, helpers) {\n\n        const result = parent(value, helpers);\n        if (result) {\n            if (result.errors &&\n                (!Array.isArray(result.errors) || result.errors.length)) {\n\n                return result;\n            }\n\n            value = result.value;\n        }\n\n        return child(value, helpers) || result;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9leHRlbmQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1QjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsMEVBQXNCOztBQUU1QyxlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsNERBQVk7OztBQUdyQzs7O0FBR0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNENBQTRDO0FBQzVFOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1DQUFtQyxhQUFhO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCOztBQUUvQjs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXh0ZW5kLmpzPzMyMmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIChmcm9tLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBiYXNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZyb20pO1xuICAgIGNvbnN0IHByb3RvdHlwZSA9IENsb25lKGJhc2UpO1xuICAgIGNvbnN0IHNjaGVtYSA9IGZyb20uX2Fzc2lnbihPYmplY3QuY3JlYXRlKHByb3RvdHlwZSkpO1xuICAgIGNvbnN0IGRlZiA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgZGVsZXRlIGRlZi5iYXNlO1xuXG4gICAgcHJvdG90eXBlLl9kZWZpbml0aW9uID0gZGVmO1xuXG4gICAgY29uc3QgcGFyZW50ID0gYmFzZS5fZGVmaW5pdGlvbiB8fCB7fTtcbiAgICBkZWYubWVzc2FnZXMgPSBNZXNzYWdlcy5tZXJnZShwYXJlbnQubWVzc2FnZXMsIGRlZi5tZXNzYWdlcyk7XG4gICAgZGVmLnByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQucHJvcGVydGllcywgZGVmLnByb3BlcnRpZXMpO1xuXG4gICAgLy8gVHlwZVxuXG4gICAgc2NoZW1hLnR5cGUgPSBkZWYudHlwZTtcblxuICAgIC8vIEZsYWdzXG5cbiAgICBkZWYuZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQuZmxhZ3MsIGRlZi5mbGFncyk7XG5cbiAgICAvLyBUZXJtc1xuXG4gICAgY29uc3QgdGVybXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQudGVybXMpO1xuICAgIGlmIChkZWYudGVybXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi50ZXJtcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IG93biB0ZXJtc1xuICAgICAgICAgICAgY29uc3QgdGVybSA9IGRlZi50ZXJtc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydChzY2hlbWEuJF90ZXJtc1tuYW1lXSA9PT0gdW5kZWZpbmVkLCAnSW52YWxpZCB0ZXJtIG92ZXJyaWRlIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zW25hbWVdID0gdGVybS5pbml0O1xuICAgICAgICAgICAgdGVybXNbbmFtZV0gPSB0ZXJtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLnRlcm1zID0gdGVybXM7XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBhcmd1bWVudHNcblxuICAgIGlmICghZGVmLmFyZ3MpIHtcbiAgICAgICAgZGVmLmFyZ3MgPSBwYXJlbnQuYXJncztcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlXG5cbiAgICBkZWYucHJlcGFyZSA9IGludGVybmFscy5wcmVwYXJlKGRlZi5wcmVwYXJlLCBwYXJlbnQucHJlcGFyZSk7XG5cbiAgICAvLyBDb2VyY2VcblxuICAgIGlmIChkZWYuY29lcmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmLmNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVmLmNvZXJjZSA9IHsgbWV0aG9kOiBkZWYuY29lcmNlIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmLmNvZXJjZS5mcm9tICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShkZWYuY29lcmNlLmZyb20pKSB7XG5cbiAgICAgICAgICAgIGRlZi5jb2VyY2UgPSB7IG1ldGhvZDogZGVmLmNvZXJjZS5tZXRob2QsIGZyb206IFtdLmNvbmNhdChkZWYuY29lcmNlLmZyb20pIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYuY29lcmNlID0gaW50ZXJuYWxzLmNvZXJjZShkZWYuY29lcmNlLCBwYXJlbnQuY29lcmNlKTtcblxuICAgIC8vIFZhbGlkYXRlXG5cbiAgICBkZWYudmFsaWRhdGUgPSBpbnRlcm5hbHMudmFsaWRhdGUoZGVmLnZhbGlkYXRlLCBwYXJlbnQudmFsaWRhdGUpO1xuXG4gICAgLy8gUnVsZXNcblxuICAgIGNvbnN0IHJ1bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnJ1bGVzKTtcbiAgICBpZiAoZGVmLnJ1bGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBkZWYucnVsZXNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJ1bGUgPT09ICdvYmplY3QnLCAnSW52YWxpZCBydWxlIGRlZmluaXRpb24gZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gcnVsZS5tZXRob2Q7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXByb3RvdHlwZVtuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQoIXJ1bGVzW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIHJ1bGVzW25hbWVdID0gcnVsZTtcblxuICAgICAgICAgICAgaWYgKHJ1bGUuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGlhc2VzID0gW10uY29uY2F0KHJ1bGUuYWxpYXMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVbYWxpYXNdID0gcnVsZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcnVsZS5hcmdzQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXJncyA9IHJ1bGUuYXJncy5tYXAoKGFyZykgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0geyBuYW1lOiBhcmcgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghcnVsZS5hcmdzQnlOYW1lLmhhcyhhcmcubmFtZSksICdEdXBsaWNhdGVkIGFyZ3VtZW50IG5hbWUnLCBhcmcubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShhcmcuYXNzZXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnLmFzc2VydCA9IGFyZy5hc3NlcnQuc3RyaWN0KCkubGFiZWwoYXJnLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hcmdzQnlOYW1lLnNldChhcmcubmFtZSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5ydWxlcyA9IHJ1bGVzO1xuXG4gICAgLy8gTW9kaWZpZXJzXG5cbiAgICBjb25zdCBtb2RpZmllcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQubW9kaWZpZXJzKTtcbiAgICBpZiAoZGVmLm1vZGlmaWVycykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgQXNzZXJ0KCFwcm90b3R5cGVbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllciA9IGRlZi5tb2RpZmllcnNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGlmaWVyID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBtb2RpZmllciBkZWZpbml0aW9uIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKGFyZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVsZSh7IFtuYW1lXTogYXJnIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgbW9kaWZpZXJzW25hbWVdID0gbW9kaWZpZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXG4gICAgLy8gT3ZlcnJpZGVzXG5cbiAgICBpZiAoZGVmLm92ZXJyaWRlcykge1xuICAgICAgICBwcm90b3R5cGUuX3N1cGVyID0gYmFzZTtcbiAgICAgICAgc2NoZW1hLiRfc3VwZXIgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBmb3IgKGNvbnN0IG92ZXJyaWRlIGluIGRlZi5vdmVycmlkZXMpIHtcbiAgICAgICAgICAgIEFzc2VydChiYXNlW292ZXJyaWRlXSwgJ0Nhbm5vdCBvdmVycmlkZSBtaXNzaW5nJywgb3ZlcnJpZGUpO1xuICAgICAgICAgICAgZGVmLm92ZXJyaWRlc1tvdmVycmlkZV1bQ29tbW9uLnN5bWJvbHMucGFyZW50XSA9IGJhc2Vbb3ZlcnJpZGVdO1xuICAgICAgICAgICAgc2NoZW1hLiRfc3VwZXJbb3ZlcnJpZGVdID0gYmFzZVtvdmVycmlkZV0uYmluZChzY2hlbWEpOyAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHByb3RvdHlwZSwgZGVmLm92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FzdHNcblxuICAgIGRlZi5jYXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LmNhc3QsIGRlZi5jYXN0KTtcblxuICAgIC8vIE1hbmlmZXN0XG5cbiAgICBjb25zdCBtYW5pZmVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5tYW5pZmVzdCwgZGVmLm1hbmlmZXN0KTtcbiAgICBtYW5pZmVzdC5idWlsZCA9IGludGVybmFscy5idWlsZChkZWYubWFuaWZlc3QgJiYgZGVmLm1hbmlmZXN0LmJ1aWxkLCBwYXJlbnQubWFuaWZlc3QgJiYgcGFyZW50Lm1hbmlmZXN0LmJ1aWxkKTtcbiAgICBkZWYubWFuaWZlc3QgPSBtYW5pZmVzdDtcblxuICAgIC8vIFJlYnVpbGRcblxuICAgIGRlZi5yZWJ1aWxkID0gaW50ZXJuYWxzLnJlYnVpbGQoZGVmLnJlYnVpbGQsIHBhcmVudC5yZWJ1aWxkKTtcblxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmJ1aWxkID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gcGFyZW50KGNoaWxkKG9iaiwgZGVzYyksIGRlc2MpO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5jb2VyY2UgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBjaGlsZC5mcm9tICYmIHBhcmVudC5mcm9tID8gWy4uLm5ldyBTZXQoWy4uLmNoaWxkLmZyb20sIC4uLnBhcmVudC5mcm9tXSldIDogbnVsbCxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgIGxldCBjb2VyY2VkO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIGNvZXJjZWQgPSBwYXJlbnQubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAoY29lcmNlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29lcmNlZC5lcnJvcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2hpbGQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIGNoaWxkLmZyb20uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3duID0gY2hpbGQubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAob3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvd247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cbmludGVybmFscy5wcmVwYXJlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgIGNvbnN0IHByZXBhcmVkID0gY2hpbGQodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocHJlcGFyZWQpIHtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZC5lcnJvcnMgfHxcbiAgICAgICAgICAgICAgICBwcmVwYXJlZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlcGFyZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcHJlcGFyZWQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50KHZhbHVlLCBoZWxwZXJzKSB8fCBwcmVwYXJlZDtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMucmVidWlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICAgICAgcGFyZW50KHNjaGVtYSk7XG4gICAgICAgIGNoaWxkKHNjaGVtYSk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcmVudCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzICYmXG4gICAgICAgICAgICAgICAgKCFBcnJheS5pc0FycmF5KHJlc3VsdC5lcnJvcnMpIHx8IHJlc3VsdC5lcnJvcnMubGVuZ3RoKSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQodmFsdWUsIGhlbHBlcnMpIHx8IHJlc3VsdDtcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/extend.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/index.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\n\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/joi/lib/cache.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ./compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Extend = __webpack_require__(/*! ./extend */ \"(rsc)/./node_modules/joi/lib/extend.js\");\nconst Manifest = __webpack_require__(/*! ./manifest */ \"(rsc)/./node_modules/joi/lib/manifest.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\nconst Trace = __webpack_require__(/*! ./trace */ \"(rsc)/./node_modules/joi/lib/trace.js\");\n\nlet Schemas;\n\n\nconst internals = {\n    types: {\n        alternatives: __webpack_require__(/*! ./types/alternatives */ \"(rsc)/./node_modules/joi/lib/types/alternatives.js\"),\n        any: __webpack_require__(/*! ./types/any */ \"(rsc)/./node_modules/joi/lib/types/any.js\"),\n        array: __webpack_require__(/*! ./types/array */ \"(rsc)/./node_modules/joi/lib/types/array.js\"),\n        boolean: __webpack_require__(/*! ./types/boolean */ \"(rsc)/./node_modules/joi/lib/types/boolean.js\"),\n        date: __webpack_require__(/*! ./types/date */ \"(rsc)/./node_modules/joi/lib/types/date.js\"),\n        function: __webpack_require__(/*! ./types/function */ \"(rsc)/./node_modules/joi/lib/types/function.js\"),\n        link: __webpack_require__(/*! ./types/link */ \"(rsc)/./node_modules/joi/lib/types/link.js\"),\n        number: __webpack_require__(/*! ./types/number */ \"(rsc)/./node_modules/joi/lib/types/number.js\"),\n        object: __webpack_require__(/*! ./types/object */ \"(rsc)/./node_modules/joi/lib/types/object.js\"),\n        string: __webpack_require__(/*! ./types/string */ \"(rsc)/./node_modules/joi/lib/types/string.js\"),\n        symbol: __webpack_require__(/*! ./types/symbol */ \"(rsc)/./node_modules/joi/lib/types/symbol.js\")\n    },\n    aliases: {\n        alt: 'alternatives',\n        bool: 'boolean',\n        func: 'function'\n    }\n};\n\n\nif (Buffer) {                                                           // $lab:coverage:ignore$\n    internals.types.binary = __webpack_require__(/*! ./types/binary */ \"(rsc)/./node_modules/joi/lib/types/binary.js\");\n}\n\n\ninternals.root = function () {\n\n    const root = {\n        _types: new Set(Object.keys(internals.types))\n    };\n\n    // Types\n\n    for (const type of root._types) {\n        root[type] = function (...args) {\n\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\n            return internals.generate(this, internals.types[type], args);\n        };\n    }\n\n    // Shortcuts\n\n    for (const method of ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']) {\n        root[method] = function (...args) {\n\n            return this.any()[method](...args);\n        };\n    }\n\n    // Methods\n\n    Object.assign(root, internals.methods);\n\n    // Aliases\n\n    for (const alias in internals.aliases) {\n        const target = internals.aliases[alias];\n        root[alias] = root[target];\n    }\n\n    root.x = root.expression;\n\n    // Trace\n\n    if (Trace.setup) {                                          // $lab:coverage:ignore$\n        Trace.setup(root);\n    }\n\n    return root;\n};\n\n\ninternals.methods = {\n\n    ValidationError: Errors.ValidationError,\n    version: Common.version,\n    cache: Cache.provider,\n\n    assert(value, schema, ...args /* [message], [options] */) {\n\n        internals.assert(value, schema, true, args);\n    },\n\n    attempt(value, schema, ...args /* [message], [options] */) {\n\n        return internals.assert(value, schema, false, args);\n    },\n\n    build(desc) {\n\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\n        return Manifest.build(this, desc);\n    },\n\n    checkPreferences(prefs) {\n\n        Common.checkPreferences(prefs);\n    },\n\n    compile(schema, options) {\n\n        return Compile.compile(this, schema, options);\n    },\n\n    defaults(modifier) {\n\n        Assert(typeof modifier === 'function', 'modifier must be a function');\n\n        const joi = Object.assign({}, this);\n        for (const type of joi._types) {\n            const schema = modifier(joi[type]());\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\n\n            joi[type] = function (...args) {\n\n                return internals.generate(this, schema, args);\n            };\n        }\n\n        return joi;\n    },\n\n    expression(...args) {\n\n        return new Template(...args);\n    },\n\n    extend(...extensions) {\n\n        Common.verifyFlat(extensions, 'extend');\n\n        Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/joi/lib/schemas.js\");\n\n        Assert(extensions.length, 'You need to provide at least one extension');\n        this.assert(extensions, Schemas.extensions);\n\n        const joi = Object.assign({}, this);\n        joi._types = new Set(joi._types);\n\n        for (let extension of extensions) {\n            if (typeof extension === 'function') {\n                extension = extension(joi);\n            }\n\n            this.assert(extension, Schemas.extension);\n\n            const expanded = internals.expandExtension(extension, joi);\n            for (const item of expanded) {\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\n\n                const base = item.base || this.any();\n                const schema = Extend.type(base, item);\n\n                joi._types.add(item.type);\n                joi[item.type] = function (...args) {\n\n                    return internals.generate(this, schema, args);\n                };\n            }\n        }\n\n        return joi;\n    },\n\n    isError: Errors.ValidationError.isError,\n    isExpression: Template.isTemplate,\n    isRef: Ref.isRef,\n    isSchema: Common.isSchema,\n\n    in(...args) {\n\n        return Ref.in(...args);\n    },\n\n    override: Common.symbols.override,\n\n    ref(...args) {\n\n        return Ref.create(...args);\n    },\n\n    types() {\n\n        const types = {};\n        for (const type of this._types) {\n            types[type] = this[type]();\n        }\n\n        for (const target in internals.aliases) {\n            types[target] = this[target]();\n        }\n\n        return types;\n    }\n};\n\n\n// Helpers\n\ninternals.assert = function (value, schema, annotate, args /* [message], [options] */) {\n\n    const message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;\n    const options = message !== null ? args[1] : args[0];\n    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));\n\n    let error = result.error;\n    if (!error) {\n        return result.value;\n    }\n\n    if (message instanceof Error) {\n        throw message;\n    }\n\n    const display = annotate && typeof error.annotate === 'function' ? error.annotate() : error.message;\n\n    if (error instanceof Errors.ValidationError === false) {\n        error = Clone(error);\n    }\n\n    error.message = message ? `${message} ${display}` : display;\n    throw error;\n};\n\n\ninternals.generate = function (root, schema, args) {\n\n    Assert(root, 'Must be invoked on a Joi instance.');\n\n    schema.$_root = root;\n\n    if (!schema._definition.args ||\n        !args.length) {\n\n        return schema;\n    }\n\n    return schema._definition.args(schema, ...args);\n};\n\n\ninternals.expandExtension = function (extension, joi) {\n\n    if (typeof extension.type === 'string') {\n        return [extension];\n    }\n\n    const extended = [];\n    for (const type of joi._types) {\n        if (extension.type.test(type)) {\n            const item = Object.assign({}, extension);\n            item.type = type;\n            item.base = joi[type]();\n            extended.push(item);\n        }\n    }\n\n    return extended;\n};\n\n\nmodule.exports = internals.root();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsNEVBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQywwRUFBc0I7O0FBRTVDLGNBQWMsbUJBQU8sQ0FBQyxzREFBUztBQUMvQixlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVc7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBWTtBQUNyQyxZQUFZLG1CQUFPLENBQUMsa0RBQU87QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsNERBQVk7QUFDckMsY0FBYyxtQkFBTyxDQUFDLHNEQUFTOztBQUUvQjs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLGdGQUFzQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsOERBQWE7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLGtFQUFlO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFpQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsZ0VBQWM7QUFDcEMsa0JBQWtCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBZ0I7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFnQjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBZ0I7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esd0VBQXdFO0FBQ3hFLDZCQUE2QixtQkFBTyxDQUFDLG9FQUFnQjtBQUNyRDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLDZCQUE2QixtQkFBTyxDQUFDLDBEQUFXOztBQUVoRDtBQUNBOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0QsVUFBVSxlQUFlLGVBQWU7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFNBQVMsRUFBRSxRQUFRO0FBQ3BEO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MaXN0ZW4vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9pbmRleC5qcz9iYWYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuY29uc3QgTWFuaWZlc3QgPSByZXF1aXJlKCcuL21hbmlmZXN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vdHJhY2UnKTtcblxubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHR5cGVzOiB7XG4gICAgICAgIGFsdGVybmF0aXZlczogcmVxdWlyZSgnLi90eXBlcy9hbHRlcm5hdGl2ZXMnKSxcbiAgICAgICAgYW55OiByZXF1aXJlKCcuL3R5cGVzL2FueScpLFxuICAgICAgICBhcnJheTogcmVxdWlyZSgnLi90eXBlcy9hcnJheScpLFxuICAgICAgICBib29sZWFuOiByZXF1aXJlKCcuL3R5cGVzL2Jvb2xlYW4nKSxcbiAgICAgICAgZGF0ZTogcmVxdWlyZSgnLi90eXBlcy9kYXRlJyksXG4gICAgICAgIGZ1bmN0aW9uOiByZXF1aXJlKCcuL3R5cGVzL2Z1bmN0aW9uJyksXG4gICAgICAgIGxpbms6IHJlcXVpcmUoJy4vdHlwZXMvbGluaycpLFxuICAgICAgICBudW1iZXI6IHJlcXVpcmUoJy4vdHlwZXMvbnVtYmVyJyksXG4gICAgICAgIG9iamVjdDogcmVxdWlyZSgnLi90eXBlcy9vYmplY3QnKSxcbiAgICAgICAgc3RyaW5nOiByZXF1aXJlKCcuL3R5cGVzL3N0cmluZycpLFxuICAgICAgICBzeW1ib2w6IHJlcXVpcmUoJy4vdHlwZXMvc3ltYm9sJylcbiAgICB9LFxuICAgIGFsaWFzZXM6IHtcbiAgICAgICAgYWx0OiAnYWx0ZXJuYXRpdmVzJyxcbiAgICAgICAgYm9vbDogJ2Jvb2xlYW4nLFxuICAgICAgICBmdW5jOiAnZnVuY3Rpb24nXG4gICAgfVxufTtcblxuXG5pZiAoQnVmZmVyKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICBpbnRlcm5hbHMudHlwZXMuYmluYXJ5ID0gcmVxdWlyZSgnLi90eXBlcy9iaW5hcnknKTtcbn1cblxuXG5pbnRlcm5hbHMucm9vdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHJvb3QgPSB7XG4gICAgICAgIF90eXBlczogbmV3IFNldChPYmplY3Qua2V5cyhpbnRlcm5hbHMudHlwZXMpKVxuICAgIH07XG5cbiAgICAvLyBUeXBlc1xuXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHJvb3QuX3R5cGVzKSB7XG4gICAgICAgIHJvb3RbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICBBc3NlcnQoIWFyZ3MubGVuZ3RoIHx8IFsnYWx0ZXJuYXRpdmVzJywgJ2xpbmsnLCAnb2JqZWN0J10uaW5jbHVkZXModHlwZSksICdUaGUnLCB0eXBlLCAndHlwZSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgaW50ZXJuYWxzLnR5cGVzW3R5cGVdLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dHNcblxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIFsnYWxsb3cnLCAnY3VzdG9tJywgJ2Rpc2FsbG93JywgJ2VxdWFsJywgJ2V4aXN0JywgJ2ZvcmJpZGRlbicsICdpbnZhbGlkJywgJ25vdCcsICdvbmx5JywgJ29wdGlvbmFsJywgJ29wdGlvbnMnLCAncHJlZnMnLCAncHJlZmVyZW5jZXMnLCAncmVxdWlyZWQnLCAnc3RyaXAnLCAndmFsaWQnLCAnd2hlbiddKSB7XG4gICAgICAgIHJvb3RbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFueSgpW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kc1xuXG4gICAgT2JqZWN0LmFzc2lnbihyb290LCBpbnRlcm5hbHMubWV0aG9kcyk7XG5cbiAgICAvLyBBbGlhc2VzXG5cbiAgICBmb3IgKGNvbnN0IGFsaWFzIGluIGludGVybmFscy5hbGlhc2VzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGludGVybmFscy5hbGlhc2VzW2FsaWFzXTtcbiAgICAgICAgcm9vdFthbGlhc10gPSByb290W3RhcmdldF07XG4gICAgfVxuXG4gICAgcm9vdC54ID0gcm9vdC5leHByZXNzaW9uO1xuXG4gICAgLy8gVHJhY2VcblxuICAgIGlmIChUcmFjZS5zZXR1cCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICBUcmFjZS5zZXR1cChyb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbn07XG5cblxuaW50ZXJuYWxzLm1ldGhvZHMgPSB7XG5cbiAgICBWYWxpZGF0aW9uRXJyb3I6IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IsXG4gICAgdmVyc2lvbjogQ29tbW9uLnZlcnNpb24sXG4gICAgY2FjaGU6IENhY2hlLnByb3ZpZGVyLFxuXG4gICAgYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIC4uLmFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICBpbnRlcm5hbHMuYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIHRydWUsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBhdHRlbXB0KHZhbHVlLCBzY2hlbWEsIC4uLmFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmFzc2VydCh2YWx1ZSwgc2NoZW1hLCBmYWxzZSwgYXJncyk7XG4gICAgfSxcblxuICAgIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIE1hbmlmZXN0LmJ1aWxkID09PSAnZnVuY3Rpb24nLCAnTWFuaWZlc3QgZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gTWFuaWZlc3QuYnVpbGQodGhpcywgZGVzYyk7XG4gICAgfSxcblxuICAgIGNoZWNrUHJlZmVyZW5jZXMocHJlZnMpIHtcblxuICAgICAgICBDb21tb24uY2hlY2tQcmVmZXJlbmNlcyhwcmVmcyk7XG4gICAgfSxcblxuICAgIGNvbXBpbGUoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIENvbXBpbGUuY29tcGlsZSh0aGlzLCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBkZWZhdWx0cyhtb2RpZmllcikge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbW9kaWZpZXIgPT09ICdmdW5jdGlvbicsICdtb2RpZmllciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGpvaS5fdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGlmaWVyKGpvaVt0eXBlXSgpKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSwgJ21vZGlmaWVyIG11c3QgcmV0dXJuIGEgdmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuXG4gICAgICAgICAgICBqb2lbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBzY2hlbWEsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqb2k7XG4gICAgfSxcblxuICAgIGV4cHJlc3Npb24oLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUoLi4uYXJncyk7XG4gICAgfSxcblxuICAgIGV4dGVuZCguLi5leHRlbnNpb25zKSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoZXh0ZW5zaW9ucywgJ2V4dGVuZCcpO1xuXG4gICAgICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgICAgIEFzc2VydChleHRlbnNpb25zLmxlbmd0aCwgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYXQgbGVhc3Qgb25lIGV4dGVuc2lvbicpO1xuICAgICAgICB0aGlzLmFzc2VydChleHRlbnNpb25zLCBTY2hlbWFzLmV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGNvbnN0IGpvaSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMpO1xuICAgICAgICBqb2kuX3R5cGVzID0gbmV3IFNldChqb2kuX3R5cGVzKTtcblxuICAgICAgICBmb3IgKGxldCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oam9pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9uLCBTY2hlbWFzLmV4dGVuc2lvbik7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gaW50ZXJuYWxzLmV4cGFuZEV4dGVuc2lvbihleHRlbnNpb24sIGpvaSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoam9pW2l0ZW0udHlwZV0gPT09IHVuZGVmaW5lZCB8fCBqb2kuX3R5cGVzLmhhcyhpdGVtLnR5cGUpLCAnQ2Fubm90IG92ZXJyaWRlIG5hbWUnLCBpdGVtLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IGl0ZW0uYmFzZSB8fCB0aGlzLmFueSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IEV4dGVuZC50eXBlKGJhc2UsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgam9pLl90eXBlcy5hZGQoaXRlbS50eXBlKTtcbiAgICAgICAgICAgICAgICBqb2lbaXRlbS50eXBlXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBzY2hlbWEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH0sXG5cbiAgICBpc0Vycm9yOiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IsXG4gICAgaXNFeHByZXNzaW9uOiBUZW1wbGF0ZS5pc1RlbXBsYXRlLFxuICAgIGlzUmVmOiBSZWYuaXNSZWYsXG4gICAgaXNTY2hlbWE6IENvbW1vbi5pc1NjaGVtYSxcblxuICAgIGluKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmluKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBvdmVycmlkZTogQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGUsXG5cbiAgICByZWYoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBSZWYuY3JlYXRlKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICB0eXBlcygpIHtcblxuICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy5fdHlwZXMpIHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gdGhpc1t0eXBlXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgaW4gaW50ZXJuYWxzLmFsaWFzZXMpIHtcbiAgICAgICAgICAgIHR5cGVzW3RhcmdldF0gPSB0aGlzW3RhcmdldF0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG59O1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmFzc2VydCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBhbm5vdGF0ZSwgYXJncyAvKiBbbWVzc2FnZV0sIFtvcHRpb25zXSAqLykge1xuXG4gICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgPyBhcmdzWzBdIDogbnVsbDtcbiAgICBjb25zdCBvcHRpb25zID0gbWVzc2FnZSAhPT0gbnVsbCA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS52YWxpZGF0ZSh2YWx1ZSwgQ29tbW9uLnByZWZlcmVuY2VzKHsgZXJyb3JzOiB7IHN0YWNrOiB0cnVlIH0gfSwgb3B0aW9ucyB8fCB7fSkpO1xuXG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgZGlzcGxheSA9IGFubm90YXRlICYmIHR5cGVvZiBlcnJvci5hbm5vdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGVycm9yLmFubm90YXRlKCkgOiBlcnJvci5tZXNzYWdlO1xuXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3JzLlZhbGlkYXRpb25FcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgZXJyb3IgPSBDbG9uZShlcnJvcik7XG4gICAgfVxuXG4gICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2UgPyBgJHttZXNzYWdlfSAke2Rpc3BsYXl9YCA6IGRpc3BsYXk7XG4gICAgdGhyb3cgZXJyb3I7XG59O1xuXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChyb290LCBzY2hlbWEsIGFyZ3MpIHtcblxuICAgIEFzc2VydChyb290LCAnTXVzdCBiZSBpbnZva2VkIG9uIGEgSm9pIGluc3RhbmNlLicpO1xuXG4gICAgc2NoZW1hLiRfcm9vdCA9IHJvb3Q7XG5cbiAgICBpZiAoIXNjaGVtYS5fZGVmaW5pdGlvbi5hcmdzIHx8XG4gICAgICAgICFhcmdzLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5fZGVmaW5pdGlvbi5hcmdzKHNjaGVtYSwgLi4uYXJncyk7XG59O1xuXG5cbmludGVybmFscy5leHBhbmRFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uLCBqb2kpIHtcblxuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbmRlZCA9IFtdO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBqb2kuX3R5cGVzKSB7XG4gICAgICAgIGlmIChleHRlbnNpb24udHlwZS50ZXN0KHR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIGl0ZW0udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpdGVtLmJhc2UgPSBqb2lbdHlwZV0oKTtcbiAgICAgICAgICAgIGV4dGVuZGVkLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLnJvb3QoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/manifest.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/manifest.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\n\nlet Schemas;\n\n\nconst internals = {};\n\n\nexports.describe = function (schema) {\n\n    const def = schema._definition;\n\n    // Type\n\n    const desc = {\n        type: schema.type,\n        flags: {},\n        rules: []\n    };\n\n    // Flags\n\n    for (const flag in schema._flags) {\n        if (flag[0] !== '_') {\n            desc.flags[flag] = internals.describe(schema._flags[flag]);\n        }\n    }\n\n    if (!Object.keys(desc.flags).length) {\n        delete desc.flags;\n    }\n\n    // Preferences\n\n    if (schema._preferences) {\n        desc.preferences = Clone(schema._preferences, { shallow: ['messages'] });\n        delete desc.preferences[Common.symbols.prefs];\n        if (desc.preferences.messages) {\n            desc.preferences.messages = Messages.decompile(desc.preferences.messages);\n        }\n    }\n\n    // Allow / Invalid\n\n    if (schema._valids) {\n        desc.allow = schema._valids.describe();\n    }\n\n    if (schema._invalids) {\n        desc.invalid = schema._invalids.describe();\n    }\n\n    // Rules\n\n    for (const rule of schema._rules) {\n        const ruleDef = def.rules[rule.name];\n        if (ruleDef.manifest === false) {                           // Defaults to true\n            continue;\n        }\n\n        const item = { name: rule.name };\n\n        for (const custom in def.modifiers) {\n            if (rule[custom] !== undefined) {\n                item[custom] = internals.describe(rule[custom]);\n            }\n        }\n\n        if (rule.args) {\n            item.args = {};\n            for (const key in rule.args) {\n                const arg = rule.args[key];\n                if (key === 'options' &&\n                    !Object.keys(arg).length) {\n\n                    continue;\n                }\n\n                item.args[key] = internals.describe(arg, { assign: key });\n            }\n\n            if (!Object.keys(item.args).length) {\n                delete item.args;\n            }\n        }\n\n        desc.rules.push(item);\n    }\n\n    if (!desc.rules.length) {\n        delete desc.rules;\n    }\n\n    // Terms (must be last to verify no name conflicts)\n\n    for (const term in schema.$_terms) {\n        if (term[0] === '_') {\n            continue;\n        }\n\n        Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);\n\n        const items = schema.$_terms[term];\n        if (!items) {\n            continue;\n        }\n\n        if (items instanceof Map) {\n            if (items.size) {\n                desc[term] = [...items.entries()];\n            }\n\n            continue;\n        }\n\n        if (Common.isValues(items)) {\n            desc[term] = items.describe();\n            continue;\n        }\n\n        Assert(def.terms[term], 'Term', term, 'missing configuration');\n        const manifest = def.terms[term].manifest;\n        const mapped = typeof manifest === 'object';\n        if (!items.length &&\n            !mapped) {\n\n            continue;\n        }\n\n        const normalized = [];\n        for (const item of items) {\n            normalized.push(internals.describe(item));\n        }\n\n        // Mapped\n\n        if (mapped) {\n            const { from, to } = manifest.mapped;\n            desc[term] = {};\n            for (const item of normalized) {\n                desc[term][item[to]] = item[from];\n            }\n\n            continue;\n        }\n\n        // Single\n\n        if (manifest === 'single') {\n            Assert(normalized.length === 1, 'Term', term, 'contains more than one item');\n            desc[term] = normalized[0];\n            continue;\n        }\n\n        // Array\n\n        desc[term] = normalized;\n    }\n\n    internals.validate(schema.$_root, desc);\n    return desc;\n};\n\n\ninternals.describe = function (item, options = {}) {\n\n    if (Array.isArray(item)) {\n        return item.map(internals.describe);\n    }\n\n    if (item === Common.symbols.deepDefault) {\n        return { special: 'deep' };\n    }\n\n    if (typeof item !== 'object' ||\n        item === null) {\n\n        return item;\n    }\n\n    if (options.assign === 'options') {\n        return Clone(item);\n    }\n\n    if (Buffer && Buffer.isBuffer(item)) {                          // $lab:coverage:ignore$\n        return { buffer: item.toString('binary') };\n    }\n\n    if (item instanceof Date) {\n        return item.toISOString();\n    }\n\n    if (item instanceof Error) {\n        return item;\n    }\n\n    if (item instanceof RegExp) {\n        if (options.assign === 'regex') {\n            return item.toString();\n        }\n\n        return { regex: item.toString() };\n    }\n\n    if (item[Common.symbols.literal]) {\n        return { function: item.literal };\n    }\n\n    if (typeof item.describe === 'function') {\n        if (options.assign === 'ref') {\n            return item.describe().ref;\n        }\n\n        return item.describe();\n    }\n\n    const normalized = {};\n    for (const key in item) {\n        const value = item[key];\n        if (value === undefined) {\n            continue;\n        }\n\n        normalized[key] = internals.describe(value, { assign: key });\n    }\n\n    return normalized;\n};\n\n\nexports.build = function (joi, desc) {\n\n    const builder = new internals.Builder(joi);\n    return builder.parse(desc);\n};\n\n\ninternals.Builder = class {\n\n    constructor(joi) {\n\n        this.joi = joi;\n    }\n\n    parse(desc) {\n\n        internals.validate(this.joi, desc);\n\n        // Type\n\n        let schema = this.joi[desc.type]()._bare();\n        const def = schema._definition;\n\n        // Flags\n\n        if (desc.flags) {\n            for (const flag in desc.flags) {\n                const setter = def.flags[flag] && def.flags[flag].setter || flag;\n                Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);\n                schema = schema[setter](this.build(desc.flags[flag]));\n            }\n        }\n\n        // Preferences\n\n        if (desc.preferences) {\n            schema = schema.preferences(this.build(desc.preferences));\n        }\n\n        // Allow / Invalid\n\n        if (desc.allow) {\n            schema = schema.allow(...this.build(desc.allow));\n        }\n\n        if (desc.invalid) {\n            schema = schema.invalid(...this.build(desc.invalid));\n        }\n\n        // Rules\n\n        if (desc.rules) {\n            for (const rule of desc.rules) {\n                Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);\n\n                const args = [];\n                if (rule.args) {\n                    const built = {};\n                    for (const key in rule.args) {\n                        built[key] = this.build(rule.args[key], { assign: key });\n                    }\n\n                    const keys = Object.keys(built);\n                    const definition = def.rules[rule.name].args;\n                    if (definition) {\n                        Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');\n                        for (const { name } of definition) {\n                            args.push(built[name]);\n                        }\n                    }\n                    else {\n                        Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');\n                        args.push(built[keys[0]]);\n                    }\n                }\n\n                // Apply\n\n                schema = schema[rule.name](...args);\n\n                // Ruleset\n\n                const options = {};\n                for (const custom in def.modifiers) {\n                    if (rule[custom] !== undefined) {\n                        options[custom] = this.build(rule[custom]);\n                    }\n                }\n\n                if (Object.keys(options).length) {\n                    schema = schema.rule(options);\n                }\n            }\n        }\n\n        // Terms\n\n        const terms = {};\n        for (const key in desc) {\n            if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {\n                continue;\n            }\n\n            Assert(def.terms[key], 'Term', key, 'missing configuration');\n            const manifest = def.terms[key].manifest;\n\n            if (manifest === 'schema') {\n                terms[key] = desc[key].map((item) => this.parse(item));\n                continue;\n            }\n\n            if (manifest === 'values') {\n                terms[key] = desc[key].map((item) => this.build(item));\n                continue;\n            }\n\n            if (manifest === 'single') {\n                terms[key] = this.build(desc[key]);\n                continue;\n            }\n\n            if (typeof manifest === 'object') {\n                terms[key] = {};\n                for (const name in desc[key]) {\n                    const value = desc[key][name];\n                    terms[key][name] = this.parse(value);\n                }\n\n                continue;\n            }\n\n            terms[key] = this.build(desc[key]);\n        }\n\n        if (desc.whens) {\n            terms.whens = desc.whens.map((when) => this.build(when));\n        }\n\n        schema = def.manifest.build(schema, terms);\n        schema.$_temp.ruleset = false;\n        return schema;\n    }\n\n    build(desc, options = {}) {\n\n        if (desc === null) {\n            return null;\n        }\n\n        if (Array.isArray(desc)) {\n            return desc.map((item) => this.build(item));\n        }\n\n        if (desc instanceof Error) {\n            return desc;\n        }\n\n        if (options.assign === 'options') {\n            return Clone(desc);\n        }\n\n        if (options.assign === 'regex') {\n            return internals.regex(desc);\n        }\n\n        if (options.assign === 'ref') {\n            return Ref.build(desc);\n        }\n\n        if (typeof desc !== 'object') {\n            return desc;\n        }\n\n        if (Object.keys(desc).length === 1) {\n            if (desc.buffer) {\n                Assert(Buffer, 'Buffers are not supported');\n                return Buffer && Buffer.from(desc.buffer, 'binary');                    // $lab:coverage:ignore$\n            }\n\n            if (desc.function) {\n                return { [Common.symbols.literal]: true, literal: desc.function };\n            }\n\n            if (desc.override) {\n                return Common.symbols.override;\n            }\n\n            if (desc.ref) {\n                return Ref.build(desc.ref);\n            }\n\n            if (desc.regex) {\n                return internals.regex(desc.regex);\n            }\n\n            if (desc.special) {\n                Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);\n                return Common.symbols.deepDefault;\n            }\n\n            if (desc.value) {\n                return Clone(desc.value);\n            }\n        }\n\n        if (desc.type) {\n            return this.parse(desc);\n        }\n\n        if (desc.template) {\n            return Template.build(desc);\n        }\n\n        const normalized = {};\n        for (const key in desc) {\n            normalized[key] = this.build(desc[key], { assign: key });\n        }\n\n        return normalized;\n    }\n};\n\n\ninternals.regex = function (string) {\n\n    const end = string.lastIndexOf('/');\n    const exp = string.slice(1, end);\n    const flags = string.slice(end + 1);\n    return new RegExp(exp, flags);\n};\n\n\ninternals.validate = function (joi, desc) {\n\n    Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/joi/lib/schemas.js\");\n\n    joi.assert(desc, Schemas.description);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tYW5pZmVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsNEVBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQywwRUFBc0I7O0FBRTVDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBWTtBQUNyQyxZQUFZLG1CQUFPLENBQUMsa0RBQU87QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsNERBQVk7O0FBRXJDOzs7QUFHQTs7O0FBR0EsZ0JBQWdCOztBQUVoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJEQUEyRCxhQUFhO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9FQUFvRTtBQUNwRSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGFBQWE7QUFDbkU7O0FBRUE7QUFDQTs7O0FBR0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsYUFBYTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4Rjs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLHlCQUF5QixtQkFBTyxDQUFDLDBEQUFXOztBQUU1QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbWFuaWZlc3QuanM/MjA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX2RlZmluaXRpb247XG5cbiAgICAvLyBUeXBlXG5cbiAgICBjb25zdCBkZXNjID0ge1xuICAgICAgICB0eXBlOiBzY2hlbWEudHlwZSxcbiAgICAgICAgZmxhZ3M6IHt9LFxuICAgICAgICBydWxlczogW11cbiAgICB9O1xuXG4gICAgLy8gRmxhZ3NcblxuICAgIGZvciAoY29uc3QgZmxhZyBpbiBzY2hlbWEuX2ZsYWdzKSB7XG4gICAgICAgIGlmIChmbGFnWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIGRlc2MuZmxhZ3NbZmxhZ10gPSBpbnRlcm5hbHMuZGVzY3JpYmUoc2NoZW1hLl9mbGFnc1tmbGFnXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKGRlc2MuZmxhZ3MpLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgZGVzYy5mbGFncztcbiAgICB9XG5cbiAgICAvLyBQcmVmZXJlbmNlc1xuXG4gICAgaWYgKHNjaGVtYS5fcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgZGVzYy5wcmVmZXJlbmNlcyA9IENsb25lKHNjaGVtYS5fcHJlZmVyZW5jZXMsIHsgc2hhbGxvdzogWydtZXNzYWdlcyddIH0pO1xuICAgICAgICBkZWxldGUgZGVzYy5wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgICAgIGlmIChkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzID0gTWVzc2FnZXMuZGVjb21waWxlKGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgLyBJbnZhbGlkXG5cbiAgICBpZiAoc2NoZW1hLl92YWxpZHMpIHtcbiAgICAgICAgZGVzYy5hbGxvdyA9IHNjaGVtYS5fdmFsaWRzLmRlc2NyaWJlKCk7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5faW52YWxpZHMpIHtcbiAgICAgICAgZGVzYy5pbnZhbGlkID0gc2NoZW1hLl9pbnZhbGlkcy5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIC8vIFJ1bGVzXG5cbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygc2NoZW1hLl9ydWxlcykge1xuICAgICAgICBjb25zdCBydWxlRGVmID0gZGVmLnJ1bGVzW3J1bGUubmFtZV07XG4gICAgICAgIGlmIChydWxlRGVmLm1hbmlmZXN0ID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHsgbmFtZTogcnVsZS5uYW1lIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBjdXN0b20gaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgaWYgKHJ1bGVbY3VzdG9tXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbVtjdXN0b21dID0gaW50ZXJuYWxzLmRlc2NyaWJlKHJ1bGVbY3VzdG9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICBpdGVtLmFyZ3MgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IHJ1bGUuYXJnc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdvcHRpb25zJyAmJlxuICAgICAgICAgICAgICAgICAgICAhT2JqZWN0LmtleXMoYXJnKS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtLmFyZ3Nba2V5XSA9IGludGVybmFscy5kZXNjcmliZShhcmcsIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoaXRlbS5hcmdzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5hcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYy5ydWxlcy5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIGlmICghZGVzYy5ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGRlc2MucnVsZXM7XG4gICAgfVxuXG4gICAgLy8gVGVybXMgKG11c3QgYmUgbGFzdCB0byB2ZXJpZnkgbm8gbmFtZSBjb25mbGljdHMpXG5cbiAgICBmb3IgKGNvbnN0IHRlcm0gaW4gc2NoZW1hLiRfdGVybXMpIHtcbiAgICAgICAgaWYgKHRlcm1bMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQoIWRlc2NbdGVybV0sICdDYW5ub3QgZGVzY3JpYmUgc2NoZW1hIGR1ZSB0byBpbnRlcm5hbCBuYW1lIGNvbmZsaWN0IHdpdGgnLCB0ZXJtKTtcblxuICAgICAgICBjb25zdCBpdGVtcyA9IHNjaGVtYS4kX3Rlcm1zW3Rlcm1dO1xuICAgICAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgaWYgKGl0ZW1zLnNpemUpIHtcbiAgICAgICAgICAgICAgICBkZXNjW3Rlcm1dID0gWy4uLml0ZW1zLmVudHJpZXMoKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1ZhbHVlcyhpdGVtcykpIHtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSBpdGVtcy5kZXNjcmliZSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQoZGVmLnRlcm1zW3Rlcm1dLCAnVGVybScsIHRlcm0sICdtaXNzaW5nIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBkZWYudGVybXNbdGVybV0ubWFuaWZlc3Q7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHR5cGVvZiBtYW5pZmVzdCA9PT0gJ29iamVjdCc7XG4gICAgICAgIGlmICghaXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhbWFwcGVkKSB7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChpbnRlcm5hbHMuZGVzY3JpYmUoaXRlbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFwcGVkXG5cbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gbWFuaWZlc3QubWFwcGVkO1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBkZXNjW3Rlcm1dW2l0ZW1bdG9dXSA9IGl0ZW1bZnJvbV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlXG5cbiAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgQXNzZXJ0KG5vcm1hbGl6ZWQubGVuZ3RoID09PSAxLCAnVGVybScsIHRlcm0sICdjb250YWlucyBtb3JlIHRoYW4gb25lIGl0ZW0nKTtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSBub3JtYWxpemVkWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcnJheVxuXG4gICAgICAgIGRlc2NbdGVybV0gPSBub3JtYWxpemVkO1xuICAgIH1cblxuICAgIGludGVybmFscy52YWxpZGF0ZShzY2hlbWEuJF9yb290LCBkZXNjKTtcbiAgICByZXR1cm4gZGVzYztcbn07XG5cblxuaW50ZXJuYWxzLmRlc2NyaWJlID0gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubWFwKGludGVybmFscy5kZXNjcmliZSk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gPT09IENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiB7IHNwZWNpYWw6ICdkZWVwJyB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgaXRlbSA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIHJldHVybiBDbG9uZShpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgIHJldHVybiB7IGJ1ZmZlcjogaXRlbS50b1N0cmluZygnYmluYXJ5JykgfTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZ2V4Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlZ2V4OiBpdGVtLnRvU3RyaW5nKCkgfTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbVtDb21tb24uc3ltYm9scy5saXRlcmFsXSkge1xuICAgICAgICByZXR1cm4geyBmdW5jdGlvbjogaXRlbS5saXRlcmFsIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVtLmRlc2NyaWJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZicpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRlc2NyaWJlKCkucmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0uZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW1ba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZFtrZXldID0gaW50ZXJuYWxzLmRlc2NyaWJlKHZhbHVlLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKGpvaSwgZGVzYykge1xuXG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBpbnRlcm5hbHMuQnVpbGRlcihqb2kpO1xuICAgIHJldHVybiBidWlsZGVyLnBhcnNlKGRlc2MpO1xufTtcblxuXG5pbnRlcm5hbHMuQnVpbGRlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGpvaSkge1xuXG4gICAgICAgIHRoaXMuam9pID0gam9pO1xuICAgIH1cblxuICAgIHBhcnNlKGRlc2MpIHtcblxuICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGUodGhpcy5qb2ksIGRlc2MpO1xuXG4gICAgICAgIC8vIFR5cGVcblxuICAgICAgICBsZXQgc2NoZW1hID0gdGhpcy5qb2lbZGVzYy50eXBlXSgpLl9iYXJlKCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcblxuICAgICAgICAvLyBGbGFnc1xuXG4gICAgICAgIGlmIChkZXNjLmZsYWdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZsYWcgaW4gZGVzYy5mbGFncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRlciA9IGRlZi5mbGFnc1tmbGFnXSAmJiBkZWYuZmxhZ3NbZmxhZ10uc2V0dGVyIHx8IGZsYWc7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBzY2hlbWFbc2V0dGVyXSA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgZmxhZycsIGZsYWcsICdmb3IgdHlwZScsIGRlc2MudHlwZSk7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hW3NldHRlcl0odGhpcy5idWlsZChkZXNjLmZsYWdzW2ZsYWddKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVmZXJlbmNlc1xuXG4gICAgICAgIGlmIChkZXNjLnByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEucHJlZmVyZW5jZXModGhpcy5idWlsZChkZXNjLnByZWZlcmVuY2VzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyAvIEludmFsaWRcblxuICAgICAgICBpZiAoZGVzYy5hbGxvdykge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLmFsbG93KC4uLnRoaXMuYnVpbGQoZGVzYy5hbGxvdykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuaW52YWxpZCkge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLmludmFsaWQoLi4udGhpcy5idWlsZChkZXNjLmludmFsaWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1bGVzXG5cbiAgICAgICAgaWYgKGRlc2MucnVsZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBkZXNjLnJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBzY2hlbWFbcnVsZS5uYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgcnVsZScsIHJ1bGUubmFtZSwgJ2ZvciB0eXBlJywgZGVzYy50eXBlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1aWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbHRba2V5XSA9IHRoaXMuYnVpbGQocnVsZS5hcmdzW2tleV0sIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYnVpbHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGVmLnJ1bGVzW3J1bGUubmFtZV0uYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXlzLmxlbmd0aCA8PSBkZWZpbml0aW9uLmxlbmd0aCwgJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3InLCBkZXNjLnR5cGUsIHJ1bGUubmFtZSwgJyhleHBlY3RlZCB1cCB0bycsIGRlZmluaXRpb24ubGVuZ3RoLCAnLCBmb3VuZCcsIGtleXMubGVuZ3RoLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IG5hbWUgfSBvZiBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWx0W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXlzLmxlbmd0aCA9PT0gMSwgJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3InLCBkZXNjLnR5cGUsIHJ1bGUubmFtZSwgJyhleHBlY3RlZCB1cCB0byAxLCBmb3VuZCcsIGtleXMubGVuZ3RoLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWx0W2tleXNbMF1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWFbcnVsZS5uYW1lXSguLi5hcmdzKTtcblxuICAgICAgICAgICAgICAgIC8vIFJ1bGVzZXRcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlW2N1c3RvbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tjdXN0b21dID0gdGhpcy5idWlsZChydWxlW2N1c3RvbV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEucnVsZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXJtc1xuXG4gICAgICAgIGNvbnN0IHRlcm1zID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgIGlmIChbJ2FsbG93JywgJ2ZsYWdzJywgJ2ludmFsaWQnLCAnd2hlbnMnLCAncHJlZmVyZW5jZXMnLCAncnVsZXMnLCAndHlwZSddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KGRlZi50ZXJtc1trZXldLCAnVGVybScsIGtleSwgJ21pc3NpbmcgY29uZmlndXJhdGlvbicpO1xuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBkZWYudGVybXNba2V5XS5tYW5pZmVzdDtcblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2NoZW1hJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSBkZXNjW2tleV0ubWFwKChpdGVtKSA9PiB0aGlzLnBhcnNlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAndmFsdWVzJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSBkZXNjW2tleV0ubWFwKChpdGVtKSA9PiB0aGlzLmJ1aWxkKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFuaWZlc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZXNjW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZXNjW2tleV1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHRlcm1zW2tleV1bbmFtZV0gPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVybXNba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLndoZW5zKSB7XG4gICAgICAgICAgICB0ZXJtcy53aGVucyA9IGRlc2Mud2hlbnMubWFwKCh3aGVuKSA9PiB0aGlzLmJ1aWxkKHdoZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYSA9IGRlZi5tYW5pZmVzdC5idWlsZChzY2hlbWEsIHRlcm1zKTtcbiAgICAgICAgc2NoZW1hLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgYnVpbGQoZGVzYywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKGRlc2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVzYykpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjLm1hcCgoaXRlbSkgPT4gdGhpcy5idWlsZChpdGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWdleCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVnZXgoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWYnKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmLmJ1aWxkKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXNjICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVzYykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoZGVzYy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoQnVmZmVyLCAnQnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIgJiYgQnVmZmVyLmZyb20oZGVzYy5idWZmZXIsICdiaW5hcnknKTsgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5mdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IFtDb21tb24uc3ltYm9scy5saXRlcmFsXTogdHJ1ZSwgbGl0ZXJhbDogZGVzYy5mdW5jdGlvbiB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uc3ltYm9scy5vdmVycmlkZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZi5idWlsZChkZXNjLnJlZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5yZWdleChkZXNjLnJlZ2V4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2Muc3BlY2lhbCkge1xuICAgICAgICAgICAgICAgIEFzc2VydChbJ2RlZXAnXS5pbmNsdWRlcyhkZXNjLnNwZWNpYWwpLCAnVW5rbm93biBzcGVjaWFsIHZhbHVlJywgZGVzYy5zcGVjaWFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENsb25lKGRlc2MudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlLmJ1aWxkKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSwgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnJlZ2V4ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgY29uc3QgZW5kID0gc3RyaW5nLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgY29uc3QgZXhwID0gc3RyaW5nLnNsaWNlKDEsIGVuZCk7XG4gICAgY29uc3QgZmxhZ3MgPSBzdHJpbmcuc2xpY2UoZW5kICsgMSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZXhwLCBmbGFncyk7XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChqb2ksIGRlc2MpIHtcblxuICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgam9pLmFzc2VydChkZXNjLCBTY2hlbWFzLmRlc2NyaXB0aW9uKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/manifest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/messages.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/messages.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\n\nconst Template = __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\n\n\nconst internals = {};\n\n\nexports.compile = function (messages, target) {\n\n    // Single value string ('plain error message', 'template {error} message')\n\n    if (typeof messages === 'string') {\n        Assert(!target, 'Cannot set single message string');\n        return new Template(messages);\n    }\n\n    // Single value template\n\n    if (Template.isTemplate(messages)) {\n        Assert(!target, 'Cannot set single message template');\n        return messages;\n    }\n\n    // By error code { 'number.min': <string | template> }\n\n    Assert(typeof messages === 'object' && !Array.isArray(messages), 'Invalid message options');\n\n    target = target ? Clone(target) : {};\n\n    for (let code in messages) {\n        const message = messages[code];\n\n        if (code === 'root' ||\n            Template.isTemplate(message)) {\n\n            target[code] = message;\n            continue;\n        }\n\n        if (typeof message === 'string') {\n            target[code] = new Template(message);\n            continue;\n        }\n\n        // By language { english: { 'number.min': <string | template> } }\n\n        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);\n\n        const language = code;\n        target[language] = target[language] || {};\n\n        for (code in message) {\n            const localized = message[code];\n\n            if (code === 'root' ||\n                Template.isTemplate(localized)) {\n\n                target[language][code] = localized;\n                continue;\n            }\n\n            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);\n            target[language][code] = new Template(localized);\n        }\n    }\n\n    return target;\n};\n\n\nexports.decompile = function (messages) {\n\n    // By error code { 'number.min': <string | template> }\n\n    const target = {};\n    for (let code in messages) {\n        const message = messages[code];\n\n        if (code === 'root') {\n            target.root = message;\n            continue;\n        }\n\n        if (Template.isTemplate(message)) {\n            target[code] = message.describe({ compact: true });\n            continue;\n        }\n\n        // By language { english: { 'number.min': <string | template> } }\n\n        const language = code;\n        target[language] = {};\n\n        for (code in message) {\n            const localized = message[code];\n\n            if (code === 'root') {\n                target[language].root = localized;\n                continue;\n            }\n\n            target[language][code] = localized.describe({ compact: true });\n        }\n    }\n\n    return target;\n};\n\n\nexports.merge = function (base, extended) {\n\n    if (!base) {\n        return exports.compile(extended);\n    }\n\n    if (!extended) {\n        return base;\n    }\n\n    // Single value string\n\n    if (typeof extended === 'string') {\n        return new Template(extended);\n    }\n\n    // Single value template\n\n    if (Template.isTemplate(extended)) {\n        return extended;\n    }\n\n    // By error code { 'number.min': <string | template> }\n\n    const target = Clone(base);\n\n    for (let code in extended) {\n        const message = extended[code];\n\n        if (code === 'root' ||\n            Template.isTemplate(message)) {\n\n            target[code] = message;\n            continue;\n        }\n\n        if (typeof message === 'string') {\n            target[code] = new Template(message);\n            continue;\n        }\n\n        // By language { english: { 'number.min': <string | template> } }\n\n        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);\n\n        const language = code;\n        target[language] = target[language] || {};\n\n        for (code in message) {\n            const localized = message[code];\n\n            if (code === 'root' ||\n                Template.isTemplate(localized)) {\n\n                target[language][code] = localized;\n                continue;\n            }\n\n            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);\n            target[language][code] = new Template(localized);\n        }\n    }\n\n    return target;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tZXNzYWdlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsNEVBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQywwRUFBc0I7O0FBRTVDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZOzs7QUFHckM7OztBQUdBLGVBQWU7O0FBRWYsOERBQThELE9BQU87O0FBRXJFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsV0FBVzs7QUFFcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLGlCQUFpQjs7QUFFakIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBOztBQUVBLHlCQUF5QixXQUFXOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELGVBQWU7QUFDekU7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFdBQVc7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbWVzc2FnZXMuanM/Y2RlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIHRhcmdldCkge1xuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHN0cmluZyAoJ3BsYWluIGVycm9yIG1lc3NhZ2UnLCAndGVtcGxhdGUge2Vycm9yfSBtZXNzYWdlJylcblxuICAgIGlmICh0eXBlb2YgbWVzc2FnZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIEFzc2VydCghdGFyZ2V0LCAnQ2Fubm90IHNldCBzaW5nbGUgbWVzc2FnZSBzdHJpbmcnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShtZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHRlbXBsYXRlXG5cbiAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlcykpIHtcbiAgICAgICAgQXNzZXJ0KCF0YXJnZXQsICdDYW5ub3Qgc2V0IHNpbmdsZSBtZXNzYWdlIHRlbXBsYXRlJyk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSwgJ0ludmFsaWQgbWVzc2FnZSBvcHRpb25zJyk7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgPyBDbG9uZSh0YXJnZXQpIDoge307XG5cbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG5cbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG5ldyBUZW1wbGF0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2UpLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUpO1xuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHRhcmdldFtsYW5ndWFnZV0gfHwge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKGxvY2FsaXplZCkpIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBsb2NhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbG9jYWxpemVkID09PSAnc3RyaW5nJywgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlLCAnaW4nLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbmV3IFRlbXBsYXRlKGxvY2FsaXplZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLmRlY29tcGlsZSA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICB0YXJnZXQucm9vdCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlLmRlc2NyaWJlKHsgY29tcGFjdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV0ucm9vdCA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZC5kZXNjcmliZSh7IGNvbXBhY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKGJhc2UsIGV4dGVuZGVkKSB7XG5cbiAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29tcGlsZShleHRlbmRlZCk7XG4gICAgfVxuXG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgc3RyaW5nXG5cbiAgICBpZiAodHlwZW9mIGV4dGVuZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKGV4dGVuZGVkKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgdGVtcGxhdGVcblxuICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKGV4dGVuZGVkKSkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gICAgfVxuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBDbG9uZShiYXNlKTtcblxuICAgIGZvciAobGV0IGNvZGUgaW4gZXh0ZW5kZWQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV4dGVuZGVkW2NvZGVdO1xuXG4gICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcblxuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbmV3IFRlbXBsYXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobWVzc2FnZSksICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSk7XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0gdGFyZ2V0W2xhbmd1YWdlXSB8fCB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobG9jYWxpemVkKSkge1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBsb2NhbGl6ZWQgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUsICdpbicsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBuZXcgVGVtcGxhdGUobG9jYWxpemVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/modify.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/modify.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\n\n\nconst internals = {};\n\n\n\nexports.Ids = internals.Ids = class {\n\n    constructor() {\n\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n\n    clone() {\n\n        const clone = new internals.Ids();\n        clone._byId = new Map(this._byId);\n        clone._byKey = new Map(this._byKey);\n        clone._schemaChain = this._schemaChain;\n        return clone;\n    }\n\n    concat(source) {\n\n        if (source._schemaChain) {\n            this._schemaChain = true;\n        }\n\n        for (const [id, value] of source._byId.entries()) {\n            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n            this._byId.set(id, value);\n        }\n\n        for (const [key, value] of source._byKey.entries()) {\n            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n            this._byKey.set(key, value);\n        }\n    }\n\n    fork(path, adjuster, root) {\n\n        const chain = this._collect(path);\n        chain.push({ schema: root });\n        const tail = chain.shift();\n        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };\n\n        Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');\n\n        for (const node of chain) {\n            adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };\n        }\n\n        return adjusted.schema;\n    }\n\n    labels(path, behind = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        if (!node) {\n            return [...behind, ...path].join('.');\n        }\n\n        const forward = path.slice(1);\n        behind = [...behind, node.schema._flags.label || current];\n        if (!forward.length) {\n            return behind.join('.');\n        }\n\n        return node.schema._ids.labels(forward, behind);\n    }\n\n    reach(path, behind = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return node.schema;\n        }\n\n        return node.schema._ids.reach(forward, [...behind, current]);\n    }\n\n    register(schema, { key } = {}) {\n\n        if (!schema ||\n            !Common.isSchema(schema)) {\n\n            return;\n        }\n\n        if (schema.$_property('schemaChain') ||\n            schema._ids._schemaChain) {\n\n            this._schemaChain = true;\n        }\n\n        const id = schema._flags.id;\n        if (id) {\n            const existing = this._byId.get(id);\n            Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);\n            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n\n            this._byId.set(id, { schema, id });\n        }\n\n        if (key) {\n            Assert(!this._byKey.has(key), 'Schema already contains key:', key);\n            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n\n            this._byKey.set(key, { schema, id: key });\n        }\n    }\n\n    reset() {\n\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n\n    _collect(path, behind = [], nodes = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n\n        nodes = [node, ...nodes];\n\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return nodes;\n        }\n\n        return node.schema._ids._collect(forward, [...behind, current], nodes);\n    }\n\n    _get(id) {\n\n        return this._byId.get(id) || this._byKey.get(id);\n    }\n};\n\n\ninternals.fork = function (schema, id, replacement) {\n\n    const each = (item, { key }) => {\n\n        if (id === (item._flags.id || key)) {\n            return replacement;\n        }\n    };\n\n    const obj = exports.schema(schema, { each, ref: false });\n    return obj ? obj.$_mutateRebuild() : schema;\n};\n\n\nexports.schema = function (schema, options) {\n\n    let obj;\n\n    for (const name in schema._flags) {\n        if (name[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(schema._flags[name], { source: 'flags', name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj._flags[name] = result;\n        }\n    }\n\n    for (let i = 0; i < schema._rules.length; ++i) {\n        const rule = schema._rules[i];\n        const result = internals.scan(rule.args, { source: 'rules', name: rule.name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            const clone = Object.assign({}, rule);\n            clone.args = result;\n            obj._rules[i] = clone;\n\n            const existingUnique = obj._singleRules.get(rule.name);\n            if (existingUnique === rule) {\n                obj._singleRules.set(rule.name, clone);\n            }\n        }\n    }\n\n    for (const name in schema.$_terms) {\n        if (name[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(schema.$_terms[name], { source: 'terms', name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj.$_terms[name] = result;\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.scan = function (item, source, options, _path, _key) {\n\n    const path = _path || [];\n\n    if (item === null ||\n        typeof item !== 'object') {\n\n        return;\n    }\n\n    let clone;\n\n    if (Array.isArray(item)) {\n        for (let i = 0; i < item.length; ++i) {\n            const key = source.source === 'terms' && source.name === 'keys' && item[i].key;\n            const result = internals.scan(item[i], source, options, [i, ...path], key);\n            if (result !== undefined) {\n                clone = clone || item.slice();\n                clone[i] = result;\n            }\n        }\n\n        return clone;\n    }\n\n    if (options.schema !== false && Common.isSchema(item) ||\n        options.ref !== false && Ref.isRef(item)) {\n\n        const result = options.each(item, { ...source, path, key: _key });\n        if (result === item) {\n            return;\n        }\n\n        return result;\n    }\n\n    for (const key in item) {\n        if (key[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(item[key], source, options, [key, ...path], _key);\n        if (result !== undefined) {\n            clone = clone || Object.assign({}, item);\n            clone[key] = result;\n        }\n    }\n\n    return clone;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tb2RpZnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1Qjs7QUFFOUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxrREFBTzs7O0FBRzNCOzs7O0FBSUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsTUFBTSxJQUFJOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFlBQVk7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLDBCQUEwQixLQUFLOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7OztBQUdBLGNBQWM7O0FBRWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZELHVCQUF1QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQSxtREFBbUQsa0NBQWtDO0FBQ3JGO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELHVCQUF1QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0Qyw0QkFBNEI7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL21vZGlmeS5qcz8wNmRhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cblxuZXhwb3J0cy5JZHMgPSBpbnRlcm5hbHMuSWRzID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5fYnlJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYnlLZXkgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgaW50ZXJuYWxzLklkcygpO1xuICAgICAgICBjbG9uZS5fYnlJZCA9IG5ldyBNYXAodGhpcy5fYnlJZCk7XG4gICAgICAgIGNsb25lLl9ieUtleSA9IG5ldyBNYXAodGhpcy5fYnlLZXkpO1xuICAgICAgICBjbG9uZS5fc2NoZW1hQ2hhaW4gPSB0aGlzLl9zY2hlbWFDaGFpbjtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBpZiAoc291cmNlLl9zY2hlbWFDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHZhbHVlXSBvZiBzb3VyY2UuX2J5SWQuZW50cmllcygpKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhpZCksICdTY2hlbWEgaWQgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcga2V5OicsIGlkKTtcbiAgICAgICAgICAgIHRoaXMuX2J5SWQuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzb3VyY2UuX2J5S2V5LmVudHJpZXMoKSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUlkLmhhcyhrZXkpLCAnU2NoZW1hIGtleSBjb25mbGljdHMgd2l0aCBleGlzdGluZyBpZDonLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5fYnlLZXkuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yayhwYXRoLCBhZGp1c3Rlciwgcm9vdCkge1xuXG4gICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5fY29sbGVjdChwYXRoKTtcbiAgICAgICAgY2hhaW4ucHVzaCh7IHNjaGVtYTogcm9vdCB9KTtcbiAgICAgICAgY29uc3QgdGFpbCA9IGNoYWluLnNoaWZ0KCk7XG4gICAgICAgIGxldCBhZGp1c3RlZCA9IHsgaWQ6IHRhaWwuaWQsIHNjaGVtYTogYWRqdXN0ZXIodGFpbC5zY2hlbWEpIH07XG5cbiAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShhZGp1c3RlZC5zY2hlbWEpLCAnYWRqdXN0ZXIgZnVuY3Rpb24gZmFpbGVkIHRvIHJldHVybiBhIGpvaSBzY2hlbWEgdHlwZScpO1xuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjaGFpbikge1xuICAgICAgICAgICAgYWRqdXN0ZWQgPSB7IGlkOiBub2RlLmlkLCBzY2hlbWE6IGludGVybmFscy5mb3JrKG5vZGUuc2NoZW1hLCBhZGp1c3RlZC5pZCwgYWRqdXN0ZWQuc2NoZW1hKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFkanVzdGVkLnNjaGVtYTtcbiAgICB9XG5cbiAgICBsYWJlbHMocGF0aCwgYmVoaW5kID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGJlaGluZCA9IFsuLi5iZWhpbmQsIG5vZGUuc2NoZW1hLl9mbGFncy5sYWJlbCB8fCBjdXJyZW50XTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJlaGluZC5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5sYWJlbHMoZm9yd2FyZCwgYmVoaW5kKTtcbiAgICB9XG5cbiAgICByZWFjaChwYXRoLCBiZWhpbmQgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBBc3NlcnQobm9kZSwgJ1NjaGVtYSBkb2VzIG5vdCBjb250YWluIHBhdGgnLCBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJykpO1xuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5yZWFjaChmb3J3YXJkLCBbLi4uYmVoaW5kLCBjdXJyZW50XSk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXIoc2NoZW1hLCB7IGtleSB9ID0ge30pIHtcblxuICAgICAgICBpZiAoIXNjaGVtYSB8fFxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYShzY2hlbWEpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuJF9wcm9wZXJ0eSgnc2NoZW1hQ2hhaW4nKSB8fFxuICAgICAgICAgICAgc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkID0gc2NoZW1hLl9mbGFncy5pZDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuX2J5SWQuZ2V0KGlkKTtcbiAgICAgICAgICAgIEFzc2VydCghZXhpc3RpbmcgfHwgZXhpc3Rpbmcuc2NoZW1hID09PSBzY2hlbWEsICdDYW5ub3QgYWRkIGRpZmZlcmVudCBzY2hlbWFzIHdpdGggdGhlIHNhbWUgaWQ6JywgaWQpO1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoaWQpLCAnU2NoZW1hIGlkIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGtleTonLCBpZCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2J5SWQuc2V0KGlkLCB7IHNjaGVtYSwgaWQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhrZXkpLCAnU2NoZW1hIGFscmVhZHkgY29udGFpbnMga2V5OicsIGtleSk7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5SWQuaGFzKGtleSksICdTY2hlbWEga2V5IGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGlkOicsIGtleSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2J5S2V5LnNldChrZXksIHsgc2NoZW1hLCBpZDoga2V5IH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5fYnlJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYnlLZXkgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX2NvbGxlY3QocGF0aCwgYmVoaW5kID0gW10sIG5vZGVzID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgQXNzZXJ0KG5vZGUsICdTY2hlbWEgZG9lcyBub3QgY29udGFpbiBwYXRoJywgWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpKTtcblxuICAgICAgICBub2RlcyA9IFtub2RlLCAuLi5ub2Rlc107XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLl9jb2xsZWN0KGZvcndhcmQsIFsuLi5iZWhpbmQsIGN1cnJlbnRdLCBub2Rlcyk7XG4gICAgfVxuXG4gICAgX2dldChpZCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9ieUlkLmdldChpZCkgfHwgdGhpcy5fYnlLZXkuZ2V0KGlkKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mb3JrID0gZnVuY3Rpb24gKHNjaGVtYSwgaWQsIHJlcGxhY2VtZW50KSB7XG5cbiAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHsga2V5IH0pID0+IHtcblxuICAgICAgICBpZiAoaWQgPT09IChpdGVtLl9mbGFncy5pZCB8fCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb2JqID0gZXhwb3J0cy5zY2hlbWEoc2NoZW1hLCB7IGVhY2gsIHJlZjogZmFsc2UgfSk7XG4gICAgcmV0dXJuIG9iaiA/IG9iai4kX211dGF0ZVJlYnVpbGQoKSA6IHNjaGVtYTtcbn07XG5cblxuZXhwb3J0cy5zY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICBsZXQgb2JqO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNjaGVtYS5fZmxhZ3MpIHtcbiAgICAgICAgaWYgKG5hbWVbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihzY2hlbWEuX2ZsYWdzW25hbWVdLCB7IHNvdXJjZTogJ2ZsYWdzJywgbmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBvYmouX2ZsYWdzW25hbWVdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuX3J1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuX3J1bGVzW2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihydWxlLmFyZ3MsIHsgc291cmNlOiAncnVsZXMnLCBuYW1lOiBydWxlLm5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBydWxlKTtcbiAgICAgICAgICAgIGNsb25lLmFyZ3MgPSByZXN1bHQ7XG4gICAgICAgICAgICBvYmouX3J1bGVzW2ldID0gY2xvbmU7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVW5pcXVlID0gb2JqLl9zaW5nbGVSdWxlcy5nZXQocnVsZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1VuaXF1ZSA9PT0gcnVsZSkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgY2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNjaGVtYS4kX3Rlcm1zKSB7XG4gICAgICAgIGlmIChuYW1lWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oc2NoZW1hLiRfdGVybXNbbmFtZV0sIHsgc291cmNlOiAndGVybXMnLCBuYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW25hbWVdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLnNjYW4gPSBmdW5jdGlvbiAoaXRlbSwgc291cmNlLCBvcHRpb25zLCBfcGF0aCwgX2tleSkge1xuXG4gICAgY29uc3QgcGF0aCA9IF9wYXRoIHx8IFtdO1xuXG4gICAgaWYgKGl0ZW0gPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjbG9uZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gc291cmNlLnNvdXJjZSA9PT0gJ3Rlcm1zJyAmJiBzb3VyY2UubmFtZSA9PT0gJ2tleXMnICYmIGl0ZW1baV0ua2V5O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oaXRlbVtpXSwgc291cmNlLCBvcHRpb25zLCBbaSwgLi4ucGF0aF0sIGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IGNsb25lIHx8IGl0ZW0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjbG9uZVtpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zY2hlbWEgIT09IGZhbHNlICYmIENvbW1vbi5pc1NjaGVtYShpdGVtKSB8fFxuICAgICAgICBvcHRpb25zLnJlZiAhPT0gZmFsc2UgJiYgUmVmLmlzUmVmKGl0ZW0pKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9ucy5lYWNoKGl0ZW0sIHsgLi4uc291cmNlLCBwYXRoLCBrZXk6IF9rZXkgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgICAgICBpZiAoa2V5WzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oaXRlbVtrZXldLCBzb3VyY2UsIG9wdGlvbnMsIFtrZXksIC4uLnBhdGhdLCBfa2V5KTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbG9uZSA9IGNsb25lIHx8IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pO1xuICAgICAgICAgICAgY2xvbmVba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/modify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/ref.js":
/*!*************************************!*\
  !*** ./node_modules/joi/lib/ref.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"(rsc)/./node_modules/@hapi/hoek/lib/reach.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\n\nlet Template;\n\n\nconst internals = {\n    symbol: Symbol('ref'),      // Used to internally identify references (shared with other joi versions)\n    defaults: {\n        adjust: null,\n        in: false,\n        iterables: null,\n        map: null,\n        separator: '.',\n        type: 'value'\n    }\n};\n\n\nexports.create = function (key, options = {}) {\n\n    Assert(typeof key === 'string', 'Invalid reference key:', key);\n    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'render', 'separator']);\n    Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');\n\n    const ref = Object.assign({}, internals.defaults, options);\n    delete ref.prefix;\n\n    const separator = ref.separator;\n    const context = internals.context(key, separator, options.prefix);\n    ref.type = context.type;\n    key = context.key;\n\n    if (ref.type === 'value') {\n        if (context.root) {\n            Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');\n            ref.ancestor = 'root';\n            if (!key) {\n                key = null;\n            }\n        }\n\n        if (separator &&\n            separator === key) {\n\n            key = null;\n            ref.ancestor = 0;\n        }\n        else {\n            if (ref.ancestor !== undefined) {\n                Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');\n            }\n            else {\n                const [ancestor, slice] = internals.ancestor(key, separator);\n                if (slice) {\n                    key = key.slice(slice);\n                    if (key === '') {\n                        key = null;\n                    }\n                }\n\n                ref.ancestor = ancestor;\n            }\n        }\n    }\n\n    ref.path = separator ? (key === null ? [] : key.split(separator)) : [key];\n\n    return new internals.Ref(ref);\n};\n\n\nexports[\"in\"] = function (key, options = {}) {\n\n    return exports.create(key, { ...options, in: true });\n};\n\n\nexports.isRef = function (ref) {\n\n    return ref ? !!ref[Common.symbols.ref] : false;\n};\n\n\ninternals.Ref = class {\n\n    constructor(options) {\n\n        Assert(typeof options === 'object', 'Invalid reference construction');\n        Common.assertOptions(options, [\n            'adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'render', 'separator', 'type',  // Copied\n            'depth', 'key', 'root', 'display'                                                       // Overridden\n        ]);\n\n        Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');\n        Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');\n        Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');\n        Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');\n\n        Object.assign(this, internals.defaults, options);\n\n        Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');\n\n        if (Array.isArray(this.map)) {\n            this.map = new Map(this.map);\n        }\n\n        this.depth = this.path.length;\n        this.key = this.path.length ? this.path.join(this.separator) : null;\n        this.root = this.path[0];\n\n        this.updateDisplay();\n    }\n\n    resolve(value, state, prefs, local, options = {}) {\n\n        Assert(!this.in || options.in, 'Invalid in() reference usage');\n\n        if (this.type === 'global') {\n            return this._resolve(prefs.context, state, options);\n        }\n\n        if (this.type === 'local') {\n            return this._resolve(local, state, options);\n        }\n\n        if (!this.ancestor) {\n            return this._resolve(value, state, options);\n        }\n\n        if (this.ancestor === 'root') {\n            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);\n        }\n\n        Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);\n        return this._resolve(state.ancestors[this.ancestor - 1], state, options);\n    }\n\n    _resolve(target, state, options) {\n\n        let resolved;\n\n        if (this.type === 'value' &&\n            state.mainstay.shadow &&\n            options.shadow !== false) {\n\n            resolved = state.mainstay.shadow.get(this.absolute(state));\n        }\n\n        if (resolved === undefined) {\n            resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });\n        }\n\n        if (this.adjust) {\n            resolved = this.adjust(resolved);\n        }\n\n        if (this.map) {\n            const mapped = this.map.get(resolved);\n            if (mapped !== undefined) {\n                resolved = mapped;\n            }\n        }\n\n        if (state.mainstay) {\n            state.mainstay.tracer.resolve(state, this, resolved);\n        }\n\n        return resolved;\n    }\n\n    toString() {\n\n        return this.display;\n    }\n\n    absolute(state) {\n\n        return [...state.path.slice(0, -this.ancestor), ...this.path];\n    }\n\n    clone() {\n\n        return new internals.Ref(this);\n    }\n\n    describe() {\n\n        const ref = { path: this.path };\n\n        if (this.type !== 'value') {\n            ref.type = this.type;\n        }\n\n        if (this.separator !== '.') {\n            ref.separator = this.separator;\n        }\n\n        if (this.type === 'value' &&\n            this.ancestor !== 1) {\n\n            ref.ancestor = this.ancestor;\n        }\n\n        if (this.map) {\n            ref.map = [...this.map];\n        }\n\n        for (const key of ['adjust', 'iterables', 'render']) {\n            if (this[key] !== null &&\n                this[key] !== undefined) {\n\n                ref[key] = this[key];\n            }\n        }\n\n        if (this.in !== false) {\n            ref.in = true;\n        }\n\n        return { ref };\n    }\n\n    updateDisplay() {\n\n        const key = this.key !== null ? this.key : '';\n        if (this.type !== 'value') {\n            this.display = `ref:${this.type}:${key}`;\n            return;\n        }\n\n        if (!this.separator) {\n            this.display = `ref:${key}`;\n            return;\n        }\n\n        if (!this.ancestor) {\n            this.display = `ref:${this.separator}${key}`;\n            return;\n        }\n\n        if (this.ancestor === 'root') {\n            this.display = `ref:root:${key}`;\n            return;\n        }\n\n        if (this.ancestor === 1) {\n            this.display = `ref:${key || '..'}`;\n            return;\n        }\n\n        const lead = new Array(this.ancestor + 1).fill(this.separator).join('');\n        this.display = `ref:${lead}${key || ''}`;\n    }\n};\n\n\ninternals.Ref.prototype[Common.symbols.ref] = true;\n\n\nexports.build = function (desc) {\n\n    desc = Object.assign({}, internals.defaults, desc);\n    if (desc.type === 'value' &&\n        desc.ancestor === undefined) {\n\n        desc.ancestor = 1;\n    }\n\n    return new internals.Ref(desc);\n};\n\n\ninternals.context = function (key, separator, prefix = {}) {\n\n    key = key.trim();\n\n    if (prefix) {\n        const globalp = prefix.global === undefined ? '$' : prefix.global;\n        if (globalp !== separator &&\n            key.startsWith(globalp)) {\n\n            return { key: key.slice(globalp.length), type: 'global' };\n        }\n\n        const local = prefix.local === undefined ? '#' : prefix.local;\n        if (local !== separator &&\n            key.startsWith(local)) {\n\n            return { key: key.slice(local.length), type: 'local' };\n        }\n\n        const root = prefix.root === undefined ? '/' : prefix.root;\n        if (root !== separator &&\n            key.startsWith(root)) {\n\n            return { key: key.slice(root.length), type: 'value', root: true };\n        }\n    }\n\n    return { key, type: 'value' };\n};\n\n\ninternals.ancestor = function (key, separator) {\n\n    if (!separator) {\n        return [1, 0];              // 'a_b' -> 1 (parent)\n    }\n\n    if (key[0] !== separator) {     // 'a.b' -> 1 (parent)\n        return [1, 0];\n    }\n\n    if (key[1] !== separator) {     // '.a.b' -> 0 (self)\n        return [0, 1];\n    }\n\n    let i = 2;\n    while (key[i] === separator) {\n        ++i;\n    }\n\n    return [i - 1, i];              // '...a.b.' -> 2 (grandparent)\n};\n\n\nexports.toSibling = 0;\n\nexports.toParent = 1;\n\n\nexports.Manager = class {\n\n    constructor() {\n\n        this.refs = [];                     // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...\n    }\n\n    register(source, target) {\n\n        if (!source) {\n            return;\n        }\n\n        target = target === undefined ? exports.toParent : target;\n\n        // Array\n\n        if (Array.isArray(source)) {\n            for (const ref of source) {\n                this.register(ref, target);\n            }\n\n            return;\n        }\n\n        // Schema\n\n        if (Common.isSchema(source)) {\n            for (const item of source._refs.refs) {\n                if (item.ancestor - target >= 0) {\n                    this.refs.push({ ancestor: item.ancestor - target, root: item.root });\n                }\n            }\n\n            return;\n        }\n\n        // Reference\n\n        if (exports.isRef(source) &&\n            source.type === 'value' &&\n            source.ancestor - target >= 0) {\n\n            this.refs.push({ ancestor: source.ancestor - target, root: source.root });\n        }\n\n        // Template\n\n        Template = Template || __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\n\n        if (Template.isTemplate(source)) {\n            this.register(source.refs(), target);\n        }\n    }\n\n    get length() {\n\n        return this.refs.length;\n    }\n\n    clone() {\n\n        const copy = new exports.Manager();\n        copy.refs = Clone(this.refs);\n        return copy;\n    }\n\n    reset() {\n\n        this.refs = [];\n    }\n\n    roots() {\n\n        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9yZWYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1QjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsMEVBQXNCO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQywwRUFBc0I7O0FBRTVDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTs7QUFFakM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGNBQWMsOEJBQThCOztBQUU1QztBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0EsYUFBVSw4QkFBOEI7O0FBRXhDLGlDQUFpQyxzQkFBc0I7QUFDdkQ7OztBQUdBLGFBQWE7O0FBRWI7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0RBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELDRDQUE0QztBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVUsR0FBRyxJQUFJO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLGVBQWUsRUFBRSxJQUFJO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixLQUFLLEVBQUUsVUFBVTtBQUMvQztBQUNBOzs7QUFHQTs7O0FBR0EsYUFBYTs7QUFFYiwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLHlEQUF5RDs7QUFFekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBLGFBQWE7QUFDYjs7O0FBR0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDOzs7QUFHQSxpQkFBaUI7O0FBRWpCLGdCQUFnQjs7O0FBR2hCLGVBQWU7O0FBRWY7O0FBRUEsNENBQTRDO0FBQzVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtREFBbUQ7QUFDeEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsdURBQXVEO0FBQ3BGOztBQUVBOztBQUVBLCtCQUErQixtQkFBTyxDQUFDLDREQUFZOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvcmVmLmpzP2Q5MDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxubGV0IFRlbXBsYXRlO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzeW1ib2w6IFN5bWJvbCgncmVmJyksICAgICAgLy8gVXNlZCB0byBpbnRlcm5hbGx5IGlkZW50aWZ5IHJlZmVyZW5jZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBhZGp1c3Q6IG51bGwsXG4gICAgICAgIGluOiBmYWxzZSxcbiAgICAgICAgaXRlcmFibGVzOiBudWxsLFxuICAgICAgICBtYXA6IG51bGwsXG4gICAgICAgIHNlcGFyYXRvcjogJy4nLFxuICAgICAgICB0eXBlOiAndmFsdWUnXG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQXNzZXJ0KHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnLCAnSW52YWxpZCByZWZlcmVuY2Uga2V5OicsIGtleSk7XG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhZGp1c3QnLCAnYW5jZXN0b3InLCAnaW4nLCAnaXRlcmFibGVzJywgJ21hcCcsICdwcmVmaXgnLCAncmVuZGVyJywgJ3NlcGFyYXRvciddKTtcbiAgICBBc3NlcnQoIW9wdGlvbnMucHJlZml4IHx8IHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gJ29iamVjdCcsICdvcHRpb25zLnByZWZpeCBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG5cbiAgICBjb25zdCByZWYgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSByZWYucHJlZml4O1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gcmVmLnNlcGFyYXRvcjtcbiAgICBjb25zdCBjb250ZXh0ID0gaW50ZXJuYWxzLmNvbnRleHQoa2V5LCBzZXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICByZWYudHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICBrZXkgPSBjb250ZXh0LmtleTtcblxuICAgIGlmIChyZWYudHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBpZiAoY29udGV4dC5yb290KSB7XG4gICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCBrZXlbMF0gIT09IHNlcGFyYXRvciwgJ0Nhbm5vdCBzcGVjaWZ5IHJlbGF0aXZlIHBhdGggd2l0aCByb290IHByZWZpeCcpO1xuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gJ3Jvb3QnO1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcGFyYXRvciAmJlxuICAgICAgICAgICAgc2VwYXJhdG9yID09PSBrZXkpIHtcblxuICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVmLmFuY2VzdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCAha2V5IHx8IGtleVswXSAhPT0gc2VwYXJhdG9yLCAnQ2Fubm90IGNvbWJpbmUgcHJlZml4IHdpdGggYW5jZXN0b3Igb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYW5jZXN0b3IsIHNsaWNlXSA9IGludGVybmFscy5hbmNlc3RvcihrZXksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zbGljZShzbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gYW5jZXN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWYucGF0aCA9IHNlcGFyYXRvciA/IChrZXkgPT09IG51bGwgPyBbXSA6IGtleS5zcGxpdChzZXBhcmF0b3IpKSA6IFtrZXldO1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHJlZik7XG59O1xuXG5cbmV4cG9ydHMuaW4gPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShrZXksIHsgLi4ub3B0aW9ucywgaW46IHRydWUgfSk7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG5cbiAgICByZXR1cm4gcmVmID8gISFyZWZbQ29tbW9uLnN5bWJvbHMucmVmXSA6IGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuUmVmID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJlZmVyZW5jZSBjb25zdHJ1Y3Rpb24nKTtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgW1xuICAgICAgICAgICAgJ2FkanVzdCcsICdhbmNlc3RvcicsICdpbicsICdpdGVyYWJsZXMnLCAnbWFwJywgJ3BhdGgnLCAncmVuZGVyJywgJ3NlcGFyYXRvcicsICd0eXBlJywgIC8vIENvcGllZFxuICAgICAgICAgICAgJ2RlcHRoJywgJ2tleScsICdyb290JywgJ2Rpc3BsYXknICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRkZW5cbiAgICAgICAgXSk7XG5cbiAgICAgICAgQXNzZXJ0KFtmYWxzZSwgdW5kZWZpbmVkXS5pbmNsdWRlcyhvcHRpb25zLnNlcGFyYXRvcikgfHwgdHlwZW9mIG9wdGlvbnMuc2VwYXJhdG9yID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLnNlcGFyYXRvci5sZW5ndGggPT09IDEsICdJbnZhbGlkIHNlcGFyYXRvcicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYWRqdXN0IHx8IHR5cGVvZiBvcHRpb25zLmFkanVzdCA9PT0gJ2Z1bmN0aW9uJywgJ29wdGlvbnMuYWRqdXN0IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXApLCAnb3B0aW9ucy5tYXAgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8ICFvcHRpb25zLmFkanVzdCwgJ0Nhbm5vdCBzZXQgYm90aCBtYXAgYW5kIGFkanVzdCBvcHRpb25zJyk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIEFzc2VydCh0aGlzLnR5cGUgPT09ICd2YWx1ZScgfHwgdGhpcy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkLCAnTm9uLXZhbHVlIHJlZmVyZW5jZXMgY2Fubm90IHJlZmVyZW5jZSBhbmNlc3RvcnMnKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hcCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCh0aGlzLm1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnBhdGgubGVuZ3RoID8gdGhpcy5wYXRoLmpvaW4odGhpcy5zZXBhcmF0b3IpIDogbnVsbDtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wYXRoWzBdO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5pbiB8fCBvcHRpb25zLmluLCAnSW52YWxpZCBpbigpIHJlZmVyZW5jZSB1c2FnZScpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShwcmVmcy5jb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShsb2NhbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoc3RhdGUuYW5jZXN0b3JzW3N0YXRlLmFuY2VzdG9ycy5sZW5ndGggLSAxXSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMuYW5jZXN0b3IgPD0gc3RhdGUuYW5jZXN0b3JzLmxlbmd0aCwgJ0ludmFsaWQgcmVmZXJlbmNlIGV4Y2VlZHMgdGhlIHNjaGVtYSByb290OicsIHRoaXMuZGlzcGxheSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHN0YXRlLmFuY2VzdG9yc1t0aGlzLmFuY2VzdG9yIC0gMV0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfcmVzb2x2ZSh0YXJnZXQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHJlc29sdmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnNoYWRvdyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5zaGFkb3cgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHJlc29sdmVkID0gc3RhdGUubWFpbnN0YXkuc2hhZG93LmdldCh0aGlzLmFic29sdXRlKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBSZWFjaCh0YXJnZXQsIHRoaXMucGF0aCwgeyBpdGVyYWJsZXM6IHRoaXMuaXRlcmFibGVzLCBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hZGp1c3QpIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gdGhpcy5hZGp1c3QocmVzb2x2ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWQgPSB0aGlzLm1hcC5nZXQocmVzb2x2ZWQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBtYXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUubWFpbnN0YXkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5yZXNvbHZlKHN0YXRlLCB0aGlzLCByZXNvbHZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheTtcbiAgICB9XG5cbiAgICBhYnNvbHV0ZShzdGF0ZSkge1xuXG4gICAgICAgIHJldHVybiBbLi4uc3RhdGUucGF0aC5zbGljZSgwLCAtdGhpcy5hbmNlc3RvciksIC4uLnRoaXMucGF0aF07XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHRoaXMpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IHJlZiA9IHsgcGF0aDogdGhpcy5wYXRoIH07XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgcmVmLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgcmVmLnNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgdGhpcy5hbmNlc3RvciAhPT0gMSkge1xuXG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSB0aGlzLmFuY2VzdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICByZWYubWFwID0gWy4uLnRoaXMubWFwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnYWRqdXN0JywgJ2l0ZXJhYmxlcycsICdyZW5kZXInXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNba2V5XSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZWZba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVmLmluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlZiB9O1xuICAgIH1cblxuICAgIHVwZGF0ZURpc3BsYXkoKSB7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXkgIT09IG51bGwgPyB0aGlzLmtleSA6ICcnO1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy50eXBlfToke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy5zZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2VzdG9yID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6cm9vdDoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtrZXkgfHwgJy4uJ31gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVhZCA9IG5ldyBBcnJheSh0aGlzLmFuY2VzdG9yICsgMSkuZmlsbCh0aGlzLnNlcGFyYXRvcikuam9pbignJyk7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtsZWFkfSR7a2V5IHx8ICcnfWA7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVmLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5yZWZdID0gdHJ1ZTtcblxuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKGRlc2MpIHtcblxuICAgIGRlc2MgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIGRlc2MpO1xuICAgIGlmIChkZXNjLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgZGVzYy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgZGVzYy5hbmNlc3RvciA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKGRlc2MpO1xufTtcblxuXG5pbnRlcm5hbHMuY29udGV4dCA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvciwgcHJlZml4ID0ge30pIHtcblxuICAgIGtleSA9IGtleS50cmltKCk7XG5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbHAgPSBwcmVmaXguZ2xvYmFsID09PSB1bmRlZmluZWQgPyAnJCcgOiBwcmVmaXguZ2xvYmFsO1xuICAgICAgICBpZiAoZ2xvYmFscCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChnbG9iYWxwKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleS5zbGljZShnbG9iYWxwLmxlbmd0aCksIHR5cGU6ICdnbG9iYWwnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2NhbCA9IHByZWZpeC5sb2NhbCA9PT0gdW5kZWZpbmVkID8gJyMnIDogcHJlZml4LmxvY2FsO1xuICAgICAgICBpZiAobG9jYWwgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgobG9jYWwpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKGxvY2FsLmxlbmd0aCksIHR5cGU6ICdsb2NhbCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3QgPSBwcmVmaXgucm9vdCA9PT0gdW5kZWZpbmVkID8gJy8nIDogcHJlZml4LnJvb3Q7XG4gICAgICAgIGlmIChyb290ICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKHJvb3QpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKHJvb3QubGVuZ3RoKSwgdHlwZTogJ3ZhbHVlJywgcm9vdDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsga2V5LCB0eXBlOiAndmFsdWUnIH07XG59O1xuXG5cbmludGVybmFscy5hbmNlc3RvciA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvcikge1xuXG4gICAgaWYgKCFzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFsxLCAwXTsgICAgICAgICAgICAgIC8vICdhX2InIC0+IDEgKHBhcmVudClcbiAgICB9XG5cbiAgICBpZiAoa2V5WzBdICE9PSBzZXBhcmF0b3IpIHsgICAgIC8vICdhLmInIC0+IDEgKHBhcmVudClcbiAgICAgICAgcmV0dXJuIFsxLCAwXTtcbiAgICB9XG5cbiAgICBpZiAoa2V5WzFdICE9PSBzZXBhcmF0b3IpIHsgICAgIC8vICcuYS5iJyAtPiAwIChzZWxmKVxuICAgICAgICByZXR1cm4gWzAsIDFdO1xuICAgIH1cblxuICAgIGxldCBpID0gMjtcbiAgICB3aGlsZSAoa2V5W2ldID09PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgKytpO1xuICAgIH1cblxuICAgIHJldHVybiBbaSAtIDEsIGldOyAgICAgICAgICAgICAgLy8gJy4uLmEuYi4nIC0+IDIgKGdyYW5kcGFyZW50KVxufTtcblxuXG5leHBvcnRzLnRvU2libGluZyA9IDA7XG5cbmV4cG9ydHMudG9QYXJlbnQgPSAxO1xuXG5cbmV4cG9ydHMuTWFuYWdlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMucmVmcyA9IFtdOyAgICAgICAgICAgICAgICAgICAgIC8vIDA6IFtzZWxmIHJlZnNdLCAxOiBbcGFyZW50IHJlZnNdLCAyOiBbZ3JhbmRwYXJlbnQgcmVmc10sIC4uLlxuICAgIH1cblxuICAgIHJlZ2lzdGVyKHNvdXJjZSwgdGFyZ2V0KSB7XG5cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZXhwb3J0cy50b1BhcmVudCA6IHRhcmdldDtcblxuICAgICAgICAvLyBBcnJheVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIocmVmLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTY2hlbWFcblxuICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzb3VyY2UuX3JlZnMucmVmcykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmFuY2VzdG9yIC0gdGFyZ2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzLnB1c2goeyBhbmNlc3RvcjogaXRlbS5hbmNlc3RvciAtIHRhcmdldCwgcm9vdDogaXRlbS5yb290IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKGV4cG9ydHMuaXNSZWYoc291cmNlKSAmJlxuICAgICAgICAgICAgc291cmNlLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHNvdXJjZS5hbmNlc3RvciAtIHRhcmdldCA+PSAwKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVmcy5wdXNoKHsgYW5jZXN0b3I6IHNvdXJjZS5hbmNlc3RvciAtIHRhcmdldCwgcm9vdDogc291cmNlLnJvb3QgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wbGF0ZVxuXG4gICAgICAgIFRlbXBsYXRlID0gVGVtcGxhdGUgfHwgcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG4gICAgICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoc291cmNlLnJlZnMoKSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBleHBvcnRzLk1hbmFnZXIoKTtcbiAgICAgICAgY29weS5yZWZzID0gQ2xvbmUodGhpcy5yZWZzKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5yZWZzID0gW107XG4gICAgfVxuXG4gICAgcm9vdHMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5maWx0ZXIoKHJlZikgPT4gIXJlZi5hbmNlc3RvcikubWFwKChyZWYpID0+IHJlZi5yb290KTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/ref.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/schemas.js":
/*!*****************************************!*\
  !*** ./node_modules/joi/lib/schemas.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Joi = __webpack_require__(/*! ./index */ \"(rsc)/./node_modules/joi/lib/index.js\");\n\n\nconst internals = {};\n\n\n// Preferences\n\ninternals.wrap = Joi.string()\n    .min(1)\n    .max(2)\n    .allow(false);\n\n\nexports.preferences = Joi.object({\n    allowUnknown: Joi.boolean(),\n    abortEarly: Joi.boolean(),\n    artifacts: Joi.boolean(),\n    cache: Joi.boolean(),\n    context: Joi.object(),\n    convert: Joi.boolean(),\n    dateFormat: Joi.valid('date', 'iso', 'string', 'time', 'utc'),\n    debug: Joi.boolean(),\n    errors: {\n        escapeHtml: Joi.boolean(),\n        label: Joi.valid('path', 'key', false),\n        language: [\n            Joi.string(),\n            Joi.object().ref()\n        ],\n        render: Joi.boolean(),\n        stack: Joi.boolean(),\n        wrap: {\n            label: internals.wrap,\n            array: internals.wrap,\n            string: internals.wrap\n        }\n    },\n    externals: Joi.boolean(),\n    messages: Joi.object(),\n    noDefaults: Joi.boolean(),\n    nonEnumerables: Joi.boolean(),\n    presence: Joi.valid('required', 'optional', 'forbidden'),\n    skipFunctions: Joi.boolean(),\n    stripUnknown: Joi.object({\n        arrays: Joi.boolean(),\n        objects: Joi.boolean()\n    })\n        .or('arrays', 'objects')\n        .allow(true, false),\n    warnings: Joi.boolean()\n})\n    .strict();\n\n\n// Extensions\n\ninternals.nameRx = /^[a-zA-Z0-9]\\w*$/;\n\n\ninternals.rule = Joi.object({\n    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),\n    args: Joi.array().items(\n        Joi.string(),\n        Joi.object({\n            name: Joi.string().pattern(internals.nameRx).required(),\n            ref: Joi.boolean(),\n            assert: Joi.alternatives([\n                Joi.function(),\n                Joi.object().schema()\n            ])\n                .conditional('ref', { is: true, then: Joi.required() }),\n            normalize: Joi.function(),\n            message: Joi.string().when('assert', { is: Joi.function(), then: Joi.required() })\n        })\n    ),\n    convert: Joi.boolean(),\n    manifest: Joi.boolean(),\n    method: Joi.function().allow(false),\n    multi: Joi.boolean(),\n    validate: Joi.function()\n});\n\n\nexports.extension = Joi.object({\n    type: Joi.alternatives([\n        Joi.string(),\n        Joi.object().regex()\n    ])\n        .required(),\n    args: Joi.function(),\n    cast: Joi.object().pattern(internals.nameRx, Joi.object({\n        from: Joi.function().maxArity(1).required(),\n        to: Joi.function().minArity(1).maxArity(2).required()\n    })),\n    base: Joi.object().schema()\n        .when('type', { is: Joi.object().regex(), then: Joi.forbidden() }),\n    coerce: [\n        Joi.function().maxArity(3),\n        Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })\n    ],\n    flags: Joi.object().pattern(internals.nameRx, Joi.object({\n        setter: Joi.string(),\n        default: Joi.any()\n    })),\n    manifest: {\n        build: Joi.function().arity(2)\n    },\n    messages: [Joi.object(), Joi.string()],\n    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),\n    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),\n    prepare: Joi.function().maxArity(3),\n    rebuild: Joi.function().arity(1),\n    rules: Joi.object().pattern(internals.nameRx, internals.rule),\n    terms: Joi.object().pattern(internals.nameRx, Joi.object({\n        init: Joi.array().allow(null).required(),\n        manifest: Joi.object().pattern(/.+/, [\n            Joi.valid('schema', 'single'),\n            Joi.object({\n                mapped: Joi.object({\n                    from: Joi.string().required(),\n                    to: Joi.string().required()\n                })\n                    .required()\n            })\n        ])\n    })),\n    validate: Joi.function().maxArity(3)\n})\n    .strict();\n\n\nexports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();\n\n\n// Manifest\n\ninternals.desc = {\n\n    buffer: Joi.object({\n        buffer: Joi.string()\n    }),\n\n    func: Joi.object({\n        function: Joi.function().required(),\n        options: {\n            literal: true\n        }\n    }),\n\n    override: Joi.object({\n        override: true\n    }),\n\n    ref: Joi.object({\n        ref: Joi.object({\n            type: Joi.valid('value', 'global', 'local'),\n            path: Joi.array().required(),\n            separator: Joi.string().length(1).allow(false),\n            ancestor: Joi.number().min(0).integer().allow('root'),\n            map: Joi.array().items(Joi.array().length(2)).min(1),\n            adjust: Joi.function(),\n            iterables: Joi.boolean(),\n            in: Joi.boolean(),\n            render: Joi.boolean()\n        })\n            .required()\n    }),\n\n    regex: Joi.object({\n        regex: Joi.string().min(3)\n    }),\n\n    special: Joi.object({\n        special: Joi.valid('deep').required()\n    }),\n\n    template: Joi.object({\n        template: Joi.string().required(),\n        options: Joi.object()\n    }),\n\n    value: Joi.object({\n        value: Joi.alternatives([Joi.object(), Joi.array()]).required()\n    })\n};\n\n\ninternals.desc.entity = Joi.alternatives([\n    Joi.array().items(Joi.link('...')),\n    Joi.boolean(),\n    Joi.function(),\n    Joi.number(),\n    Joi.string(),\n    internals.desc.buffer,\n    internals.desc.func,\n    internals.desc.ref,\n    internals.desc.regex,\n    internals.desc.special,\n    internals.desc.template,\n    internals.desc.value,\n    Joi.link('/')\n]);\n\n\ninternals.desc.values = Joi.array()\n    .items(\n        null,\n        Joi.boolean(),\n        Joi.function(),\n        Joi.number().allow(Infinity, -Infinity),\n        Joi.string().allow(''),\n        Joi.symbol(),\n        internals.desc.buffer,\n        internals.desc.func,\n        internals.desc.override,\n        internals.desc.ref,\n        internals.desc.regex,\n        internals.desc.template,\n        internals.desc.value\n    );\n\n\ninternals.desc.messages = Joi.object()\n    .pattern(/.+/, [\n        Joi.string(),\n        internals.desc.template,\n        Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])\n    ]);\n\n\nexports.description = Joi.object({\n    type: Joi.string().required(),\n    flags: Joi.object({\n        cast: Joi.string(),\n        default: Joi.any(),\n        description: Joi.string(),\n        empty: Joi.link('/'),\n        failover: internals.desc.entity,\n        id: Joi.string(),\n        label: Joi.string(),\n        only: true,\n        presence: ['optional', 'required', 'forbidden'],\n        result: ['raw', 'strip'],\n        strip: Joi.boolean(),\n        unit: Joi.string()\n    })\n        .unknown(),\n    preferences: {\n        allowUnknown: Joi.boolean(),\n        abortEarly: Joi.boolean(),\n        artifacts: Joi.boolean(),\n        cache: Joi.boolean(),\n        convert: Joi.boolean(),\n        dateFormat: ['date', 'iso', 'string', 'time', 'utc'],\n        errors: {\n            escapeHtml: Joi.boolean(),\n            label: ['path', 'key'],\n            language: [\n                Joi.string(),\n                internals.desc.ref\n            ],\n            wrap: {\n                label: internals.wrap,\n                array: internals.wrap\n            }\n        },\n        externals: Joi.boolean(),\n        messages: internals.desc.messages,\n        noDefaults: Joi.boolean(),\n        nonEnumerables: Joi.boolean(),\n        presence: ['required', 'optional', 'forbidden'],\n        skipFunctions: Joi.boolean(),\n        stripUnknown: Joi.object({\n            arrays: Joi.boolean(),\n            objects: Joi.boolean()\n        })\n            .or('arrays', 'objects')\n            .allow(true, false),\n        warnings: Joi.boolean()\n    },\n    allow: internals.desc.values,\n    invalid: internals.desc.values,\n    rules: Joi.array().min(1).items({\n        name: Joi.string().required(),\n        args: Joi.object().min(1),\n        keep: Joi.boolean(),\n        message: [\n            Joi.string(),\n            internals.desc.messages\n        ],\n        warn: Joi.boolean()\n    }),\n\n    // Terms\n\n    keys: Joi.object().pattern(/.*/, Joi.link('/')),\n    link: internals.desc.ref\n})\n    .pattern(/^[a-z]\\w*$/, Joi.any());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zY2hlbWFzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxzREFBUzs7O0FBRzdCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBLG1EQUFtRCwwQ0FBMEM7QUFDN0YsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFO0FBQ0E7QUFDQSxxQkFBcUIsK0ZBQStGO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7O0FBR0Esa0JBQWtCOzs7QUFHbEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3NjaGVtYXMuanM/MzM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEpvaSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBQcmVmZXJlbmNlc1xuXG5pbnRlcm5hbHMud3JhcCA9IEpvaS5zdHJpbmcoKVxuICAgIC5taW4oMSlcbiAgICAubWF4KDIpXG4gICAgLmFsbG93KGZhbHNlKTtcblxuXG5leHBvcnRzLnByZWZlcmVuY2VzID0gSm9pLm9iamVjdCh7XG4gICAgYWxsb3dVbmtub3duOiBKb2kuYm9vbGVhbigpLFxuICAgIGFib3J0RWFybHk6IEpvaS5ib29sZWFuKCksXG4gICAgYXJ0aWZhY3RzOiBKb2kuYm9vbGVhbigpLFxuICAgIGNhY2hlOiBKb2kuYm9vbGVhbigpLFxuICAgIGNvbnRleHQ6IEpvaS5vYmplY3QoKSxcbiAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgIGRhdGVGb3JtYXQ6IEpvaS52YWxpZCgnZGF0ZScsICdpc28nLCAnc3RyaW5nJywgJ3RpbWUnLCAndXRjJyksXG4gICAgZGVidWc6IEpvaS5ib29sZWFuKCksXG4gICAgZXJyb3JzOiB7XG4gICAgICAgIGVzY2FwZUh0bWw6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGxhYmVsOiBKb2kudmFsaWQoJ3BhdGgnLCAna2V5JywgZmFsc2UpLFxuICAgICAgICBsYW5ndWFnZTogW1xuICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgSm9pLm9iamVjdCgpLnJlZigpXG4gICAgICAgIF0sXG4gICAgICAgIHJlbmRlcjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgc3RhY2s6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgIGxhYmVsOiBpbnRlcm5hbHMud3JhcCxcbiAgICAgICAgICAgIGFycmF5OiBpbnRlcm5hbHMud3JhcCxcbiAgICAgICAgICAgIHN0cmluZzogaW50ZXJuYWxzLndyYXBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZXJuYWxzOiBKb2kuYm9vbGVhbigpLFxuICAgIG1lc3NhZ2VzOiBKb2kub2JqZWN0KCksXG4gICAgbm9EZWZhdWx0czogSm9pLmJvb2xlYW4oKSxcbiAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICBwcmVzZW5jZTogSm9pLnZhbGlkKCdyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nKSxcbiAgICBza2lwRnVuY3Rpb25zOiBKb2kuYm9vbGVhbigpLFxuICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgIGFycmF5czogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgb2JqZWN0czogSm9pLmJvb2xlYW4oKVxuICAgIH0pXG4gICAgICAgIC5vcignYXJyYXlzJywgJ29iamVjdHMnKVxuICAgICAgICAuYWxsb3codHJ1ZSwgZmFsc2UpLFxuICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG4vLyBFeHRlbnNpb25zXG5cbmludGVybmFscy5uYW1lUnggPSAvXlthLXpBLVowLTldXFx3KiQvO1xuXG5cbmludGVybmFscy5ydWxlID0gSm9pLm9iamVjdCh7XG4gICAgYWxpYXM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngpKS5zaW5nbGUoKSxcbiAgICBhcmdzOiBKb2kuYXJyYXkoKS5pdGVtcyhcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IEpvaS5zdHJpbmcoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICByZWY6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBhc3NlcnQ6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICAgICAgICAgIEpvaS5mdW5jdGlvbigpLFxuICAgICAgICAgICAgICAgIEpvaS5vYmplY3QoKS5zY2hlbWEoKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAuY29uZGl0aW9uYWwoJ3JlZicsIHsgaXM6IHRydWUsIHRoZW46IEpvaS5yZXF1aXJlZCgpIH0pLFxuICAgICAgICAgICAgbm9ybWFsaXplOiBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpvaS5zdHJpbmcoKS53aGVuKCdhc3NlcnQnLCB7IGlzOiBKb2kuZnVuY3Rpb24oKSwgdGhlbjogSm9pLnJlcXVpcmVkKCkgfSlcbiAgICAgICAgfSlcbiAgICApLFxuICAgIGNvbnZlcnQ6IEpvaS5ib29sZWFuKCksXG4gICAgbWFuaWZlc3Q6IEpvaS5ib29sZWFuKCksXG4gICAgbWV0aG9kOiBKb2kuZnVuY3Rpb24oKS5hbGxvdyhmYWxzZSksXG4gICAgbXVsdGk6IEpvaS5ib29sZWFuKCksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpXG59KTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbiA9IEpvaS5vYmplY3Qoe1xuICAgIHR5cGU6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgIEpvaS5vYmplY3QoKS5yZWdleCgpXG4gICAgXSlcbiAgICAgICAgLnJlcXVpcmVkKCksXG4gICAgYXJnczogSm9pLmZ1bmN0aW9uKCksXG4gICAgY2FzdDogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIGZyb206IEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDEpLnJlcXVpcmVkKCksXG4gICAgICAgIHRvOiBKb2kuZnVuY3Rpb24oKS5taW5Bcml0eSgxKS5tYXhBcml0eSgyKS5yZXF1aXJlZCgpXG4gICAgfSkpLFxuICAgIGJhc2U6IEpvaS5vYmplY3QoKS5zY2hlbWEoKVxuICAgICAgICAud2hlbigndHlwZScsIHsgaXM6IEpvaS5vYmplY3QoKS5yZWdleCgpLCB0aGVuOiBKb2kuZm9yYmlkZGVuKCkgfSksXG4gICAgY29lcmNlOiBbXG4gICAgICAgIEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpLFxuICAgICAgICBKb2kub2JqZWN0KHsgbWV0aG9kOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKS5yZXF1aXJlZCgpLCBmcm9tOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpIH0pXG4gICAgXSxcbiAgICBmbGFnczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIHNldHRlcjogSm9pLnN0cmluZygpLFxuICAgICAgICBkZWZhdWx0OiBKb2kuYW55KClcbiAgICB9KSksXG4gICAgbWFuaWZlc3Q6IHtcbiAgICAgICAgYnVpbGQ6IEpvaS5mdW5jdGlvbigpLmFyaXR5KDIpXG4gICAgfSxcbiAgICBtZXNzYWdlczogW0pvaS5vYmplY3QoKSwgSm9pLnN0cmluZygpXSxcbiAgICBtb2RpZmllcnM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5mdW5jdGlvbigpLm1pbkFyaXR5KDEpLm1heEFyaXR5KDIpKSxcbiAgICBvdmVycmlkZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5mdW5jdGlvbigpKSxcbiAgICBwcmVwYXJlOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICByZWJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgxKSxcbiAgICBydWxlczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgaW50ZXJuYWxzLnJ1bGUpLFxuICAgIHRlcm1zOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kub2JqZWN0KHtcbiAgICAgICAgaW5pdDogSm9pLmFycmF5KCkuYWxsb3cobnVsbCkucmVxdWlyZWQoKSxcbiAgICAgICAgbWFuaWZlc3Q6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtcbiAgICAgICAgICAgIEpvaS52YWxpZCgnc2NoZW1hJywgJ3NpbmdsZScpLFxuICAgICAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFwcGVkOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICAgICAgICAgIHRvOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5yZXF1aXJlZCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgIH0pKSxcbiAgICB2YWxpZGF0ZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMylcbn0pXG4gICAgLnN0cmljdCgpO1xuXG5cbmV4cG9ydHMuZXh0ZW5zaW9ucyA9IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5vYmplY3QoKSwgSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSkpLnN0cmljdCgpO1xuXG5cbi8vIE1hbmlmZXN0XG5cbmludGVybmFscy5kZXNjID0ge1xuXG4gICAgYnVmZmVyOiBKb2kub2JqZWN0KHtcbiAgICAgICAgYnVmZmVyOiBKb2kuc3RyaW5nKClcbiAgICB9KSxcblxuICAgIGZ1bmM6IEpvaS5vYmplY3Qoe1xuICAgICAgICBmdW5jdGlvbjogSm9pLmZ1bmN0aW9uKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbGl0ZXJhbDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSksXG5cbiAgICBvdmVycmlkZTogSm9pLm9iamVjdCh7XG4gICAgICAgIG92ZXJyaWRlOiB0cnVlXG4gICAgfSksXG5cbiAgICByZWY6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWY6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogSm9pLnZhbGlkKCd2YWx1ZScsICdnbG9iYWwnLCAnbG9jYWwnKSxcbiAgICAgICAgICAgIHBhdGg6IEpvaS5hcnJheSgpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICBzZXBhcmF0b3I6IEpvaS5zdHJpbmcoKS5sZW5ndGgoMSkuYWxsb3coZmFsc2UpLFxuICAgICAgICAgICAgYW5jZXN0b3I6IEpvaS5udW1iZXIoKS5taW4oMCkuaW50ZWdlcigpLmFsbG93KCdyb290JyksXG4gICAgICAgICAgICBtYXA6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5hcnJheSgpLmxlbmd0aCgyKSkubWluKDEpLFxuICAgICAgICAgICAgYWRqdXN0OiBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgIGl0ZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIGluOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgcmVuZGVyOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgIH0pLFxuXG4gICAgcmVnZXg6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWdleDogSm9pLnN0cmluZygpLm1pbigzKVxuICAgIH0pLFxuXG4gICAgc3BlY2lhbDogSm9pLm9iamVjdCh7XG4gICAgICAgIHNwZWNpYWw6IEpvaS52YWxpZCgnZGVlcCcpLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHRlbXBsYXRlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgdGVtcGxhdGU6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICBvcHRpb25zOiBKb2kub2JqZWN0KClcbiAgICB9KSxcblxuICAgIHZhbHVlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgdmFsdWU6IEpvaS5hbHRlcm5hdGl2ZXMoW0pvaS5vYmplY3QoKSwgSm9pLmFycmF5KCldKS5yZXF1aXJlZCgpXG4gICAgfSlcbn07XG5cblxuaW50ZXJuYWxzLmRlc2MuZW50aXR5ID0gSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgSm9pLmFycmF5KCkuaXRlbXMoSm9pLmxpbmsoJy4uLicpKSxcbiAgICBKb2kuYm9vbGVhbigpLFxuICAgIEpvaS5mdW5jdGlvbigpLFxuICAgIEpvaS5udW1iZXIoKSxcbiAgICBKb2kuc3RyaW5nKCksXG4gICAgaW50ZXJuYWxzLmRlc2MuYnVmZmVyLFxuICAgIGludGVybmFscy5kZXNjLmZ1bmMsXG4gICAgaW50ZXJuYWxzLmRlc2MucmVmLFxuICAgIGludGVybmFscy5kZXNjLnJlZ2V4LFxuICAgIGludGVybmFscy5kZXNjLnNwZWNpYWwsXG4gICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgaW50ZXJuYWxzLmRlc2MudmFsdWUsXG4gICAgSm9pLmxpbmsoJy8nKVxuXSk7XG5cblxuaW50ZXJuYWxzLmRlc2MudmFsdWVzID0gSm9pLmFycmF5KClcbiAgICAuaXRlbXMoXG4gICAgICAgIG51bGwsXG4gICAgICAgIEpvaS5ib29sZWFuKCksXG4gICAgICAgIEpvaS5mdW5jdGlvbigpLFxuICAgICAgICBKb2kubnVtYmVyKCkuYWxsb3coSW5maW5pdHksIC1JbmZpbml0eSksXG4gICAgICAgIEpvaS5zdHJpbmcoKS5hbGxvdygnJyksXG4gICAgICAgIEpvaS5zeW1ib2woKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuYnVmZmVyLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5vdmVycmlkZSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVmLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnZhbHVlXG4gICAgKTtcblxuXG5pbnRlcm5hbHMuZGVzYy5tZXNzYWdlcyA9IEpvaS5vYmplY3QoKVxuICAgIC5wYXR0ZXJuKC8uKy8sIFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy50ZW1wbGF0ZSxcbiAgICAgICAgSm9pLm9iamVjdCgpLnBhdHRlcm4oLy4rLywgW0pvaS5zdHJpbmcoKSwgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGVdKVxuICAgIF0pO1xuXG5cbmV4cG9ydHMuZGVzY3JpcHRpb24gPSBKb2kub2JqZWN0KHtcbiAgICB0eXBlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICBmbGFnczogSm9pLm9iamVjdCh7XG4gICAgICAgIGNhc3Q6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogSm9pLnN0cmluZygpLFxuICAgICAgICBlbXB0eTogSm9pLmxpbmsoJy8nKSxcbiAgICAgICAgZmFpbG92ZXI6IGludGVybmFscy5kZXNjLmVudGl0eSxcbiAgICAgICAgaWQ6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgbGFiZWw6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgb25seTogdHJ1ZSxcbiAgICAgICAgcHJlc2VuY2U6IFsnb3B0aW9uYWwnLCAncmVxdWlyZWQnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHJlc3VsdDogWydyYXcnLCAnc3RyaXAnXSxcbiAgICAgICAgc3RyaXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHVuaXQ6IEpvaS5zdHJpbmcoKVxuICAgIH0pXG4gICAgICAgIC51bmtub3duKCksXG4gICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgYWxsb3dVbmtub3duOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBhcnRpZmFjdHM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGNhY2hlOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBkYXRlRm9ybWF0OiBbJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YyddLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIGVzY2FwZUh0bWw6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBsYWJlbDogWydwYXRoJywgJ2tleSddLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVmXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgd3JhcDoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBpbnRlcm5hbHMud3JhcCxcbiAgICAgICAgICAgICAgICBhcnJheTogaW50ZXJuYWxzLndyYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZXJuYWxzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBtZXNzYWdlczogaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMsXG4gICAgICAgIG5vRGVmYXVsdHM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG5vbkVudW1lcmFibGVzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBwcmVzZW5jZTogWydyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nXSxcbiAgICAgICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgc3RyaXBVbmtub3duOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIGFycmF5czogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIG9iamVjdHM6IEpvaS5ib29sZWFuKClcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vcignYXJyYXlzJywgJ29iamVjdHMnKVxuICAgICAgICAgICAgLmFsbG93KHRydWUsIGZhbHNlKSxcbiAgICAgICAgd2FybmluZ3M6IEpvaS5ib29sZWFuKClcbiAgICB9LFxuICAgIGFsbG93OiBpbnRlcm5hbHMuZGVzYy52YWx1ZXMsXG4gICAgaW52YWxpZDogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIHJ1bGVzOiBKb2kuYXJyYXkoKS5taW4oMSkuaXRlbXMoe1xuICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgYXJnczogSm9pLm9iamVjdCgpLm1pbigxKSxcbiAgICAgICAga2VlcDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZTogW1xuICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgaW50ZXJuYWxzLmRlc2MubWVzc2FnZXNcbiAgICAgICAgXSxcbiAgICAgICAgd2FybjogSm9pLmJvb2xlYW4oKVxuICAgIH0pLFxuXG4gICAgLy8gVGVybXNcblxuICAgIGtleXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKi8sIEpvaS5saW5rKCcvJykpLFxuICAgIGxpbms6IGludGVybmFscy5kZXNjLnJlZlxufSlcbiAgICAucGF0dGVybigvXlthLXpdXFx3KiQvLCBKb2kuYW55KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/state.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/state.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"(rsc)/./node_modules/@hapi/hoek/lib/reach.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    value: Symbol('value')\n};\n\n\nmodule.exports = internals.State = class {\n\n    constructor(path, ancestors, state) {\n\n        this.path = path;\n        this.ancestors = ancestors;                 // [parent, ..., root]\n\n        this.mainstay = state.mainstay;\n        this.schemas = state.schemas;               // [current, ..., root]\n        this.debug = null;\n    }\n\n    localize(path, ancestors = null, schema = null) {\n\n        const state = new internals.State(path, ancestors, this);\n\n        if (schema &&\n            state.schemas) {\n\n            state.schemas = [internals.schemas(schema), ...state.schemas];\n        }\n\n        return state;\n    }\n\n    nest(schema, debug) {\n\n        const state = new internals.State(this.path, this.ancestors, this);\n        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];\n        state.debug = debug;\n        return state;\n    }\n\n    shadow(value, reason) {\n\n        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();\n        this.mainstay.shadow.set(this.path, value, reason);\n    }\n\n    snapshot() {\n\n        if (this.mainstay.shadow) {\n            this._snapshot = Clone(this.mainstay.shadow.node(this.path));\n        }\n\n        this.mainstay.snapshot();\n    }\n\n    restore() {\n\n        if (this.mainstay.shadow) {\n            this.mainstay.shadow.override(this.path, this._snapshot);\n            this._snapshot = undefined;\n        }\n\n        this.mainstay.restore();\n    }\n\n    commit() {\n\n        if (this.mainstay.shadow) {\n            this.mainstay.shadow.override(this.path, this._snapshot);\n            this._snapshot = undefined;\n        }\n\n        this.mainstay.commit();\n    }\n};\n\n\ninternals.schemas = function (schema) {\n\n    if (Common.isSchema(schema)) {\n        return { schema };\n    }\n\n    return schema;\n};\n\n\ninternals.Shadow = class {\n\n    constructor() {\n\n        this._values = null;\n    }\n\n    set(path, value, reason) {\n\n        if (!path.length) {                                     // No need to store root value\n            return;\n        }\n\n        if (reason === 'strip' &&\n            typeof path[path.length - 1] === 'number') {        // Cannot store stripped array values (due to shift)\n\n            return;\n        }\n\n        this._values = this._values || new Map();\n\n        let node = this._values;\n        for (let i = 0; i < path.length; ++i) {\n            const segment = path[i];\n            let next = node.get(segment);\n            if (!next) {\n                next = new Map();\n                node.set(segment, next);\n            }\n\n            node = next;\n        }\n\n        node[internals.value] = value;\n    }\n\n    get(path) {\n\n        const node = this.node(path);\n        if (node) {\n            return node[internals.value];\n        }\n    }\n\n    node(path) {\n\n        if (!this._values) {\n            return;\n        }\n\n        return Reach(this._values, path, { iterables: true });\n    }\n\n    override(path, node) {\n\n        if (!this._values) {\n            return;\n        }\n\n        const parents = path.slice(0, -1);\n        const own = path[path.length - 1];\n        const parent = Reach(this._values, parents, { iterables: true });\n\n        if (node) {\n            parent.set(own, node);\n            return;\n        }\n\n        if (parent) {\n            parent.delete(own);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsMEVBQXNCO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQywwRUFBc0I7O0FBRTVDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTs7O0FBR2pDO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLGlCQUFpQjtBQUM1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MaXN0ZW4vLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zdGF0ZS5qcz8wMTMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB2YWx1ZTogU3ltYm9sKCd2YWx1ZScpXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlN0YXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocGF0aCwgYW5jZXN0b3JzLCBzdGF0ZSkge1xuXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuYW5jZXN0b3JzID0gYW5jZXN0b3JzOyAgICAgICAgICAgICAgICAgLy8gW3BhcmVudCwgLi4uLCByb290XVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkgPSBzdGF0ZS5tYWluc3RheTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gc3RhdGUuc2NoZW1hczsgICAgICAgICAgICAgICAvLyBbY3VycmVudCwgLi4uLCByb290XVxuICAgICAgICB0aGlzLmRlYnVnID0gbnVsbDtcbiAgICB9XG5cbiAgICBsb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMgPSBudWxsLCBzY2hlbWEgPSBudWxsKSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgaW50ZXJuYWxzLlN0YXRlKHBhdGgsIGFuY2VzdG9ycywgdGhpcyk7XG5cbiAgICAgICAgaWYgKHNjaGVtYSAmJlxuICAgICAgICAgICAgc3RhdGUuc2NoZW1hcykge1xuXG4gICAgICAgICAgICBzdGF0ZS5zY2hlbWFzID0gW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIG5lc3Qoc2NoZW1hLCBkZWJ1Zykge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IGludGVybmFscy5TdGF0ZSh0aGlzLnBhdGgsIHRoaXMuYW5jZXN0b3JzLCB0aGlzKTtcbiAgICAgICAgc3RhdGUuc2NoZW1hcyA9IHN0YXRlLnNjaGVtYXMgJiYgW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICBzdGF0ZS5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgc2hhZG93KHZhbHVlLCByZWFzb24pIHtcblxuICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdyA9IHRoaXMubWFpbnN0YXkuc2hhZG93IHx8IG5ldyBpbnRlcm5hbHMuU2hhZG93KCk7XG4gICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93LnNldCh0aGlzLnBhdGgsIHZhbHVlLCByZWFzb24pO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSBDbG9uZSh0aGlzLm1haW5zdGF5LnNoYWRvdy5ub2RlKHRoaXMucGF0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWluc3RheS5zbmFwc2hvdCgpO1xuICAgIH1cblxuICAgIHJlc3RvcmUoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWFpbnN0YXkuc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdy5vdmVycmlkZSh0aGlzLnBhdGgsIHRoaXMuX3NuYXBzaG90KTtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWluc3RheS5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgY29tbWl0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cub3ZlcnJpZGUodGhpcy5wYXRoLCB0aGlzLl9zbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkuY29tbWl0KCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hcyA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcblxuICAgIGlmIChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4geyBzY2hlbWEgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hO1xufTtcblxuXG5pbnRlcm5hbHMuU2hhZG93ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBzZXQocGF0aCwgdmFsdWUsIHJlYXNvbikge1xuXG4gICAgICAgIGlmICghcGF0aC5sZW5ndGgpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBzdG9yZSByb290IHZhbHVlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVhc29uID09PSAnc3RyaXAnICYmXG4gICAgICAgICAgICB0eXBlb2YgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnbnVtYmVyJykgeyAgICAgICAgLy8gQ2Fubm90IHN0b3JlIHN0cmlwcGVkIGFycmF5IHZhbHVlcyAoZHVlIHRvIHNoaWZ0KVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSB0aGlzLl92YWx1ZXMgfHwgbmV3IE1hcCgpO1xuXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fdmFsdWVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoW2ldO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLmdldChzZWdtZW50KTtcbiAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXQoc2VnbWVudCwgbmV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZVtpbnRlcm5hbHMudmFsdWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0KHBhdGgpIHtcblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlKHBhdGgpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxzLnZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUocGF0aCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVhY2godGhpcy5fdmFsdWVzLCBwYXRoLCB7IGl0ZXJhYmxlczogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBvdmVycmlkZShwYXRoLCBub2RlKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgY29uc3Qgb3duID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBSZWFjaCh0aGlzLl92YWx1ZXMsIHBhcmVudHMsIHsgaXRlcmFibGVzOiB0cnVlIH0pO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBwYXJlbnQuc2V0KG93biwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQuZGVsZXRlKG93bik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/template.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/template.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst EscapeHtml = __webpack_require__(/*! @hapi/hoek/lib/escapeHtml */ \"(rsc)/./node_modules/@hapi/hoek/lib/escapeHtml.js\");\nconst Formula = __webpack_require__(/*! @sideway/formula */ \"(rsc)/./node_modules/@sideway/formula/lib/index.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\n\n\nconst internals = {\n    symbol: Symbol('template'),\n\n    opens: new Array(1000).join('\\u0000'),\n    closes: new Array(1000).join('\\u0001'),\n\n    dateFormat: {\n        date: Date.prototype.toDateString,\n        iso: Date.prototype.toISOString,\n        string: Date.prototype.toString,\n        time: Date.prototype.toTimeString,\n        utc: Date.prototype.toUTCString\n    }\n};\n\n\nmodule.exports = exports = internals.Template = class {\n\n    constructor(source, options) {\n\n        Assert(typeof source === 'string', 'Template source must be a string');\n        Assert(!source.includes('\\u0000') && !source.includes('\\u0001'), 'Template source cannot contain reserved control characters');\n\n        this.source = source;\n        this.rendered = source;\n\n        this._template = null;\n\n        if (options) {\n            const { functions, ...opts } = options;\n            this._settings = Object.keys(opts).length ? Clone(opts) : undefined;\n            this._functions = functions;\n            if (this._functions) {\n                Assert(Object.keys(this._functions).every((key) => typeof key === 'string'), 'Functions keys must be strings');\n                Assert(Object.values(this._functions).every((key) => typeof key === 'function'), 'Functions values must be functions');\n            }\n        }\n        else {\n            this._settings = undefined;\n            this._functions = undefined;\n        }\n\n        this._parse();\n    }\n\n    _parse() {\n\n        // 'text {raw} {{ref}} \\\\{{ignore}} {{ignore\\\\}} {{ignore {{ignore}'\n\n        if (!this.source.includes('{')) {\n            return;\n        }\n\n        // Encode escaped \\\\{{{{{\n\n        const encoded = internals.encode(this.source);\n\n        // Split on first { in each set\n\n        const parts = internals.split(encoded);\n\n        // Process parts\n\n        let refs = false;\n        const processed = [];\n        const head = parts.shift();\n        if (head) {\n            processed.push(head);\n        }\n\n        for (const part of parts) {\n            const raw = part[0] !== '{';\n            const ender = raw ? '}' : '}}';\n            const end = part.indexOf(ender);\n            if (end === -1 ||                               // Ignore non-matching closing\n                part[1] === '{') {                          // Ignore more than two {\n\n                processed.push(`{${internals.decode(part)}`);\n                continue;\n            }\n\n            let variable = part.slice(raw ? 0 : 1, end);\n            const wrapped = variable[0] === ':';\n            if (wrapped) {\n                variable = variable.slice(1);\n            }\n\n            const dynamic = this._ref(internals.decode(variable), { raw, wrapped });\n            processed.push(dynamic);\n            if (typeof dynamic !== 'string') {\n                refs = true;\n            }\n\n            const rest = part.slice(end + ender.length);\n            if (rest) {\n                processed.push(internals.decode(rest));\n            }\n        }\n\n        if (!refs) {\n            this.rendered = processed.join('');\n            return;\n        }\n\n        this._template = processed;\n    }\n\n    static date(date, prefs) {\n\n        return internals.dateFormat[prefs.dateFormat].call(date);\n    }\n\n    describe(options = {}) {\n\n        if (!this._settings &&\n            options.compact) {\n\n            return this.source;\n        }\n\n        const desc = { template: this.source };\n        if (this._settings) {\n            desc.options = this._settings;\n        }\n\n        if (this._functions) {\n            desc.functions = this._functions;\n        }\n\n        return desc;\n    }\n\n    static build(desc) {\n\n        return new internals.Template(desc.template, desc.options || desc.functions ? { ...desc.options, functions: desc.functions } : undefined);\n    }\n\n    isDynamic() {\n\n        return !!this._template;\n    }\n\n    static isTemplate(template) {\n\n        return template ? !!template[Common.symbols.template] : false;\n    }\n\n    refs() {\n\n        if (!this._template) {\n            return;\n        }\n\n        const refs = [];\n        for (const part of this._template) {\n            if (typeof part !== 'string') {\n                refs.push(...part.refs);\n            }\n        }\n\n        return refs;\n    }\n\n    resolve(value, state, prefs, local) {\n\n        if (this._template &&\n            this._template.length === 1) {\n\n            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */);\n        }\n\n        return this.render(value, state, prefs, local);\n    }\n\n    _part(part, ...args) {\n\n        if (part.ref) {\n            return part.ref.resolve(...args);\n        }\n\n        return part.formula.evaluate(args);\n    }\n\n    render(value, state, prefs, local, options = {}) {\n\n        if (!this.isDynamic()) {\n            return this.rendered;\n        }\n\n        const parts = [];\n        for (const part of this._template) {\n            if (typeof part === 'string') {\n                parts.push(part);\n            }\n            else {\n                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */);\n                const string = internals.stringify(rendered, value, state, prefs, local, options);\n                if (string !== undefined) {\n                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);\n                    parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));\n                }\n            }\n        }\n\n        return parts.join('');\n    }\n\n    _ref(content, { raw, wrapped }) {\n\n        const refs = [];\n        const reference = (variable) => {\n\n            const ref = Ref.create(variable, this._settings);\n            refs.push(ref);\n            return (context) => {\n\n                const resolved = ref.resolve(...context);\n                return resolved !== undefined ? resolved : null;\n            };\n        };\n\n        try {\n            const functions = this._functions ? { ...internals.functions, ...this._functions } : internals.functions;\n            var formula = new Formula.Parser(content, { reference, functions, constants: internals.constants });\n        }\n        catch (err) {\n            err.message = `Invalid template variable \"${content}\" fails due to: ${err.message}`;\n            throw err;\n        }\n\n        if (formula.single) {\n            if (formula.single.type === 'reference') {\n                const ref = refs[0];\n                return { ref, raw, refs, wrapped: wrapped || ref.type === 'local' && ref.key === 'label' };\n            }\n\n            return internals.stringify(formula.single.value);\n        }\n\n        return { formula, raw, refs };\n    }\n\n    toString() {\n\n        return this.source;\n    }\n};\n\n\ninternals.Template.prototype[Common.symbols.template] = true;\ninternals.Template.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects\n\n\ninternals.encode = function (string) {\n\n    return string\n        .replace(/\\\\(\\{+)/g, ($0, $1) => {\n\n            return internals.opens.slice(0, $1.length);\n        })\n        .replace(/\\\\(\\}+)/g, ($0, $1) => {\n\n            return internals.closes.slice(0, $1.length);\n        });\n};\n\n\ninternals.decode = function (string) {\n\n    return string\n        .replace(/\\u0000/g, '{')\n        .replace(/\\u0001/g, '}');\n};\n\n\ninternals.split = function (string) {\n\n    const parts = [];\n    let current = '';\n\n    for (let i = 0; i < string.length; ++i) {\n        const char = string[i];\n\n        if (char === '{') {\n            let next = '';\n            while (i + 1 < string.length &&\n                string[i + 1] === '{') {\n\n                next += '{';\n                ++i;\n            }\n\n            parts.push(current);\n            current = next;\n        }\n        else {\n            current += char;\n        }\n    }\n\n    parts.push(current);\n    return parts;\n};\n\n\ninternals.wrap = function (value, ends) {\n\n    if (!ends) {\n        return value;\n    }\n\n    if (ends.length === 1) {\n        return `${ends}${value}${ends}`;\n    }\n\n    return `${ends[0]}${value}${ends[1]}`;\n};\n\n\ninternals.stringify = function (value, original, state, prefs, local, options = {}) {\n\n    const type = typeof value;\n    const wrap = prefs && prefs.errors && prefs.errors.wrap || {};\n\n    let skipWrap = false;\n    if (Ref.isRef(value) &&\n        value.render) {\n\n        skipWrap = value.in;\n        value = value.resolve(original, state, prefs, local, { in: value.in, ...options });\n    }\n\n    if (value === null) {\n        return 'null';\n    }\n\n    if (type === 'string') {\n        return internals.wrap(value, options.arrayItems && wrap.string);\n    }\n\n    if (type === 'number' ||\n        type === 'function' ||\n        type === 'symbol') {\n\n        return value.toString();\n    }\n\n    if (type !== 'object') {\n        return JSON.stringify(value);\n    }\n\n    if (value instanceof Date) {\n        return internals.Template.date(value, prefs);\n    }\n\n    if (value instanceof Map) {\n        const pairs = [];\n        for (const [key, sym] of value.entries()) {\n            pairs.push(`${key.toString()} -> ${sym.toString()}`);\n        }\n\n        value = pairs;\n    }\n\n    if (!Array.isArray(value)) {\n        return value.toString();\n    }\n\n    const values = [];\n    for (const item of value) {\n        values.push(internals.stringify(item, original, state, prefs, local, { arrayItems: true, ...options }));\n    }\n\n    return internals.wrap(values.join(', '), !skipWrap && wrap.array);\n};\n\n\ninternals.constants = {\n\n    true: true,\n    false: false,\n    null: null,\n\n    second: 1000,\n    minute: 60 * 1000,\n    hour: 60 * 60 * 1000,\n    day: 24 * 60 * 60 * 1000\n};\n\n\ninternals.functions = {\n\n    if(condition, then, otherwise) {\n\n        return condition ? then : otherwise;\n    },\n\n    length(item) {\n\n        if (typeof item === 'string') {\n            return item.length;\n        }\n\n        if (!item || typeof item !== 'object') {\n            return null;\n        }\n\n        if (Array.isArray(item)) {\n            return item.length;\n        }\n\n        return Object.keys(item).length;\n    },\n\n    msg(code) {\n\n        const [value, state, prefs, local, options] = this;\n        const messages = options.messages;\n        if (!messages) {\n            return '';\n        }\n\n        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);\n        if (!template) {\n            return '';\n        }\n\n        return template.render(value, state, prefs, local, options);\n    },\n\n    number(value) {\n\n        if (typeof value === 'number') {\n            return value;\n        }\n\n        if (typeof value === 'string') {\n            return parseFloat(value);\n        }\n\n        if (typeof value === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (value instanceof Date) {\n            return value.getTime();\n        }\n\n        return null;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90ZW1wbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsNEVBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQywwRUFBc0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQTJCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLDRFQUFrQjs7QUFFMUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTtBQUNqQyxZQUFZLG1CQUFPLENBQUMsa0RBQU87OztBQUczQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU8sTUFBTSxJQUFJLFdBQVcsYUFBYSxTQUFTLE9BQU87O0FBRTNFLG9DQUFvQztBQUNwQztBQUNBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCOztBQUU1RCxpQ0FBaUMsRUFBRSx1QkFBdUI7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9FQUFvRSxjQUFjO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0ZBQXdGLDZDQUE2QztBQUNySTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0dBQWtHO0FBQ2xHOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCw2Q0FBNkM7QUFDL0Ysd0RBQXdELHNEQUFzRDtBQUM5RztBQUNBO0FBQ0Esd0RBQXdELFFBQVEsa0JBQWtCLFlBQVk7QUFDOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdFQUFnRTs7O0FBR2hFOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7O0FBRXZCO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2Qzs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEMsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLO0FBQ3RDOztBQUVBLGNBQWMsUUFBUSxFQUFFLE1BQU0sRUFBRSxRQUFRO0FBQ3hDOzs7QUFHQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELDBCQUEwQjtBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQixLQUFLLGVBQWU7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSw4QkFBOEI7QUFDN0c7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3RlbXBsYXRlLmpzPzhjYWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IEVzY2FwZUh0bWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lc2NhcGVIdG1sJyk7XG5jb25zdCBGb3JtdWxhID0gcmVxdWlyZSgnQHNpZGV3YXkvZm9ybXVsYScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHN5bWJvbDogU3ltYm9sKCd0ZW1wbGF0ZScpLFxuXG4gICAgb3BlbnM6IG5ldyBBcnJheSgxMDAwKS5qb2luKCdcXHUwMDAwJyksXG4gICAgY2xvc2VzOiBuZXcgQXJyYXkoMTAwMCkuam9pbignXFx1MDAwMScpLFxuXG4gICAgZGF0ZUZvcm1hdDoge1xuICAgICAgICBkYXRlOiBEYXRlLnByb3RvdHlwZS50b0RhdGVTdHJpbmcsXG4gICAgICAgIGlzbzogRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcsXG4gICAgICAgIHN0cmluZzogRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIHRpbWU6IERhdGUucHJvdG90eXBlLnRvVGltZVN0cmluZyxcbiAgICAgICAgdXRjOiBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZ1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gaW50ZXJuYWxzLlRlbXBsYXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnLCAnVGVtcGxhdGUgc291cmNlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuaW5jbHVkZXMoJ1xcdTAwMDAnKSAmJiAhc291cmNlLmluY2x1ZGVzKCdcXHUwMDAxJyksICdUZW1wbGF0ZSBzb3VyY2UgY2Fubm90IGNvbnRhaW4gcmVzZXJ2ZWQgY29udHJvbCBjaGFyYWN0ZXJzJyk7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBzb3VyY2U7XG5cbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZ1bmN0aW9ucywgLi4ub3B0cyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0gT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID8gQ2xvbmUob3B0cykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy5fZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC5rZXlzKHRoaXMuX2Z1bmN0aW9ucykuZXZlcnkoKGtleSkgPT4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycpLCAnRnVuY3Rpb25zIGtleXMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC52YWx1ZXModGhpcy5fZnVuY3Rpb25zKS5ldmVyeSgoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSwgJ0Z1bmN0aW9ucyB2YWx1ZXMgbXVzdCBiZSBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFyc2UoKTtcbiAgICB9XG5cbiAgICBfcGFyc2UoKSB7XG5cbiAgICAgICAgLy8gJ3RleHQge3Jhd30ge3tyZWZ9fSBcXFxce3tpZ25vcmV9fSB7e2lnbm9yZVxcXFx9fSB7e2lnbm9yZSB7e2lnbm9yZX0nXG5cbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmNvZGUgZXNjYXBlZCBcXFxce3t7e3tcblxuICAgICAgICBjb25zdCBlbmNvZGVkID0gaW50ZXJuYWxzLmVuY29kZSh0aGlzLnNvdXJjZSk7XG5cbiAgICAgICAgLy8gU3BsaXQgb24gZmlyc3QgeyBpbiBlYWNoIHNldFxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gaW50ZXJuYWxzLnNwbGl0KGVuY29kZWQpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICBsZXQgcmVmcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgY29uc3QgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gcGFydFswXSAhPT0gJ3snO1xuICAgICAgICAgICAgY29uc3QgZW5kZXIgPSByYXcgPyAnfScgOiAnfX0nO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcGFydC5pbmRleE9mKGVuZGVyKTtcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBub24tbWF0Y2hpbmcgY2xvc2luZ1xuICAgICAgICAgICAgICAgIHBhcnRbMV0gPT09ICd7JykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG1vcmUgdGhhbiB0d28ge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goYHske2ludGVybmFscy5kZWNvZGUocGFydCl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YXJpYWJsZSA9IHBhcnQuc2xpY2UocmF3ID8gMCA6IDEsIGVuZCk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gdmFyaWFibGVbMF0gPT09ICc6JztcbiAgICAgICAgICAgIGlmICh3cmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IHRoaXMuX3JlZihpbnRlcm5hbHMuZGVjb2RlKHZhcmlhYmxlKSwgeyByYXcsIHdyYXBwZWQgfSk7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChkeW5hbWljKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHluYW1pYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhcnQuc2xpY2UoZW5kICsgZW5kZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goaW50ZXJuYWxzLmRlY29kZShyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSBwcm9jZXNzZWQuam9pbignJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGF0ZShkYXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZUZvcm1hdFtwcmVmcy5kYXRlRm9ybWF0XS5jYWxsKGRhdGUpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcGFjdCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjID0geyB0ZW1wbGF0ZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB0aGlzLl9zZXR0aW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIGRlc2MuZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuXG4gICAgc3RhdGljIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5UZW1wbGF0ZShkZXNjLnRlbXBsYXRlLCBkZXNjLm9wdGlvbnMgfHwgZGVzYy5mdW5jdGlvbnMgPyB7IC4uLmRlc2Mub3B0aW9ucywgZnVuY3Rpb25zOiBkZXNjLmZ1bmN0aW9ucyB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBpc0R5bmFtaWMoKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVGVtcGxhdGUodGVtcGxhdGUpIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUgPyAhIXRlbXBsYXRlW0NvbW1vbi5zeW1ib2xzLnRlbXBsYXRlXSA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJlZnMoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2goLi4ucGFydC5yZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpIHtcblxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydCh0aGlzLl90ZW1wbGF0ZVswXSwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHt9IC8qXSAqLyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpO1xuICAgIH1cblxuICAgIF9wYXJ0KHBhcnQsIC4uLmFyZ3MpIHtcblxuICAgICAgICBpZiAocGFydC5yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnJlZi5yZXNvbHZlKC4uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnQuZm9ybXVsYS5ldmFsdWF0ZShhcmdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSB0aGlzLl9wYXJ0KHBhcnQsIC8qIGNvbnRleHQgLT4gWyovIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zIC8qXSAqLyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gaW50ZXJuYWxzLnN0cmluZ2lmeShyZW5kZXJlZCwgdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJ0LnJhdyB8fCAob3B0aW9ucy5lcnJvcnMgJiYgb3B0aW9ucy5lcnJvcnMuZXNjYXBlSHRtbCkgPT09IGZhbHNlID8gc3RyaW5nIDogRXNjYXBlSHRtbChzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGludGVybmFscy53cmFwKHJlc3VsdCwgcGFydC53cmFwcGVkICYmIHByZWZzLmVycm9ycy53cmFwLmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIF9yZWYoY29udGVudCwgeyByYXcsIHdyYXBwZWQgfSkge1xuXG4gICAgICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gKHZhcmlhYmxlKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IFJlZi5jcmVhdGUodmFyaWFibGUsIHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgICAgIHJlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlZi5yZXNvbHZlKC4uLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZCAhPT0gdW5kZWZpbmVkID8gcmVzb2x2ZWQgOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zID8geyAuLi5pbnRlcm5hbHMuZnVuY3Rpb25zLCAuLi50aGlzLl9mdW5jdGlvbnMgfSA6IGludGVybmFscy5mdW5jdGlvbnM7XG4gICAgICAgICAgICB2YXIgZm9ybXVsYSA9IG5ldyBGb3JtdWxhLlBhcnNlcihjb250ZW50LCB7IHJlZmVyZW5jZSwgZnVuY3Rpb25zLCBjb25zdGFudHM6IGludGVybmFscy5jb25zdGFudHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgSW52YWxpZCB0ZW1wbGF0ZSB2YXJpYWJsZSBcIiR7Y29udGVudH1cIiBmYWlscyBkdWUgdG86ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtdWxhLnNpbmdsZSkge1xuICAgICAgICAgICAgaWYgKGZvcm11bGEuc2luZ2xlLnR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWYsIHJhdywgcmVmcywgd3JhcHBlZDogd3JhcHBlZCB8fCByZWYudHlwZSA9PT0gJ2xvY2FsJyAmJiByZWYua2V5ID09PSAnbGFiZWwnIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuc3RyaW5naWZ5KGZvcm11bGEuc2luZ2xlLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGZvcm11bGEsIHJhdywgcmVmcyB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudGVtcGxhdGVdID0gdHJ1ZTtcbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzXG5cblxuaW50ZXJuYWxzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFx7KykvZywgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm9wZW5zLnNsaWNlKDAsICQxLmxlbmd0aCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcKFxcfSspL2csICgkMCwgJDEpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5jbG9zZXMuc2xpY2UoMCwgJDEubGVuZ3RoKTtcbiAgICAgICAgfSk7XG59O1xuXG5cbmludGVybmFscy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csICd7JylcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDEvZywgJ30nKTtcbn07XG5cblxuaW50ZXJuYWxzLnNwbGl0ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0cmluZ1tpXTtcblxuICAgICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgc3RyaW5nLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ1tpICsgMV0gPT09ICd7Jykge1xuXG4gICAgICAgICAgICAgICAgbmV4dCArPSAneyc7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgIHJldHVybiBwYXJ0cztcbn07XG5cblxuaW50ZXJuYWxzLndyYXAgPSBmdW5jdGlvbiAodmFsdWUsIGVuZHMpIHtcblxuICAgIGlmICghZW5kcykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGVuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmRzfSR7dmFsdWV9JHtlbmRzfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2VuZHNbMF19JHt2YWx1ZX0ke2VuZHNbMV19YDtcbn07XG5cblxuaW50ZXJuYWxzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjb25zdCB3cmFwID0gcHJlZnMgJiYgcHJlZnMuZXJyb3JzICYmIHByZWZzLmVycm9ycy53cmFwIHx8IHt9O1xuXG4gICAgbGV0IHNraXBXcmFwID0gZmFsc2U7XG4gICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUucmVuZGVyKSB7XG5cbiAgICAgICAgc2tpcFdyYXAgPSB2YWx1ZS5pbjtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXNvbHZlKG9yaWdpbmFsLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCB7IGluOiB2YWx1ZS5pbiwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy53cmFwKHZhbHVlLCBvcHRpb25zLmFycmF5SXRlbXMgJiYgd3JhcC5zdHJpbmcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLlRlbXBsYXRlLmRhdGUodmFsdWUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBzeW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChgJHtrZXkudG9TdHJpbmcoKX0gLT4gJHtzeW0udG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gcGFpcnM7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goaW50ZXJuYWxzLnN0cmluZ2lmeShpdGVtLCBvcmlnaW5hbCwgc3RhdGUsIHByZWZzLCBsb2NhbCwgeyBhcnJheUl0ZW1zOiB0cnVlLCAuLi5vcHRpb25zIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLndyYXAodmFsdWVzLmpvaW4oJywgJyksICFza2lwV3JhcCAmJiB3cmFwLmFycmF5KTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbnN0YW50cyA9IHtcblxuICAgIHRydWU6IHRydWUsXG4gICAgZmFsc2U6IGZhbHNlLFxuICAgIG51bGw6IG51bGwsXG5cbiAgICBzZWNvbmQ6IDEwMDAsXG4gICAgbWludXRlOiA2MCAqIDEwMDAsXG4gICAgaG91cjogNjAgKiA2MCAqIDEwMDAsXG4gICAgZGF5OiAyNCAqIDYwICogNjAgKiAxMDAwXG59O1xuXG5cbmludGVybmFscy5mdW5jdGlvbnMgPSB7XG5cbiAgICBpZihjb25kaXRpb24sIHRoZW4sIG90aGVyd2lzZSkge1xuXG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyB0aGVuIDogb3RoZXJ3aXNlO1xuICAgIH0sXG5cbiAgICBsZW5ndGgoaXRlbSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIG1zZyhjb2RlKSB7XG5cbiAgICAgICAgY29uc3QgW3ZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zXSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBFcnJvcnMudGVtcGxhdGUodmFsdWUsIG1lc3NhZ2VzWzBdLCBjb2RlLCBzdGF0ZSwgcHJlZnMpIHx8IEVycm9ycy50ZW1wbGF0ZSh2YWx1ZSwgbWVzc2FnZXNbMV0sIGNvZGUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBudW1iZXIodmFsdWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/template.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/trace.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/trace.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"(rsc)/./node_modules/@hapi/hoek/lib/deepEqual.js\");\nconst Pinpoint = __webpack_require__(/*! @sideway/pinpoint */ \"(rsc)/./node_modules/@sideway/pinpoint/lib/index.js\");\n\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\n\n\nconst internals = {\n    codes: {\n        error: 1,\n        pass: 2,\n        full: 3\n    },\n    labels: {\n        0: 'never used',\n        1: 'always error',\n        2: 'always pass'\n    }\n};\n\n\nexports.setup = function (root) {\n\n    const trace = function () {\n\n        root._tracer = root._tracer || new internals.Tracer();\n        return root._tracer;\n    };\n\n    root.trace = trace;\n    root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;\n\n    root.untrace = () => {\n\n        root._tracer = null;\n    };\n};\n\n\nexports.location = function (schema) {\n\n    return schema.$_setFlag('_tracerLocation', Pinpoint.location(2));                       // base.tracer(), caller\n};\n\n\ninternals.Tracer = class {\n\n    constructor() {\n\n        this.name = 'Joi';\n        this._schemas = new Map();\n    }\n\n    _register(schema) {\n\n        const existing = this._schemas.get(schema);\n        if (existing) {\n            return existing.store;\n        }\n\n        const store = new internals.Store(schema);\n        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);   // internals.tracer(), internals.entry(), exports.entry(), validate(), caller\n        this._schemas.set(schema, { filename, line, store });\n        return store;\n    }\n\n    _combine(merged, sources) {\n\n        for (const { store } of this._schemas.values()) {\n            store._combine(merged, sources);\n        }\n    }\n\n    report(file) {\n\n        const coverage = [];\n\n        // Process each registered schema\n\n        for (const { filename, line, store } of this._schemas.values()) {\n            if (file &&\n                file !== filename) {\n\n                continue;\n            }\n\n            // Process sub schemas of the registered root\n\n            const missing = [];\n            const skipped = [];\n\n            for (const [schema, log] of store._sources.entries()) {\n\n                // Check if sub schema parent skipped\n\n                if (internals.sub(log.paths, skipped)) {\n                    continue;\n                }\n\n                // Check if sub schema reached\n\n                if (!log.entry) {\n                    missing.push({\n                        status: 'never reached',\n                        paths: [...log.paths]\n                    });\n\n                    skipped.push(...log.paths);\n                    continue;\n                }\n\n                // Check values\n\n                for (const type of ['valid', 'invalid']) {\n                    const set = schema[`_${type}s`];\n                    if (!set) {\n                        continue;\n                    }\n\n                    const values = new Set(set._values);\n                    const refs = new Set(set._refs);\n                    for (const { value, ref } of log[type]) {\n                        values.delete(value);\n                        refs.delete(ref);\n                    }\n\n                    if (values.size ||\n                        refs.size) {\n\n                        missing.push({\n                            status: [...values, ...[...refs].map((ref) => ref.display)],\n                            rule: `${type}s`\n                        });\n                    }\n                }\n\n                // Check rules status\n\n                const rules = schema._rules.map((rule) => rule.name);\n                for (const type of ['default', 'failover']) {\n                    if (schema._flags[type] !== undefined) {\n                        rules.push(type);\n                    }\n                }\n\n                for (const name of rules) {\n                    const status = internals.labels[log.rule[name] || 0];\n                    if (status) {\n                        const report = { rule: name, status };\n                        if (log.paths.size) {\n                            report.paths = [...log.paths];\n                        }\n\n                        missing.push(report);\n                    }\n                }\n            }\n\n            if (missing.length) {\n                coverage.push({\n                    filename,\n                    line,\n                    missing,\n                    severity: 'error',\n                    message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`\n                });\n            }\n        }\n\n        return coverage.length ? coverage : null;\n    }\n};\n\n\ninternals.Store = class {\n\n    constructor(schema) {\n\n        this.active = true;\n        this._sources = new Map();          // schema -> { paths, entry, rule, valid, invalid }\n        this._combos = new Map();           // merged -> [sources]\n        this._scan(schema);\n    }\n\n    debug(state, source, name, result) {\n\n        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });\n    }\n\n    entry(schema, state) {\n\n        internals.debug(state, { type: 'entry' });\n\n        this._record(schema, (log) => {\n\n            log.entry = true;\n        });\n    }\n\n    filter(schema, state, source, value) {\n\n        internals.debug(state, { type: source, ...value });\n\n        this._record(schema, (log) => {\n\n            log[source].add(value);\n        });\n    }\n\n    log(schema, state, source, name, result) {\n\n        internals.debug(state, { type: source, name, result: result === 'full' ? 'pass' : result });\n\n        this._record(schema, (log) => {\n\n            log[source][name] = log[source][name] || 0;\n            log[source][name] |= internals.codes[result];\n        });\n    }\n\n    resolve(state, ref, to) {\n\n        if (!state.mainstay.debug) {\n            return;\n        }\n\n        const log = { type: 'resolve', ref: ref.display, to, path: state.path };\n        state.mainstay.debug.push(log);\n    }\n\n    value(state, by, from, to, name) {\n\n        if (!state.mainstay.debug ||\n            DeepEqual(from, to)) {\n\n            return;\n        }\n\n        const log = { type: 'value', by, from, to, path: state.path };\n        if (name) {\n            log.name = name;\n        }\n\n        state.mainstay.debug.push(log);\n    }\n\n    _record(schema, each) {\n\n        const log = this._sources.get(schema);\n        if (log) {\n            each(log);\n            return;\n        }\n\n        const sources = this._combos.get(schema);\n        for (const source of sources) {\n            this._record(source, each);\n        }\n    }\n\n    _scan(schema, _path) {\n\n        const path = _path || [];\n\n        let log = this._sources.get(schema);\n        if (!log) {\n            log = {\n                paths: new Set(),\n                entry: false,\n                rule: {},\n                valid: new Set(),\n                invalid: new Set()\n            };\n\n            this._sources.set(schema, log);\n        }\n\n        if (path.length) {\n            log.paths.add(path);\n        }\n\n        const each = (sub, source) => {\n\n            const subId = internals.id(sub, source);\n            this._scan(sub, path.concat(subId));\n        };\n\n        schema.$_modify({ each, ref: false });\n    }\n\n    _combine(merged, sources) {\n\n        this._combos.set(merged, sources);\n    }\n};\n\n\ninternals.message = function (item) {\n\n    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';\n    return `${path}${item.rule || ''} (${item.status})`;\n};\n\n\ninternals.id = function (schema, { source, name, path, key }) {\n\n    if (schema._flags.id) {\n        return schema._flags.id;\n    }\n\n    if (key) {\n        return key;\n    }\n\n    name = `@${name}`;\n\n    if (source === 'terms') {\n        return [name, path[Math.min(path.length - 1, 1)]];\n    }\n\n    return name;\n};\n\n\ninternals.sub = function (paths, skipped) {\n\n    for (const path of paths) {\n        for (const skip of skipped) {\n            if (DeepEqual(path.slice(0, skip.length), skip)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n\ninternals.debug = function (state, event) {\n\n    if (state.mainstay.debug) {\n        event.path = state.debug ? [...state.path, state.debug] : state.path;\n        state.mainstay.debug.push(event);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90cmFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBMEI7QUFDcEQsaUJBQWlCLG1CQUFPLENBQUMsOEVBQW1COztBQUU1QyxlQUFlLG1CQUFPLENBQUMsd0RBQVU7OztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLGdCQUFnQjs7QUFFaEIsNEZBQTRGO0FBQzVGOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsaUJBQWlCLDJEQUEyRDtBQUM1RixvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQyx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMENBQTBDO0FBQ25HLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRCw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQSw0REFBNEQsOENBQThDO0FBQzFHOztBQUVBOztBQUVBLGlDQUFpQyxlQUFlOztBQUVoRDs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSxpQ0FBaUMsd0JBQXdCOztBQUV6RDs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSxpQ0FBaUMsaUVBQWlFOztBQUVsRzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGtCQUFrQjtBQUM1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsY0FBYyxLQUFLLEVBQUUsaUJBQWlCLEdBQUcsWUFBWTtBQUNyRDs7O0FBR0EsbUNBQW1DLHlCQUF5Qjs7QUFFNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLEtBQUs7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHJhY2UuanM/Mzc1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgUGlucG9pbnQgPSByZXF1aXJlKCdAc2lkZXdheS9waW5wb2ludCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBjb2Rlczoge1xuICAgICAgICBlcnJvcjogMSxcbiAgICAgICAgcGFzczogMixcbiAgICAgICAgZnVsbDogM1xuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICAgIDA6ICduZXZlciB1c2VkJyxcbiAgICAgICAgMTogJ2Fsd2F5cyBlcnJvcicsXG4gICAgICAgIDI6ICdhbHdheXMgcGFzcydcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuc2V0dXAgPSBmdW5jdGlvbiAocm9vdCkge1xuXG4gICAgY29uc3QgdHJhY2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gcm9vdC5fdHJhY2VyIHx8IG5ldyBpbnRlcm5hbHMuVHJhY2VyKCk7XG4gICAgICAgIHJldHVybiByb290Ll90cmFjZXI7XG4gICAgfTtcblxuICAgIHJvb3QudHJhY2UgPSB0cmFjZTtcbiAgICByb290W1N5bWJvbC5mb3IoJ0BoYXBpL2xhYi9jb3ZlcmFnZS9pbml0aWFsaXplJyldID0gdHJhY2U7XG5cbiAgICByb290LnVudHJhY2UgPSAoKSA9PiB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gbnVsbDtcbiAgICB9O1xufTtcblxuXG5leHBvcnRzLmxvY2F0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgcmV0dXJuIHNjaGVtYS4kX3NldEZsYWcoJ190cmFjZXJMb2NhdGlvbicsIFBpbnBvaW50LmxvY2F0aW9uKDIpKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2UudHJhY2VyKCksIGNhbGxlclxufTtcblxuXG5pbnRlcm5hbHMuVHJhY2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0pvaSc7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyKHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fc2NoZW1hcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmcuc3RvcmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBpbnRlcm5hbHMuU3RvcmUoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgeyBmaWxlbmFtZSwgbGluZSB9ID0gc2NoZW1hLl9mbGFncy5fdHJhY2VyTG9jYXRpb24gfHwgUGlucG9pbnQubG9jYXRpb24oNSk7ICAgLy8gaW50ZXJuYWxzLnRyYWNlcigpLCBpbnRlcm5hbHMuZW50cnkoKSwgZXhwb3J0cy5lbnRyeSgpLCB2YWxpZGF0ZSgpLCBjYWxsZXJcbiAgICAgICAgdGhpcy5fc2NoZW1hcy5zZXQoc2NoZW1hLCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN0b3JlLl9jb21iaW5lKG1lcmdlZCwgc291cmNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXBvcnQoZmlsZSkge1xuXG4gICAgICAgIGNvbnN0IGNvdmVyYWdlID0gW107XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHJlZ2lzdGVyZWQgc2NoZW1hXG5cbiAgICAgICAgZm9yIChjb25zdCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChmaWxlICYmXG4gICAgICAgICAgICAgICAgZmlsZSAhPT0gZmlsZW5hbWUpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHN1YiBzY2hlbWFzIG9mIHRoZSByZWdpc3RlcmVkIHJvb3RcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzY2hlbWEsIGxvZ10gb2Ygc3RvcmUuX3NvdXJjZXMuZW50cmllcygpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzdWIgc2NoZW1hIHBhcmVudCBza2lwcGVkXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLnN1Yihsb2cucGF0aHMsIHNraXBwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHN1YiBzY2hlbWEgcmVhY2hlZFxuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2cuZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ25ldmVyIHJlYWNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsuLi5sb2cucGF0aHNdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCguLi5sb2cucGF0aHMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB2YWx1ZXNcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ3ZhbGlkJywgJ2ludmFsaWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBzY2hlbWFbYF8ke3R5cGV9c2BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KHNldC5fdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IG5ldyBTZXQoc2V0Ll9yZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlLCByZWYgfSBvZiBsb2dbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuc2l6ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5zaXplKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBbLi4udmFsdWVzLCAuLi5bLi4ucmVmc10ubWFwKChyZWYpID0+IHJlZi5kaXNwbGF5KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYCR7dHlwZX1zYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBydWxlcyBzdGF0dXNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gc2NoZW1hLl9ydWxlcy5tYXAoKHJ1bGUpID0+IHJ1bGUubmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFsnZGVmYXVsdCcsICdmYWlsb3ZlciddKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gaW50ZXJuYWxzLmxhYmVsc1tsb2cucnVsZVtuYW1lXSB8fCAwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0geyBydWxlOiBuYW1lLCBzdGF0dXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cucGF0aHMuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRocyA9IFsuLi5sb2cucGF0aHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFNjaGVtYSBtaXNzaW5nIHRlc3RzIGZvciAke21pc3NpbmcubWFwKGludGVybmFscy5tZXNzYWdlKS5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3ZlcmFnZS5sZW5ndGggPyBjb3ZlcmFnZSA6IG51bGw7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuU3RvcmUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgIC8vIHNjaGVtYSAtPiB7IHBhdGhzLCBlbnRyeSwgcnVsZSwgdmFsaWQsIGludmFsaWQgfVxuICAgICAgICB0aGlzLl9jb21ib3MgPSBuZXcgTWFwKCk7ICAgICAgICAgICAvLyBtZXJnZWQgLT4gW3NvdXJjZXNdXG4gICAgICAgIHRoaXMuX3NjYW4oc2NoZW1hKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhzdGF0ZSwgc291cmNlLCBuYW1lLCByZXN1bHQpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1ZyAmJiBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKHsgdHlwZTogc291cmNlLCBuYW1lLCByZXN1bHQsIHBhdGg6IHN0YXRlLnBhdGggfSk7XG4gICAgfVxuXG4gICAgZW50cnkoc2NoZW1hLCBzdGF0ZSkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiAnZW50cnknIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nLmVudHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmlsdGVyKHNjaGVtYSwgc3RhdGUsIHNvdXJjZSwgdmFsdWUpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogc291cmNlLCAuLi52YWx1ZSB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZ1tzb3VyY2VdLmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvZyhzY2hlbWEsIHN0YXRlLCBzb3VyY2UsIG5hbWUsIHJlc3VsdCkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiBzb3VyY2UsIG5hbWUsIHJlc3VsdDogcmVzdWx0ID09PSAnZnVsbCcgPyAncGFzcycgOiByZXN1bHQgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSA9IGxvZ1tzb3VyY2VdW25hbWVdIHx8IDA7XG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSB8PSBpbnRlcm5hbHMuY29kZXNbcmVzdWx0XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZShzdGF0ZSwgcmVmLCB0bykge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZyA9IHsgdHlwZTogJ3Jlc29sdmUnLCByZWY6IHJlZi5kaXNwbGF5LCB0bywgcGF0aDogc3RhdGUucGF0aCB9O1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgdmFsdWUoc3RhdGUsIGJ5LCBmcm9tLCB0bywgbmFtZSkge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcgfHxcbiAgICAgICAgICAgIERlZXBFcXVhbChmcm9tLCB0bykpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9nID0geyB0eXBlOiAndmFsdWUnLCBieSwgZnJvbSwgdG8sIHBhdGg6IHN0YXRlLnBhdGggfTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGxvZy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2gobG9nKTtcbiAgICB9XG5cbiAgICBfcmVjb3JkKHNjaGVtYSwgZWFjaCkge1xuXG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX3NvdXJjZXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGVhY2gobG9nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9jb21ib3MuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZChzb3VyY2UsIGVhY2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NjYW4oc2NoZW1hLCBfcGF0aCkge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgICAgICBsZXQgbG9nID0gdGhpcy5fc291cmNlcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKCFsb2cpIHtcbiAgICAgICAgICAgIGxvZyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoczogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydWxlOiB7fSxcbiAgICAgICAgICAgICAgICB2YWxpZDogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fc291cmNlcy5zZXQoc2NoZW1hLCBsb2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2cucGF0aHMuYWRkKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChzdWIsIHNvdXJjZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IGludGVybmFscy5pZChzdWIsIHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9zY2FuKHN1YiwgcGF0aC5jb25jYXQoc3ViSWQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY2hlbWEuJF9tb2RpZnkoeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIHRoaXMuX2NvbWJvcy5zZXQobWVyZ2VkLCBzb3VyY2VzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5tZXNzYWdlID0gZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgIGNvbnN0IHBhdGggPSBpdGVtLnBhdGhzID8gRXJyb3JzLnBhdGgoaXRlbS5wYXRoc1swXSkgKyAoaXRlbS5ydWxlID8gJzonIDogJycpIDogJyc7XG4gICAgcmV0dXJuIGAke3BhdGh9JHtpdGVtLnJ1bGUgfHwgJyd9ICgke2l0ZW0uc3RhdHVzfSlgO1xufTtcblxuXG5pbnRlcm5hbHMuaWQgPSBmdW5jdGlvbiAoc2NoZW1hLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pIHtcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLmlkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBuYW1lID0gYEAke25hbWV9YDtcblxuICAgIGlmIChzb3VyY2UgPT09ICd0ZXJtcycpIHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCBwYXRoW01hdGgubWluKHBhdGgubGVuZ3RoIC0gMSwgMSldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cblxuaW50ZXJuYWxzLnN1YiA9IGZ1bmN0aW9uIChwYXRocywgc2tpcHBlZCkge1xuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2tpcCBvZiBza2lwcGVkKSB7XG4gICAgICAgICAgICBpZiAoRGVlcEVxdWFsKHBhdGguc2xpY2UoMCwgc2tpcC5sZW5ndGgpLCBza2lwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuZGVidWcgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XG5cbiAgICBpZiAoc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgZXZlbnQucGF0aCA9IHN0YXRlLmRlYnVnID8gWy4uLnN0YXRlLnBhdGgsIHN0YXRlLmRlYnVnXSA6IHN0YXRlLnBhdGg7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2goZXZlbnQpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/trace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/alternatives.js":
/*!****************************************************!*\
  !*** ./node_modules/joi/lib/types/alternatives.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ \"(rsc)/./node_modules/@hapi/hoek/lib/merge.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ../ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'alternatives',\n\n    flags: {\n\n        match: { default: 'any' }                 // 'any', 'one', 'all'\n    },\n\n    terms: {\n\n        matches: { init: [], register: Ref.toSibling }\n    },\n\n    args(schema, ...schemas) {\n\n        if (schemas.length === 1) {\n            if (Array.isArray(schemas[0])) {\n                return schema.try(...schemas[0]);\n            }\n        }\n\n        return schema.try(...schemas);\n    },\n\n    validate(value, helpers) {\n\n        const { schema, error, state, prefs } = helpers;\n\n        // Match all or one\n\n        if (schema._flags.match) {\n            const matched = [];\n            const failed = [];\n\n            for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n                const item = schema.$_terms.matches[i];\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    matched.push(result.value);\n                    localState.commit();\n                }\n                else {\n                    failed.push(result.errors);\n                    localState.restore();\n                }\n            }\n\n            if (matched.length === 0) {\n                const context = {\n                    details: failed.map((f) => Errors.details(f, { override: false }))\n                };\n\n                return { errors: error('alternatives.any', context) };\n            }\n\n            // Match one\n\n            if (schema._flags.match === 'one') {\n                return matched.length === 1 ? { value: matched[0] } : { errors: error('alternatives.one') };\n            }\n\n            // Match all\n\n            if (matched.length !== schema.$_terms.matches.length) {\n                const context = {\n                    details: failed.map((f) => Errors.details(f, { override: false }))\n                };\n\n                return { errors: error('alternatives.all', context) };\n            }\n\n            const isAnyObj = (alternative) => {\n\n                return alternative.$_terms.matches.some((v) => {\n\n                    return v.schema.type === 'object' ||\n                        (v.schema.type === 'alternatives' && isAnyObj(v.schema));\n                });\n            };\n\n            return isAnyObj(schema) ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };\n        }\n\n        // Match any\n\n        const errors = [];\n        for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n            const item = schema.$_terms.matches[i];\n\n            // Try\n\n            if (item.schema) {\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    localState.commit();\n                    return result;\n                }\n\n                localState.restore();\n                errors.push({ schema: item.schema, reports: result.errors });\n                continue;\n            }\n\n            // Conditional\n\n            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;\n            const tests = item.is ? [item] : item.switch;\n\n            for (let j = 0; j < tests.length; ++j) {\n                const test = tests[j];\n                const { is, then, otherwise } = test;\n\n                const id = `match.${i}${item.switch ? '.' + j : ''}`;\n                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {\n                    if (otherwise) {\n                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);\n                    }\n                }\n                else if (then) {\n                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);\n                }\n            }\n        }\n\n        return internals.errors(errors, helpers);\n    },\n\n    rules: {\n\n        conditional: {\n            method(condition, options) {\n\n                Assert(!this._flags._endedSwitch, 'Unreachable condition');\n                Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');\n                Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');\n\n                const obj = this.clone();\n\n                const match = Compile.when(obj, condition, options);\n                const conditions = match.is ? [match] : match.switch;\n                for (const item of conditions) {\n                    if (item.then &&\n                        item.otherwise) {\n\n                        obj.$_setFlag('_endedSwitch', true, { clone: false });\n                        break;\n                    }\n                }\n\n                obj.$_terms.matches.push(match);\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        match: {\n            method(mode) {\n\n                Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);\n\n                if (mode !== 'any') {\n                    for (const match of this.$_terms.matches) {\n                        Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');\n                    }\n                }\n\n                return this.$_setFlag('match', mode);\n            }\n        },\n\n        try: {\n            method(...schemas) {\n\n                Assert(schemas.length, 'Missing alternative schemas');\n                Common.verifyFlat(schemas, 'try');\n\n                Assert(!this._flags._endedSwitch, 'Unreachable condition');\n\n                const obj = this.clone();\n                for (const schema of schemas) {\n                    obj.$_terms.matches.push({ schema: obj.$_compile(schema) });\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        }\n    },\n\n    overrides: {\n\n        label(name) {\n\n            const obj = this.$_parent('label', name);\n            const each = (item, source) => {\n\n                return source.path[0] !== 'is' && typeof item._flags.label !== 'string' ? item.label(name) : undefined;\n            };\n\n            return obj.$_modify({ each, ref: false });\n        }\n    },\n\n    rebuild(schema) {\n\n        // Flag when an alternative type is an array\n\n        const each = (item) => {\n\n            if (Common.isSchema(item) &&\n                item.type === 'array') {\n\n                schema.$_setFlag('_arrayItems', true, { clone: false });\n            }\n        };\n\n        schema.$_modify({ each });\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.matches) {\n                for (const match of desc.matches) {\n                    const { schema, ref, is, not, then, otherwise } = match;\n                    if (schema) {\n                        obj = obj.try(schema);\n                    }\n                    else if (ref) {\n                        obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });\n                    }\n                    else {\n                        obj = obj.conditional(is, { then, otherwise });\n                    }\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'alternatives.all': '{{#label}} does not match all of the required types',\n        'alternatives.any': '{{#label}} does not match any of the allowed types',\n        'alternatives.match': '{{#label}} does not match any of the allowed types',\n        'alternatives.one': '{{#label}} matches more than one allowed type',\n        'alternatives.types': '{{#label}} must be one of {{#types}}'\n    }\n});\n\n\n// Helpers\n\ninternals.errors = function (failures, { error, state }) {\n\n    // Nothing matched due to type criteria rules\n\n    if (!failures.length) {\n        return { errors: error('alternatives.any') };\n    }\n\n    // Single error\n\n    if (failures.length === 1) {\n        return { errors: failures[0].reports };\n    }\n\n    // Analyze reasons\n\n    const valids = new Set();\n    const complex = [];\n\n    for (const { reports, schema } of failures) {\n\n        // Multiple errors (!abortEarly)\n\n        if (reports.length > 1) {\n            return internals.unmatched(failures, error);\n        }\n\n        // Custom error\n\n        const report = reports[0];\n        if (report instanceof Errors.Report === false) {\n            return internals.unmatched(failures, error);\n        }\n\n        // Internal object or array error\n\n        if (report.state.path.length !== state.path.length) {\n            complex.push({ type: schema.type, report });\n            continue;\n        }\n\n        // Valids\n\n        if (report.code === 'any.only') {\n            for (const valid of report.local.valids) {\n                valids.add(valid);\n            }\n\n            continue;\n        }\n\n        // Base type\n\n        const [type, code] = report.code.split('.');\n        if (code !== 'base') {\n            complex.push({ type: schema.type, report });\n        }\n        else if (report.code === 'object.base') {\n            valids.add(report.local.type);\n        }\n        else {\n            valids.add(type);\n        }\n    }\n\n    // All errors are base types or valids\n\n    if (!complex.length) {\n        return { errors: error('alternatives.types', { types: [...valids] }) };\n    }\n\n    // Single complex error\n\n    if (complex.length === 1) {\n        return { errors: complex[0].report };\n    }\n\n    return internals.unmatched(failures, error);\n};\n\n\ninternals.unmatched = function (failures, error) {\n\n    const errors = [];\n    for (const failure of failures) {\n        errors.push(...failure.reports);\n    }\n\n    return { errors: error('alternatives.match', Errors.details(errors, { override: false })) };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1QjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsMEVBQXNCOztBQUU1QyxZQUFZLG1CQUFPLENBQUMsd0RBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHlEQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFZO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyx5REFBVztBQUNsQyxZQUFZLG1CQUFPLENBQUMsbURBQVE7OztBQUc1Qjs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLGlDQUFpQztBQUNsRCxLQUFLOztBQUVMOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBLGdCQUFnQiw4QkFBOEI7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUNBQW1DO0FBQy9EO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdELG9CQUFvQixJQUFJO0FBQ3hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLHdDQUF3QyxrREFBa0Qsb0JBQW9CLEtBQUssSUFBSTtBQUN2SDs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7O0FBRUE7O0FBRUE7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBLHdCQUF3QixzQkFBc0I7O0FBRTlDLG9DQUFvQyxFQUFFLEVBQUUsMkJBQTJCO0FBQ25FLHlEQUF5RCxHQUFHO0FBQzVEO0FBQ0Esb0ZBQW9GLEdBQUc7QUFDdkY7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEdBQUc7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtDQUErQywrQkFBK0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3REFBd0QsY0FBYztBQUN0RTtBQUNBOztBQUVBLDBCQUEwQixNQUFNO0FBQ2hDLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBd0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0RBQWdEO0FBQ3JHO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtCQUErQixTQUFTO0FBQ3hDLCtCQUErQixTQUFTO0FBQ3hDLGlDQUFpQyxTQUFTO0FBQzFDLCtCQUErQixTQUFTO0FBQ3hDLGlDQUFpQyxTQUFTLGlCQUFpQixRQUFRO0FBQ25FO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUEseUNBQXlDLGNBQWM7O0FBRXZEOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixzQ0FBc0Msb0JBQW9CO0FBQzNFOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsNkRBQTZELGlCQUFpQjtBQUMzRiIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2FsdGVybmF0aXZlcy5qcz8xNmNjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL21lcmdlJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYWx0ZXJuYXRpdmVzJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgbWF0Y2g6IHsgZGVmYXVsdDogJ2FueScgfSAgICAgICAgICAgICAgICAgLy8gJ2FueScsICdvbmUnLCAnYWxsJ1xuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIG1hdGNoZXM6IHsgaW5pdDogW10sIHJlZ2lzdGVyOiBSZWYudG9TaWJsaW5nIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIC4uLnNjaGVtYXMpIHtcblxuICAgICAgICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NoZW1hLnRyeSguLi5zY2hlbWFzKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgICAgICAvLyBNYXRjaCBhbGwgb3Igb25lXG5cbiAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MubWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLiRfdGVybXMubWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubmVzdChpdGVtLnNjaGVtYSwgYG1hdGNoLiR7aX1gKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLnNjaGVtYS4kX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkLnB1c2gocmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZmFpbGVkLm1hcCgoZikgPT4gRXJyb3JzLmRldGFpbHMoZiwgeyBvdmVycmlkZTogZmFsc2UgfSkpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknLCBjb250ZXh0KSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYXRjaCBvbmVcblxuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MubWF0Y2ggPT09ICdvbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoID09PSAxID8geyB2YWx1ZTogbWF0Y2hlZFswXSB9IDogeyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMub25lJykgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggYWxsXG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCAhPT0gc2NoZW1hLiRfdGVybXMubWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBmYWlsZWQubWFwKChmKSA9PiBFcnJvcnMuZGV0YWlscyhmLCB7IG92ZXJyaWRlOiBmYWxzZSB9KSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLmFsbCcsIGNvbnRleHQpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlzQW55T2JqID0gKGFsdGVybmF0aXZlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRpdmUuJF90ZXJtcy5tYXRjaGVzLnNvbWUoKHYpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5zY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh2LnNjaGVtYS50eXBlID09PSAnYWx0ZXJuYXRpdmVzJyAmJiBpc0FueU9iaih2LnNjaGVtYSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzQW55T2JqKHNjaGVtYSkgPyB7IHZhbHVlOiBtYXRjaGVkLnJlZHVjZSgoYWNjLCB2KSA9PiBNZXJnZShhY2MsIHYsIHsgbWVyZ2VBcnJheXM6IGZhbHNlIH0pKSB9IDogeyB2YWx1ZTogbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXRjaCBhbnlcblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLiRfdGVybXMubWF0Y2hlc1tpXTtcblxuICAgICAgICAgICAgLy8gVHJ5XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5uZXN0KGl0ZW0uc2NoZW1hLCBgbWF0Y2guJHtpfWApO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uc2NoZW1hLiRfdmFsaWRhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5jb21taXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHNjaGVtYTogaXRlbS5zY2hlbWEsIHJlcG9ydHM6IHJlc3VsdC5lcnJvcnMgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbmRpdGlvbmFsXG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gaXRlbS5yZWYgPyBpdGVtLnJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIDogdmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IGl0ZW0uaXMgPyBbaXRlbV0gOiBpdGVtLnN3aXRjaDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzLCB0aGVuLCBvdGhlcndpc2UgfSA9IHRlc3Q7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGBtYXRjaC4ke2l9JHtpdGVtLnN3aXRjaCA/ICcuJyArIGogOiAnJ31gO1xuICAgICAgICAgICAgICAgIGlmICghaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7aWR9LmlzYCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXJ3aXNlLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3Qob3RoZXJ3aXNlLCBgJHtpZH0ub3RoZXJ3aXNlYCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGVuLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3QodGhlbiwgYCR7aWR9LnRoZW5gKSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3JzKGVycm9ycywgaGVscGVycyk7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29uZGl0aW9uYWw6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MuX2VuZGVkU3dpdGNoLCAnVW5yZWFjaGFibGUgY29uZGl0aW9uJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9mbGFncy5tYXRjaCwgJ0Nhbm5vdCBjb21iaW5lIG1hdGNoIG1vZGUnLCB0aGlzLl9mbGFncy5tYXRjaCwgJ3dpdGggY29uZGl0aW9uYWwgcnVsZScpO1xuICAgICAgICAgICAgICAgIEFzc2VydChvcHRpb25zLmJyZWFrID09PSB1bmRlZmluZWQsICdDYW5ub3QgdXNlIGJyZWFrIG9wdGlvbiB3aXRoIGFsdGVybmF0aXZlcyBjb25kaXRpb25hbCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21waWxlLndoZW4ob2JqLCBjb25kaXRpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBtYXRjaC5pcyA/IFttYXRjaF0gOiBtYXRjaC5zd2l0Y2g7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGhlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vdGhlcndpc2UpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRfc2V0RmxhZygnX2VuZGVkU3dpdGNoJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXRjaDoge1xuICAgICAgICAgICAgbWV0aG9kKG1vZGUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2FueScsICdvbmUnLCAnYWxsJ10uaW5jbHVkZXMobW9kZSksICdJbnZhbGlkIGFsdGVybmF0aXZlcyBtYXRjaCBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPT0gJ2FueScpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiB0aGlzLiRfdGVybXMubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KG1hdGNoLnNjaGVtYSwgJ0Nhbm5vdCBjb21iaW5lIG1hdGNoIG1vZGUnLCBtb2RlLCAnd2l0aCBjb25kaXRpb25hbCBydWxlcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdtYXRjaCcsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWFzLmxlbmd0aCwgJ01pc3NpbmcgYWx0ZXJuYXRpdmUgc2NoZW1hcycpO1xuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICd0cnknKTtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MuX2VuZGVkU3dpdGNoLCAnVW5yZWFjaGFibGUgY29uZGl0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXRjaGVzLnB1c2goeyBzY2hlbWE6IG9iai4kX2NvbXBpbGUoc2NoZW1hKSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG92ZXJyaWRlczoge1xuXG4gICAgICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX3BhcmVudCgnbGFiZWwnLCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgc291cmNlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnBhdGhbMF0gIT09ICdpcycgJiYgdHlwZW9mIGl0ZW0uX2ZsYWdzLmxhYmVsICE9PSAnc3RyaW5nJyA/IGl0ZW0ubGFiZWwobmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gb2JqLiRfbW9kaWZ5KHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWJ1aWxkKHNjaGVtYSkge1xuXG4gICAgICAgIC8vIEZsYWcgd2hlbiBhbiBhbHRlcm5hdGl2ZSB0eXBlIGlzIGFuIGFycmF5XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoaXRlbSkgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09ICdhcnJheScpIHtcblxuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3NldEZsYWcoJ19hcnJheUl0ZW1zJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NoZW1hLiRfbW9kaWZ5KHsgZWFjaCB9KTtcbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZGVzYy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCByZWYsIGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnkoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChyZWYsIHsgaXMsIHRoZW4sIG5vdCwgb3RoZXJ3aXNlLCBzd2l0Y2g6IG1hdGNoLnN3aXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChpcywgeyB0aGVuLCBvdGhlcndpc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbGwnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbGwgb2YgdGhlIHJlcXVpcmVkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbnknOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYWx0ZXJuYXRpdmVzLm1hdGNoJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5vbmUnOiAne3sjbGFiZWx9fSBtYXRjaGVzIG1vcmUgdGhhbiBvbmUgYWxsb3dlZCB0eXBlJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy50eXBlcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgb25lIG9mIHt7I3R5cGVzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZXJyb3JzID0gZnVuY3Rpb24gKGZhaWx1cmVzLCB7IGVycm9yLCBzdGF0ZSB9KSB7XG5cbiAgICAvLyBOb3RoaW5nIG1hdGNoZWQgZHVlIHRvIHR5cGUgY3JpdGVyaWEgcnVsZXNcblxuICAgIGlmICghZmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknKSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBlcnJvclxuXG4gICAgaWYgKGZhaWx1cmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGZhaWx1cmVzWzBdLnJlcG9ydHMgfTtcbiAgICB9XG5cbiAgICAvLyBBbmFseXplIHJlYXNvbnNcblxuICAgIGNvbnN0IHZhbGlkcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBjb21wbGV4ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHsgcmVwb3J0cywgc2NoZW1hIH0gb2YgZmFpbHVyZXMpIHtcblxuICAgICAgICAvLyBNdWx0aXBsZSBlcnJvcnMgKCFhYm9ydEVhcmx5KVxuXG4gICAgICAgIGlmIChyZXBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gZXJyb3JcblxuICAgICAgICBjb25zdCByZXBvcnQgPSByZXBvcnRzWzBdO1xuICAgICAgICBpZiAocmVwb3J0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcm5hbCBvYmplY3Qgb3IgYXJyYXkgZXJyb3JcblxuICAgICAgICBpZiAocmVwb3J0LnN0YXRlLnBhdGgubGVuZ3RoICE9PSBzdGF0ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcGxleC5wdXNoKHsgdHlwZTogc2NoZW1hLnR5cGUsIHJlcG9ydCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRzXG5cbiAgICAgICAgaWYgKHJlcG9ydC5jb2RlID09PSAnYW55Lm9ubHknKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkIG9mIHJlcG9ydC5sb2NhbC52YWxpZHMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZHMuYWRkKHZhbGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlIHR5cGVcblxuICAgICAgICBjb25zdCBbdHlwZSwgY29kZV0gPSByZXBvcnQuY29kZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY29kZSAhPT0gJ2Jhc2UnKSB7XG4gICAgICAgICAgICBjb21wbGV4LnB1c2goeyB0eXBlOiBzY2hlbWEudHlwZSwgcmVwb3J0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcG9ydC5jb2RlID09PSAnb2JqZWN0LmJhc2UnKSB7XG4gICAgICAgICAgICB2YWxpZHMuYWRkKHJlcG9ydC5sb2NhbC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkcy5hZGQodHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGwgZXJyb3JzIGFyZSBiYXNlIHR5cGVzIG9yIHZhbGlkc1xuXG4gICAgaWYgKCFjb21wbGV4Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMudHlwZXMnLCB7IHR5cGVzOiBbLi4udmFsaWRzXSB9KSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBjb21wbGV4IGVycm9yXG5cbiAgICBpZiAoY29tcGxleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBjb21wbGV4WzBdLnJlcG9ydCB9O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG59O1xuXG5cbmludGVybmFscy51bm1hdGNoZWQgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIGVycm9yKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZmFpbHVyZS5yZXBvcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMubWF0Y2gnLCBFcnJvcnMuZGV0YWlscyhlcnJvcnMsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pKSB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/alternatives.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/any.js":
/*!*******************************************!*\
  !*** ./node_modules/joi/lib/types/any.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Base = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/joi/lib/base.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ../messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Base.extend({\n\n    type: 'any',\n\n    flags: {\n\n        only: { default: false }\n    },\n\n    terms: {\n\n        alterations: { init: null },\n        examples: { init: null },\n        externals: { init: null },\n        metas: { init: [] },\n        notes: { init: [] },\n        shared: { init: null },\n        tags: { init: [] },\n        whens: { init: null }\n    },\n\n    rules: {\n\n        custom: {\n            method(method, description) {\n\n                Assert(typeof method === 'function', 'Method must be a function');\n                Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');\n\n                return this.$_addRule({ name: 'custom', args: { method, description } });\n            },\n            validate(value, helpers, { method }) {\n\n                try {\n                    return method(value, helpers);\n                }\n                catch (err) {\n                    return helpers.error('any.custom', { error: err });\n                }\n            },\n            args: ['method', 'description'],\n            multi: true\n        },\n\n        messages: {\n            method(messages) {\n\n                return this.prefs({ messages });\n            }\n        },\n\n        shared: {\n            method(schema) {\n\n                Assert(Common.isSchema(schema) && schema._flags.id, 'Schema must be a schema with an id');\n\n                const obj = this.clone();\n                obj.$_terms.shared = obj.$_terms.shared || [];\n                obj.$_terms.shared.push(schema);\n                obj.$_mutateRegister(schema);\n                return obj;\n            }\n        },\n\n        warning: {\n            method(code, local) {\n\n                Assert(code && typeof code === 'string', 'Invalid warning code');\n\n                return this.$_addRule({ name: 'warning', args: { code, local }, warn: true });\n            },\n            validate(value, helpers, { code, local }) {\n\n                return helpers.error(code, local);\n            },\n            args: ['code', 'local'],\n            multi: true\n        }\n    },\n\n    modifiers: {\n\n        keep(rule, enabled = true) {\n\n            rule.keep = enabled;\n        },\n\n        message(rule, message) {\n\n            rule.message = Messages.compile(message);\n        },\n\n        warn(rule, enabled = true) {\n\n            rule.warn = enabled;\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            for (const key in desc) {\n                const values = desc[key];\n\n                if (['examples', 'externals', 'metas', 'notes', 'tags'].includes(key)) {\n                    for (const value of values) {\n                        obj = obj[key.slice(0, -1)](value);\n                    }\n\n                    continue;\n                }\n\n                if (key === 'alterations') {\n                    const alter = {};\n                    for (const { target, adjuster } of values) {\n                        alter[target] = adjuster;\n                    }\n\n                    obj = obj.alter(alter);\n                    continue;\n                }\n\n                if (key === 'whens') {\n                    for (const value of values) {\n                        const { ref, is, not, then, otherwise, concat } = value;\n                        if (concat) {\n                            obj = obj.concat(concat);\n                        }\n                        else if (ref) {\n                            obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });\n                        }\n                        else {\n                            obj = obj.when(is, { then, otherwise, break: value.break });\n                        }\n                    }\n\n                    continue;\n                }\n\n                if (key === 'shared') {\n                    for (const value of values) {\n                        obj = obj.shared(value);\n                    }\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'any.custom': '{{#label}} failed custom validation because {{#error.message}}',\n        'any.default': '{{#label}} threw an error when running default method',\n        'any.failover': '{{#label}} threw an error when running failover method',\n        'any.invalid': '{{#label}} contains an invalid value',\n        'any.only': '{{#label}} must be {if(#valids.length == 1, \"\", \"one of \")}{{#valids}}',\n        'any.ref': '{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}',\n        'any.required': '{{#label}} is required',\n        'any.unknown': '{{#label}} is not allowed'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1Qjs7QUFFOUMsYUFBYSxtQkFBTyxDQUFDLHFEQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyx5REFBVztBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyw2REFBYTs7O0FBR3RDOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDs7QUFFQSx1QkFBdUIsWUFBWTtBQUNuQyxvQkFBb0IsWUFBWTtBQUNoQyxxQkFBcUIsWUFBWTtBQUNqQyxpQkFBaUIsVUFBVTtBQUMzQixpQkFBaUIsVUFBVTtBQUMzQixrQkFBa0IsWUFBWTtBQUM5QixnQkFBZ0IsVUFBVTtBQUMxQixpQkFBaUI7QUFDakIsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHdCQUF3Qix1QkFBdUI7QUFDdkYsYUFBYTtBQUNiLHVDQUF1QyxRQUFROztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsb0NBQW9DLFVBQVU7QUFDOUM7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLHdDQUF3Qyx5QkFBeUIsYUFBYSxjQUFjO0FBQzVGLGFBQWE7QUFDYix1Q0FBdUMsYUFBYTs7QUFFcEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLHdDQUF3QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvRUFBb0U7QUFDdEg7QUFDQTtBQUNBLGlEQUFpRCxxQ0FBcUM7QUFDdEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QixTQUFTLG1DQUFtQyxnQkFBZ0I7QUFDckYsMEJBQTBCLFNBQVM7QUFDbkMsMkJBQTJCLFNBQVM7QUFDcEMsMEJBQTBCLFNBQVM7QUFDbkMsdUJBQXVCLFNBQVMsU0FBUyx5Q0FBeUMsU0FBUztBQUMzRixzQkFBc0IsV0FBVyxPQUFPLGFBQWEsUUFBUSxRQUFRLFNBQVM7QUFDOUUsMkJBQTJCLFNBQVM7QUFDcEMsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYW55LmpzP2MwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuLi9tZXNzYWdlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FueScsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG9ubHk6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGFsdGVyYXRpb25zOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgZXhhbXBsZXM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBleHRlcm5hbHM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBtZXRhczogeyBpbml0OiBbXSB9LFxuICAgICAgICBub3RlczogeyBpbml0OiBbXSB9LFxuICAgICAgICBzaGFyZWQ6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICB0YWdzOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIHdoZW5zOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgbWV0aG9kKG1ldGhvZCwgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGRlc2NyaXB0aW9uICYmIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2N1c3RvbScsIGFyZ3M6IHsgbWV0aG9kLCBkZXNjcmlwdGlvbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG1ldGhvZCB9KSB7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYW55LmN1c3RvbScsIHsgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydtZXRob2QnLCAnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChtZXNzYWdlcykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZnMoeyBtZXNzYWdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaGFyZWQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSAmJiBzY2hlbWEuX2ZsYWdzLmlkLCAnU2NoZW1hIG11c3QgYmUgYSBzY2hlbWEgd2l0aCBhbiBpZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnNoYXJlZCA9IG9iai4kX3Rlcm1zLnNoYXJlZCB8fCBbXTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5zaGFyZWQucHVzaChzY2hlbWEpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3YXJuaW5nOiB7XG4gICAgICAgICAgICBtZXRob2QoY29kZSwgbG9jYWwpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChjb2RlICYmIHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJywgJ0ludmFsaWQgd2FybmluZyBjb2RlJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnd2FybmluZycsIGFyZ3M6IHsgY29kZSwgbG9jYWwgfSwgd2FybjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBjb2RlLCBsb2NhbCB9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihjb2RlLCBsb2NhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydjb2RlJywgJ2xvY2FsJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vZGlmaWVyczoge1xuXG4gICAgICAgIGtlZXAocnVsZSwgZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgcnVsZS5rZWVwID0gZW5hYmxlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXNzYWdlKHJ1bGUsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgcnVsZS5tZXNzYWdlID0gTWVzc2FnZXMuY29tcGlsZShtZXNzYWdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3YXJuKHJ1bGUsIGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUud2FybiA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGRlc2Nba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2V4YW1wbGVzJywgJ2V4dGVybmFscycsICdtZXRhcycsICdub3RlcycsICd0YWdzJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2tleS5zbGljZSgwLCAtMSldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdhbHRlcmF0aW9ucycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx0ZXIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgYWRqdXN0ZXIgfSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVyW3RhcmdldF0gPSBhZGp1c3RlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5hbHRlcihhbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd3aGVucycpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVmLCBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UsIGNvbmNhdCB9ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uY2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLmNvbmNhdChjb25jYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLndoZW4ocmVmLCB7IGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSwgc3dpdGNoOiB2YWx1ZS5zd2l0Y2gsIGJyZWFrOiB2YWx1ZS5icmVhayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai53aGVuKGlzLCB7IHRoZW4sIG90aGVyd2lzZSwgYnJlYWs6IHZhbHVlLmJyZWFrIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5zaGFyZWQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhbnkuY3VzdG9tJzogJ3t7I2xhYmVsfX0gZmFpbGVkIGN1c3RvbSB2YWxpZGF0aW9uIGJlY2F1c2Uge3sjZXJyb3IubWVzc2FnZX19JyxcbiAgICAgICAgJ2FueS5kZWZhdWx0JzogJ3t7I2xhYmVsfX0gdGhyZXcgYW4gZXJyb3Igd2hlbiBydW5uaW5nIGRlZmF1bHQgbWV0aG9kJyxcbiAgICAgICAgJ2FueS5mYWlsb3Zlcic6ICd7eyNsYWJlbH19IHRocmV3IGFuIGVycm9yIHdoZW4gcnVubmluZyBmYWlsb3ZlciBtZXRob2QnLFxuICAgICAgICAnYW55LmludmFsaWQnOiAne3sjbGFiZWx9fSBjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlJyxcbiAgICAgICAgJ2FueS5vbmx5JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB7aWYoI3ZhbGlkcy5sZW5ndGggPT0gMSwgXCJcIiwgXCJvbmUgb2YgXCIpfXt7I3ZhbGlkc319JyxcbiAgICAgICAgJ2FueS5yZWYnOiAne3sjbGFiZWx9fSB7eyNhcmd9fSByZWZlcmVuY2VzIHt7OiNyZWZ9fSB3aGljaCB7eyNyZWFzb259fScsXG4gICAgICAgICdhbnkucmVxdWlyZWQnOiAne3sjbGFiZWx9fSBpcyByZXF1aXJlZCcsXG4gICAgICAgICdhbnkudW5rbm93bic6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkJ1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/any.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/array.js":
/*!*********************************************!*\
  !*** ./node_modules/joi/lib/types/array.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"(rsc)/./node_modules/@hapi/hoek/lib/deepEqual.js\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"(rsc)/./node_modules/@hapi/hoek/lib/reach.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'array',\n\n    flags: {\n\n        single: { default: false },\n        sparse: { default: false }\n    },\n\n    terms: {\n\n        items: { init: [], manifest: 'schema' },\n        ordered: { init: [], manifest: 'schema' },\n\n        _exclusions: { init: [] },\n        _inclusions: { init: [] },\n        _requireds: { init: [] }\n    },\n\n    coerce: {\n        from: 'object',\n        method(value, { schema, state, prefs }) {\n\n            if (!Array.isArray(value)) {\n                return;\n            }\n\n            const sort = schema.$_getRule('sort');\n            if (!sort) {\n                return;\n            }\n\n            return internals.sort(schema, value, sort.args.options, state, prefs);\n        }\n    },\n\n    validate(value, { schema, error }) {\n\n        if (!Array.isArray(value)) {\n            if (schema._flags.single) {\n                const single = [value];\n                single[Common.symbols.arraySingle] = true;\n                return { value: single };\n            }\n\n            return { errors: error('array.base') };\n        }\n\n        if (!schema.$_getRule('items') &&\n            !schema.$_terms.externals) {\n\n            return;\n        }\n\n        return { value: value.slice() };        // Clone the array so that we don't modify the original\n    },\n\n    rules: {\n\n        has: {\n            method(schema) {\n\n                schema = this.$_compile(schema, { appendPath: true });\n                const obj = this.$_addRule({ name: 'has', args: { schema } });\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate(value, { state, prefs, error }, { schema: has }) {\n\n                const ancestors = [value, ...state.ancestors];\n                for (let i = 0; i < value.length; ++i) {\n                    const localState = state.localize([...state.path, i], ancestors, has);\n                    if (has.$_match(value[i], localState, prefs)) {\n                        return value;\n                    }\n                }\n\n                const patternLabel = has._flags.label;\n                if (patternLabel) {\n                    return error('array.hasKnown', { patternLabel });\n                }\n\n                return error('array.hasUnknown', null);\n            },\n            multi: true\n        },\n\n        items: {\n            method(...schemas) {\n\n                Common.verifyFlat(schemas, 'items');\n\n                const obj = this.$_addRule('items');\n\n                for (let i = 0; i < schemas.length; ++i) {\n                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });\n                    obj.$_terms.items.push(type);\n                }\n\n                return obj.$_mutateRebuild();\n            },\n            validate(value, { schema, error, state, prefs, errorsArray }) {\n\n                const requireds = schema.$_terms._requireds.slice();\n                const ordereds = schema.$_terms.ordered.slice();\n                const inclusions = [...schema.$_terms._inclusions, ...requireds];\n\n                const wasArray = !value[Common.symbols.arraySingle];\n                delete value[Common.symbols.arraySingle];\n\n                const errors = errorsArray();\n\n                let il = value.length;\n                for (let i = 0; i < il; ++i) {\n                    const item = value[i];\n\n                    let errored = false;\n                    let isValid = false;\n\n                    const key = wasArray ? i : new Number(i);       // eslint-disable-line no-new-wrappers\n                    const path = [...state.path, key];\n\n                    // Sparse\n\n                    if (!schema._flags.sparse &&\n                        item === undefined) {\n\n                        errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n\n                        ordereds.shift();\n                        continue;\n                    }\n\n                    // Exclusions\n\n                    const ancestors = [value, ...state.ancestors];\n\n                    for (const exclusion of schema.$_terms._exclusions) {\n                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: 'ignore' })) {\n                            continue;\n                        }\n\n                        errors.push(error('array.excludes', { pos: i, value: item }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n\n                        errored = true;\n                        ordereds.shift();\n                        break;\n                    }\n\n                    if (errored) {\n                        continue;\n                    }\n\n                    // Ordered\n\n                    if (schema.$_terms.ordered.length) {\n                        if (ordereds.length) {\n                            const ordered = ordereds.shift();\n                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);\n                            if (!res.errors) {\n                                if (ordered._flags.result === 'strip') {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                }\n                                else if (!schema._flags.sparse && res.value === undefined) {\n                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                    if (prefs.abortEarly) {\n                                        return errors;\n                                    }\n\n                                    continue;\n                                }\n                                else {\n                                    value[i] = res.value;\n                                }\n                            }\n                            else {\n                                errors.push(...res.errors);\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n\n                            continue;\n                        }\n                        else if (!schema.$_terms.items.length) {\n                            errors.push(error('array.orderedLength', { pos: i, limit: schema.$_terms.ordered.length }));\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n\n                            break;      // No reason to continue since there are no other rules to validate other than array.orderedLength\n                        }\n                    }\n\n                    // Requireds\n\n                    const requiredChecks = [];\n                    let jl = requireds.length;\n                    for (let j = 0; j < jl; ++j) {\n                        const localState = state.localize(path, ancestors, requireds[j]);\n                        localState.snapshot();\n\n                        const res = requireds[j].$_validate(item, localState, prefs);\n                        requiredChecks[j] = res;\n\n                        if (!res.errors) {\n                            localState.commit();\n                            value[i] = res.value;\n                            isValid = true;\n                            internals.fastSplice(requireds, j);\n                            --j;\n                            --jl;\n\n                            if (!schema._flags.sparse &&\n                                res.value === undefined) {\n\n                                errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n\n                            break;\n                        }\n\n                        localState.restore();\n                    }\n\n                    if (isValid) {\n                        continue;\n                    }\n\n                    // Inclusions\n\n                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;\n\n                    jl = inclusions.length;\n                    for (const inclusion of inclusions) {\n\n                        // Avoid re-running requireds that already didn't match in the previous loop\n\n                        let res;\n                        const previousCheck = requireds.indexOf(inclusion);\n                        if (previousCheck !== -1) {\n                            res = requiredChecks[previousCheck];\n                        }\n                        else {\n                            const localState = state.localize(path, ancestors, inclusion);\n                            localState.snapshot();\n\n                            res = inclusion.$_validate(item, localState, prefs);\n                            if (!res.errors) {\n                                localState.commit();\n                                if (inclusion._flags.result === 'strip') {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                }\n                                else if (!schema._flags.sparse &&\n                                    res.value === undefined) {\n\n                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                    errored = true;\n                                }\n                                else {\n                                    value[i] = res.value;\n                                }\n\n                                isValid = true;\n                                break;\n                            }\n\n                            localState.restore();\n                        }\n\n                        // Return the actual error if only one inclusion defined\n\n                        if (jl === 1) {\n                            if (stripUnknown) {\n                                internals.fastSplice(value, i);\n                                --i;\n                                --il;\n                                isValid = true;\n                                break;\n                            }\n\n                            errors.push(...res.errors);\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n\n                            errored = true;\n                            break;\n                        }\n                    }\n\n                    if (errored) {\n                        continue;\n                    }\n\n                    if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) &&\n                        !isValid) {\n\n                        if (stripUnknown) {\n                            internals.fastSplice(value, i);\n                            --i;\n                            --il;\n                            continue;\n                        }\n\n                        errors.push(error('array.includes', { pos: i, value: item }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n                    }\n                }\n\n                if (requireds.length) {\n                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);\n                }\n\n                if (ordereds.length) {\n                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);\n\n                    if (!errors.length) {\n                        internals.fillDefault(ordereds, value, state, prefs);\n                    }\n                }\n\n                return errors.length ? errors : value;\n            },\n\n            priority: true,\n            manifest: false\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('array.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        },\n\n        ordered: {\n            method(...schemas) {\n\n                Common.verifyFlat(schemas, 'ordered');\n\n                const obj = this.$_addRule('items');\n\n                for (let i = 0; i < schemas.length; ++i) {\n                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });\n                    internals.validateSingle(type, obj);\n\n                    obj.$_mutateRegister(type);\n                    obj.$_terms.ordered.push(type);\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        single: {\n            method(enabled) {\n\n                const value = enabled === undefined ? true : !!enabled;\n                Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');\n\n                return this.$_setFlag('single', value);\n            }\n        },\n\n        sort: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['by', 'order']);\n\n                const settings = {\n                    order: options.order || 'ascending'\n                };\n\n                if (options.by) {\n                    settings.by = Compile.ref(options.by, { ancestor: 0 });\n                    Assert(!settings.by.ancestor, 'Cannot sort by ancestor');\n                }\n\n                return this.$_addRule({ name: 'sort', args: { options: settings } });\n            },\n            validate(value, { error, state, prefs, schema }, { options }) {\n\n                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);\n                if (errors) {\n                    return errors;\n                }\n\n                for (let i = 0; i < value.length; ++i) {\n                    if (value[i] !== sorted[i]) {\n                        return error('array.sort', { order: options.order, by: options.by ? options.by.key : 'value' });\n                    }\n                }\n\n                return value;\n            },\n            convert: true\n        },\n\n        sparse: {\n            method(enabled) {\n\n                const value = enabled === undefined ? true : !!enabled;\n\n                if (this._flags.sparse === value) {\n                    return this;\n                }\n\n                const obj = value ? this.clone() : this.$_addRule('items');\n                return obj.$_setFlag('sparse', value, { clone: false });\n            }\n        },\n\n        unique: {\n            method(comparator, options = {}) {\n\n                Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n                Common.assertOptions(options, ['ignoreUndefined', 'separator']);\n\n                const rule = { name: 'unique', args: { options, comparator } };\n\n                if (comparator) {\n                    if (typeof comparator === 'string') {\n                        const separator = Common.default(options.separator, '.');\n                        rule.path = separator ? comparator.split(separator) : [comparator];\n                    }\n                    else {\n                        rule.comparator = comparator;\n                    }\n                }\n\n                return this.$_addRule(rule);\n            },\n            validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {\n\n                const found = {\n                    string: Object.create(null),\n                    number: Object.create(null),\n                    undefined: Object.create(null),\n                    boolean: Object.create(null),\n                    bigint: Object.create(null),\n                    object: new Map(),\n                    function: new Map(),\n                    custom: new Map()\n                };\n\n                const compare = comparator || DeepEqual;\n                const ignoreUndefined = options.ignoreUndefined;\n\n                for (let i = 0; i < value.length; ++i) {\n                    const item = path ? Reach(value[i], path) : value[i];\n                    const records = comparator ? found.custom : found[typeof item];\n                    Assert(records, 'Failed to find unique map container for type', typeof item);\n\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (path) {\n                                    context.path = raw;\n                                }\n\n                                return error('array.unique', context, localState);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if ((!ignoreUndefined || item !== undefined) &&\n                            records[item] !== undefined) {\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (path) {\n                                context.path = raw;\n                            }\n\n                            const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                            return error('array.unique', context, localState);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n\n                return value;\n            },\n            args: ['comparator', 'options'],\n            multi: true\n        }\n    },\n\n    cast: {\n        set: {\n            from: Array.isArray,\n            to(value, helpers) {\n\n                return new Set(value);\n            }\n        }\n    },\n\n    rebuild(schema) {\n\n        schema.$_terms._inclusions = [];\n        schema.$_terms._exclusions = [];\n        schema.$_terms._requireds = [];\n\n        for (const type of schema.$_terms.items) {\n            internals.validateSingle(type, schema);\n\n            if (type._flags.presence === 'required') {\n                schema.$_terms._requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                schema.$_terms._exclusions.push(type);\n            }\n            else {\n                schema.$_terms._inclusions.push(type);\n            }\n        }\n\n        for (const type of schema.$_terms.ordered) {\n            internals.validateSingle(type, schema);\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.items) {\n                obj = obj.items(...desc.items);\n            }\n\n            if (desc.ordered) {\n                obj = obj.ordered(...desc.ordered);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'array.base': '{{#label}} must be an array',\n        'array.excludes': '{{#label}} contains an excluded value',\n        'array.hasKnown': '{{#label}} does not contain at least one required match for type {:#patternLabel}',\n        'array.hasUnknown': '{{#label}} does not contain at least one required match',\n        'array.includes': '{{#label}} does not match any of the allowed types',\n        'array.includesRequiredBoth': '{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',\n        'array.includesRequiredKnowns': '{{#label}} does not contain {{#knownMisses}}',\n        'array.includesRequiredUnknowns': '{{#label}} does not contain {{#unknownMisses}} required value(s)',\n        'array.length': '{{#label}} must contain {{#limit}} items',\n        'array.max': '{{#label}} must contain less than or equal to {{#limit}} items',\n        'array.min': '{{#label}} must contain at least {{#limit}} items',\n        'array.orderedLength': '{{#label}} must contain at most {{#limit}} items',\n        'array.sort': '{{#label}} must be sorted in {#order} order by {{#by}}',\n        'array.sort.mismatching': '{{#label}} cannot be sorted due to mismatching types',\n        'array.sort.unsupported': '{{#label}} cannot be sorted due to unsupported type {#type}',\n        'array.sparse': '{{#label}} must not be a sparse array item',\n        'array.unique': '{{#label}} contains a duplicate value'\n    }\n});\n\n\n// Helpers\n\ninternals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {\n\n    const knownMisses = [];\n    let unknownMisses = 0;\n    for (const required of requireds) {\n        const label = required._flags.label;\n        if (label) {\n            knownMisses.push(label);\n        }\n        else {\n            ++unknownMisses;\n        }\n    }\n\n    if (knownMisses.length) {\n        if (unknownMisses) {\n            errors.push(schema.$_createError('array.includesRequiredBoth', value, { knownMisses, unknownMisses }, state, prefs));\n        }\n        else {\n            errors.push(schema.$_createError('array.includesRequiredKnowns', value, { knownMisses }, state, prefs));\n        }\n    }\n    else {\n        errors.push(schema.$_createError('array.includesRequiredUnknowns', value, { unknownMisses }, state, prefs));\n    }\n};\n\n\ninternals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {\n\n    const requiredOrdereds = [];\n\n    for (const ordered of ordereds) {\n        if (ordered._flags.presence === 'required') {\n            requiredOrdereds.push(ordered);\n        }\n    }\n\n    if (requiredOrdereds.length) {\n        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);\n    }\n};\n\n\ninternals.fillDefault = function (ordereds, value, state, prefs) {\n\n    const overrides = [];\n    let trailingUndefined = true;\n\n    for (let i = ordereds.length - 1; i >= 0; --i) {\n        const ordered = ordereds[i];\n        const ancestors = [value, ...state.ancestors];\n        const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;\n\n        if (trailingUndefined) {\n            if (override === undefined) {\n                continue;\n            }\n\n            trailingUndefined = false;\n        }\n\n        overrides.unshift(override);\n    }\n\n    if (overrides.length) {\n        value.push(...overrides);\n    }\n};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.validateSingle = function (type, obj) {\n\n    if (type.type === 'array' ||\n        type._flags._arrayItems) {\n\n        Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');\n        obj.$_setFlag('_arrayItems', true, { clone: false });\n    }\n};\n\n\ninternals.sort = function (schema, value, settings, state, prefs) {\n\n    const order = settings.order === 'ascending' ? 1 : -1;\n    const aFirst = -1 * order;\n    const bFirst = order;\n\n    const sort = (a, b) => {\n\n        let compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n\n        if (settings.by) {\n            a = settings.by.resolve(a, state, prefs);\n            b = settings.by.resolve(b, state, prefs);\n        }\n\n        compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n\n        const type = typeof a;\n        if (type !== typeof b) {\n            throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);\n        }\n\n        if (type !== 'number' &&\n            type !== 'string') {\n\n            throw schema.$_createError('array.sort.unsupported', value, { type }, state, prefs);\n        }\n\n        if (type === 'number') {\n            return (a - b) * order;\n        }\n\n        return a < b ? aFirst : bFirst;\n    };\n\n    try {\n        return { value: value.slice().sort(sort) };\n    }\n    catch (err) {\n        return { errors: err };\n    }\n};\n\n\ninternals.compare = function (a, b, aFirst, bFirst) {\n\n    if (a === b) {\n        return 0;\n    }\n\n    if (a === undefined) {\n        return 1;           // Always last regardless of sort order\n    }\n\n    if (b === undefined) {\n        return -1;           // Always last regardless of sort order\n    }\n\n    if (a === null) {\n        return bFirst;\n    }\n\n    if (b === null) {\n        return aFirst;\n    }\n\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsNEVBQXVCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLGtGQUEwQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsMEVBQXNCOztBQUU1QyxZQUFZLG1CQUFPLENBQUMsd0RBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHlEQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFZOzs7QUFHcEM7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEMsa0JBQWtCO0FBQ2xCLEtBQUs7O0FBRUw7O0FBRUEsaUJBQWlCLDhCQUE4QjtBQUMvQyxtQkFBbUIsOEJBQThCOztBQUVqRCx1QkFBdUIsVUFBVTtBQUNqQyx1QkFBdUIsVUFBVTtBQUNqQyxzQkFBc0I7QUFDdEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNCQUFzQixlQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwrQkFBK0I7QUFDaEQsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRCxrQkFBa0I7QUFDcEUsNkNBQTZDLHFCQUFxQixVQUFVO0FBQzVFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsOEJBQThCLHFCQUFxQixJQUFJLGFBQWE7O0FBRXBFO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELDJGQUEyRixjQUFjO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsOEJBQThCLDBDQUEwQzs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBLG9FQUFvRTtBQUNwRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RCxxQ0FBcUM7QUFDakc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDBHQUEwRyxvQkFBb0I7QUFDOUg7QUFDQTs7QUFFQSw4REFBOEQscUJBQXFCO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxxQ0FBcUM7QUFDN0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsOENBQThDO0FBQ3JIO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FLHFDQUFxQztBQUN6RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3RUFBd0UscUNBQXFDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELHFCQUFxQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHdDQUF3Qyx3QkFBd0IsT0FBTyxpQkFBaUI7QUFDeEYsYUFBYTtBQUNiLHVDQUF1QyxPQUFPLElBQUksc0JBQXNCOztBQUV4RTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELDBCQUEwQjtBQUNsRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSx3Q0FBd0MsdUNBQXVDLE9BQU8sa0JBQWtCO0FBQ3hHO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHdDQUF3Qyx1Q0FBdUMsT0FBTyxrQkFBa0I7QUFDeEc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLG9CQUFvQjtBQUNwRCwyRkFBMkYsY0FBYztBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsYUFBYTtBQUN6RTtBQUNBOztBQUVBLHdDQUF3QyxzQkFBc0IscUJBQXFCO0FBQ25GLGFBQWE7QUFDYiw4QkFBOEIsNkJBQTZCLElBQUksU0FBUzs7QUFFeEUsd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBLHFEQUFxRCxpRUFBaUU7QUFDdEg7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsY0FBYztBQUN0RTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUEsK0JBQStCLHdCQUF3Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLDhCQUE4QixzQkFBc0IsSUFBSSwwQkFBMEIsSUFBSSxrQkFBa0I7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDLDZCQUE2QixTQUFTO0FBQ3RDLDZCQUE2QixTQUFTLHVEQUF1RCxlQUFlO0FBQzVHLCtCQUErQixTQUFTO0FBQ3hDLDZCQUE2QixTQUFTO0FBQ3RDLHlDQUF5QyxTQUFTLG1CQUFtQixlQUFlLE1BQU0saUJBQWlCO0FBQzNHLDJDQUEyQyxTQUFTLG1CQUFtQixjQUFjO0FBQ3JGLDZDQUE2QyxTQUFTLG1CQUFtQixpQkFBaUI7QUFDMUYsMkJBQTJCLFNBQVMsZUFBZSxTQUFTO0FBQzVELHdCQUF3QixTQUFTLHFDQUFxQyxTQUFTO0FBQy9FLHdCQUF3QixTQUFTLHdCQUF3QixTQUFTO0FBQ2xFLGtDQUFrQyxTQUFTLHVCQUF1QixTQUFTO0FBQzNFLHlCQUF5QixTQUFTLG1CQUFtQixRQUFRLFdBQVcsS0FBSztBQUM3RSxxQ0FBcUMsU0FBUztBQUM5QyxxQ0FBcUMsU0FBUywwQ0FBMEMsTUFBTTtBQUM5RiwyQkFBMkIsU0FBUztBQUNwQywyQkFBMkIsU0FBUztBQUNwQztBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixlQUFlO0FBQ25HO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBFQUEwRSxNQUFNO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2FycmF5LmpzPzY1YjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYXJyYXknLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBzaW5nbGU6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgc3BhcnNlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBpdGVtczogeyBpbml0OiBbXSwgbWFuaWZlc3Q6ICdzY2hlbWEnIH0sXG4gICAgICAgIG9yZGVyZWQ6IHsgaW5pdDogW10sIG1hbmlmZXN0OiAnc2NoZW1hJyB9LFxuXG4gICAgICAgIF9leGNsdXNpb25zOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIF9pbmNsdXNpb25zOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIF9yZXF1aXJlZHM6IHsgaW5pdDogW10gfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ29iamVjdCcsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnQgPSBzY2hlbWEuJF9nZXRSdWxlKCdzb3J0Jyk7XG4gICAgICAgICAgICBpZiAoIXNvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuc29ydChzY2hlbWEsIHZhbHVlLCBzb3J0LmFyZ3Mub3B0aW9ucywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5zaW5nbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaW5nbGUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIHNpbmdsZVtDb21tb24uc3ltYm9scy5hcnJheVNpbmdsZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBzaW5nbGUgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYXJyYXkuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjaGVtYS4kX2dldFJ1bGUoJ2l0ZW1zJykgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLnNsaWNlKCkgfTsgICAgICAgIC8vIENsb25lIHRoZSBhcnJheSBzbyB0aGF0IHdlIGRvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWxcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBoYXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2hhcycsIGFyZ3M6IHsgc2NoZW1hIH0gfSk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IHN0YXRlLCBwcmVmcywgZXJyb3IgfSwgeyBzY2hlbWE6IGhhcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGldLCBhbmNlc3RvcnMsIGhhcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXMuJF9tYXRjaCh2YWx1ZVtpXSwgbG9jYWxTdGF0ZSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTGFiZWwgPSBoYXMuX2ZsYWdzLmxhYmVsO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5oYXNLbm93bicsIHsgcGF0dGVybkxhYmVsIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuaGFzVW5rbm93bicsIG51bGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAnaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKCdpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gdGhpcy4kX2NvbXBpbGUoc2NoZW1hc1tpXSksIGksIHsgYXBwZW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5pdGVtcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgc3RhdGUsIHByZWZzLCBlcnJvcnNBcnJheSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZHMgPSBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZHMgPSBzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5jbHVzaW9ucyA9IFsuLi5zY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucywgLi4ucmVxdWlyZWRzXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHdhc0FycmF5ID0gIXZhbHVlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gZXJyb3JzQXJyYXkoKTtcblxuICAgICAgICAgICAgICAgIGxldCBpbCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gd2FzQXJyYXkgPyBpIDogbmV3IE51bWJlcihpKTsgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFsuLi5zdGF0ZS5wYXRoLCBrZXldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYXJzZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdXNpb25zXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhjbHVzaW9uIG9mIHNjaGVtYS4kX3Rlcm1zLl9leGNsdXNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4Y2x1c2lvbi4kX21hdGNoKGl0ZW0sIHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgZXhjbHVzaW9uKSwgcHJlZnMsIHsgcHJlc2VuY2U6ICdpZ25vcmUnIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5leGNsdWRlcycsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yZGVyZWRcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMub3JkZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkID0gb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBvcmRlcmVkLiRfdmFsaWRhdGUoaXRlbSwgc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBvcmRlcmVkKSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJlZC5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJiByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZW1hLiRfdGVybXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5Lm9yZGVyZWRMZW5ndGgnLCB7IHBvczogaSwgbGltaXQ6IHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQubGVuZ3RoIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgIC8vIE5vIHJlYXNvbiB0byBjb250aW51ZSBzaW5jZSB0aGVyZSBhcmUgbm8gb3RoZXIgcnVsZXMgdG8gdmFsaWRhdGUgb3RoZXIgdGhhbiBhcnJheS5vcmRlcmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXF1aXJlZHNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZENoZWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgamwgPSByZXF1aXJlZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIHJlcXVpcmVkc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHJlcXVpcmVkc1tqXS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ2hlY2tzW2pdID0gcmVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHJlcXVpcmVkcywgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tamw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdXNpb25zXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gcHJlZnMuc3RyaXBVbmtub3duICYmICEhcHJlZnMuc3RyaXBVbmtub3duLmFycmF5cyB8fCBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBqbCA9IGluY2x1c2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluY2x1c2lvbiBvZiBpbmNsdXNpb25zKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIHJlLXJ1bm5pbmcgcmVxdWlyZWRzIHRoYXQgYWxyZWFkeSBkaWRuJ3QgbWF0Y2ggaW4gdGhlIHByZXZpb3VzIGxvb3BcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ2hlY2sgPSByZXF1aXJlZHMuaW5kZXhPZihpbmNsdXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2hlY2sgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVxdWlyZWRDaGVja3NbcHJldmlvdXNDaGVja107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBpbmNsdXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGluY2x1c2lvbi4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5jb21taXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1c2lvbi5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYWN0dWFsIGVycm9yIGlmIG9ubHkgb25lIGluY2x1c2lvbiBkZWZpbmVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqbCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucy5sZW5ndGggfHwgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNWYWxpZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuaW5jbHVkZXMnLCB7IHBvczogaSwgdmFsdWU6IGl0ZW0gfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5maWxsTWlzc2VkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZpbGxPcmRlcmVkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCBvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbERlZmF1bHQob3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgbWFuaWZlc3Q6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUubGVuZ3RoLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYXJyYXkuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvcmRlcmVkOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4uc2NoZW1hcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoc2NoZW1hcywgJ29yZGVyZWQnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKCdpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gdGhpcy4kX2NvbXBpbGUoc2NoZW1hc1tpXSksIGksIHsgYXBwZW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUodHlwZSwgb2JqKTtcblxuICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMub3JkZXJlZC5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2luZ2xlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuICAgICAgICAgICAgICAgIEFzc2VydCghdmFsdWUgfHwgIXRoaXMuX2ZsYWdzLl9hcnJheUl0ZW1zLCAnQ2Fubm90IHNwZWNpZnkgc2luZ2xlIHJ1bGUgd2hlbiBhcnJheSBoYXMgYXJyYXkgaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnc2luZ2xlJywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNvcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYnknLCAnb3JkZXInXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IG9wdGlvbnMub3JkZXIgfHwgJ2FzY2VuZGluZydcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYnkgPSBDb21waWxlLnJlZihvcHRpb25zLmJ5LCB7IGFuY2VzdG9yOiAwIH0pO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXNldHRpbmdzLmJ5LmFuY2VzdG9yLCAnQ2Fubm90IHNvcnQgYnkgYW5jZXN0b3InKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc29ydCcsIGFyZ3M6IHsgb3B0aW9uczogc2V0dGluZ3MgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciwgc3RhdGUsIHByZWZzLCBzY2hlbWEgfSwgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IHNvcnRlZCwgZXJyb3JzIH0gPSBpbnRlcm5hbHMuc29ydChzY2hlbWEsIHZhbHVlLCBvcHRpb25zLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtpXSAhPT0gc29ydGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnNvcnQnLCB7IG9yZGVyOiBvcHRpb25zLm9yZGVyLCBieTogb3B0aW9ucy5ieSA/IG9wdGlvbnMuYnkua2V5IDogJ3ZhbHVlJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BhcnNlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnNwYXJzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdmFsdWUgPyB0aGlzLmNsb25lKCkgOiB0aGlzLiRfYWRkUnVsZSgnaXRlbXMnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfc2V0RmxhZygnc3BhcnNlJywgdmFsdWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuaXF1ZToge1xuICAgICAgICAgICAgbWV0aG9kKGNvbXBhcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFjb21wYXJhdG9yIHx8IHR5cGVvZiBjb21wYXJhdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJywgJ2NvbXBhcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpZ25vcmVVbmRlZmluZWQnLCAnc2VwYXJhdG9yJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHsgbmFtZTogJ3VuaXF1ZScsIGFyZ3M6IHsgb3B0aW9ucywgY29tcGFyYXRvciB9IH07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBDb21tb24uZGVmYXVsdChvcHRpb25zLnNlcGFyYXRvciwgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUucGF0aCA9IHNlcGFyYXRvciA/IGNvbXBhcmF0b3Iuc3BsaXQoc2VwYXJhdG9yKSA6IFtjb21wYXJhdG9yXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUocnVsZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgc3RhdGUsIGVycm9yLCBzY2hlbWEgfSwgeyBjb21wYXJhdG9yOiByYXcsIG9wdGlvbnMgfSwgeyBjb21wYXJhdG9yLCBwYXRoIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0ge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmc6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIG51bWJlcjogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBib29sZWFuOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBiaWdpbnQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b206IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlID0gY29tcGFyYXRvciB8fCBEZWVwRXF1YWw7XG4gICAgICAgICAgICAgICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwYXRoID8gUmVhY2godmFsdWVbaV0sIHBhdGgpIDogdmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZHMgPSBjb21wYXJhdG9yID8gZm91bmQuY3VzdG9tIDogZm91bmRbdHlwZW9mIGl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQocmVjb3JkcywgJ0ZhaWxlZCB0byBmaW5kIHVuaXF1ZSBtYXAgY29udGFpbmVyIGZvciB0eXBlJywgdHlwZW9mIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gcmVjb3Jkcy5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghKGN1cnJlbnQgPSBlbnRyaWVzLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGN1cnJlbnQudmFsdWVbMF0sIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlUG9zOiBjdXJyZW50LnZhbHVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtjdXJyZW50LnZhbHVlWzFdXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSByYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zZXQoaXRlbSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCFpZ25vcmVVbmRlZmluZWQgfHwgaXRlbSAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHNbaXRlbV0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IHJlY29yZHNbaXRlbV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVWYWx1ZTogdmFsdWVbcmVjb3Jkc1tpdGVtXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXRoID0gcmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS51bmlxdWUnLCBjb250ZXh0LCBsb2NhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydjb21wYXJhdG9yJywgJ29wdGlvbnMnXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgIGZyb206IEFycmF5LmlzQXJyYXksXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYnVpbGQoc2NoZW1hKSB7XG5cbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMgPSBbXTtcbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMgPSBbXTtcbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBzY2hlbWEuJF90ZXJtcy5pdGVtcykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIHNjaGVtYSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9leGNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQpIHtcbiAgICAgICAgICAgIGludGVybmFscy52YWxpZGF0ZVNpbmdsZSh0eXBlLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLml0ZW1zKC4uLmRlc2MuaXRlbXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5vcmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLm9yZGVyZWQoLi4uZGVzYy5vcmRlcmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYXJyYXkuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYW4gYXJyYXknLFxuICAgICAgICAnYXJyYXkuZXhjbHVkZXMnOiAne3sjbGFiZWx9fSBjb250YWlucyBhbiBleGNsdWRlZCB2YWx1ZScsXG4gICAgICAgICdhcnJheS5oYXNLbm93bic6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoIGZvciB0eXBlIHs6I3BhdHRlcm5MYWJlbH0nLFxuICAgICAgICAnYXJyYXkuaGFzVW5rbm93bic6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoJyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRCb3RoJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiB7eyNrbm93bk1pc3Nlc319IGFuZCB7eyN1bmtub3duTWlzc2VzfX0gb3RoZXIgcmVxdWlyZWQgdmFsdWUocyknLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEtub3ducyc6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4ge3sja25vd25NaXNzZXN9fScsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIHt7I3Vua25vd25NaXNzZXN9fSByZXF1aXJlZCB2YWx1ZShzKScsXG4gICAgICAgICdhcnJheS5sZW5ndGgnOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4ge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IGxlYXN0IHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkub3JkZXJlZExlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiBhdCBtb3N0IHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkuc29ydCc6ICd7eyNsYWJlbH19IG11c3QgYmUgc29ydGVkIGluIHsjb3JkZXJ9IG9yZGVyIGJ5IHt7I2J5fX0nLFxuICAgICAgICAnYXJyYXkuc29ydC5taXNtYXRjaGluZyc6ICd7eyNsYWJlbH19IGNhbm5vdCBiZSBzb3J0ZWQgZHVlIHRvIG1pc21hdGNoaW5nIHR5cGVzJyxcbiAgICAgICAgJ2FycmF5LnNvcnQudW5zdXBwb3J0ZWQnOiAne3sjbGFiZWx9fSBjYW5ub3QgYmUgc29ydGVkIGR1ZSB0byB1bnN1cHBvcnRlZCB0eXBlIHsjdHlwZX0nLFxuICAgICAgICAnYXJyYXkuc3BhcnNlJzogJ3t7I2xhYmVsfX0gbXVzdCBub3QgYmUgYSBzcGFyc2UgYXJyYXkgaXRlbScsXG4gICAgICAgICdhcnJheS51bmlxdWUnOiAne3sjbGFiZWx9fSBjb250YWlucyBhIGR1cGxpY2F0ZSB2YWx1ZSdcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5maWxsTWlzc2VkRXJyb3JzID0gZnVuY3Rpb24gKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IGtub3duTWlzc2VzID0gW107XG4gICAgbGV0IHVua25vd25NaXNzZXMgPSAwO1xuICAgIGZvciAoY29uc3QgcmVxdWlyZWQgb2YgcmVxdWlyZWRzKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gcmVxdWlyZWQuX2ZsYWdzLmxhYmVsO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGtub3duTWlzc2VzLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKyt1bmtub3duTWlzc2VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtub3duTWlzc2VzLmxlbmd0aCkge1xuICAgICAgICBpZiAodW5rbm93bk1pc3Nlcykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRCb3RoJywgdmFsdWUsIHsga25vd25NaXNzZXMsIHVua25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEtub3ducycsIHZhbHVlLCB7IGtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZFVua25vd25zJywgdmFsdWUsIHsgdW5rbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5maWxsT3JkZXJlZEVycm9ycyA9IGZ1bmN0aW9uIChzY2hlbWEsIGVycm9ycywgb3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IHJlcXVpcmVkT3JkZXJlZHMgPSBbXTtcblxuICAgIGZvciAoY29uc3Qgb3JkZXJlZCBvZiBvcmRlcmVkcykge1xuICAgICAgICBpZiAob3JkZXJlZC5fZmxhZ3MucHJlc2VuY2UgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgIHJlcXVpcmVkT3JkZXJlZHMucHVzaChvcmRlcmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1aXJlZE9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICBpbnRlcm5hbHMuZmlsbE1pc3NlZEVycm9ycyhzY2hlbWEsIGVycm9ycywgcmVxdWlyZWRPcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZmlsbERlZmF1bHQgPSBmdW5jdGlvbiAob3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IFtdO1xuICAgIGxldCB0cmFpbGluZ1VuZGVmaW5lZCA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpID0gb3JkZXJlZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZCA9IG9yZGVyZWRzW2ldO1xuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gb3JkZXJlZC4kX3ZhbGlkYXRlKHVuZGVmaW5lZCwgc3RhdGUubG9jYWxpemUoc3RhdGUucGF0aCwgYW5jZXN0b3JzLCBvcmRlcmVkKSwgcHJlZnMpLnZhbHVlO1xuXG4gICAgICAgIGlmICh0cmFpbGluZ1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhaWxpbmdVbmRlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG92ZXJyaWRlcy51bnNoaWZ0KG92ZXJyaWRlKTtcbiAgICB9XG5cbiAgICBpZiAob3ZlcnJpZGVzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZS5wdXNoKC4uLm92ZXJyaWRlcyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZmFzdFNwbGljZSA9IGZ1bmN0aW9uIChhcnIsIGkpIHtcblxuICAgIGxldCBwb3MgPSBpO1xuICAgIHdoaWxlIChwb3MgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGFycltwb3MrK10gPSBhcnJbcG9zXTtcbiAgICB9XG5cbiAgICAtLWFyci5sZW5ndGg7XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZVNpbmdsZSA9IGZ1bmN0aW9uICh0eXBlLCBvYmopIHtcblxuICAgIGlmICh0eXBlLnR5cGUgPT09ICdhcnJheScgfHxcbiAgICAgICAgdHlwZS5fZmxhZ3MuX2FycmF5SXRlbXMpIHtcblxuICAgICAgICBBc3NlcnQoIW9iai5fZmxhZ3Muc2luZ2xlLCAnQ2Fubm90IHNwZWNpZnkgYXJyYXkgaXRlbSB3aXRoIHNpbmdsZSBydWxlIGVuYWJsZWQnKTtcbiAgICAgICAgb2JqLiRfc2V0RmxhZygnX2FycmF5SXRlbXMnLCB0cnVlLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zb3J0ID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHNldHRpbmdzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGNvbnN0IG9yZGVyID0gc2V0dGluZ3Mub3JkZXIgPT09ICdhc2NlbmRpbmcnID8gMSA6IC0xO1xuICAgIGNvbnN0IGFGaXJzdCA9IC0xICogb3JkZXI7XG4gICAgY29uc3QgYkZpcnN0ID0gb3JkZXI7XG5cbiAgICBjb25zdCBzb3J0ID0gKGEsIGIpID0+IHtcblxuICAgICAgICBsZXQgY29tcGFyZSA9IGludGVybmFscy5jb21wYXJlKGEsIGIsIGFGaXJzdCwgYkZpcnN0KTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmJ5KSB7XG4gICAgICAgICAgICBhID0gc2V0dGluZ3MuYnkucmVzb2x2ZShhLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgYiA9IHNldHRpbmdzLmJ5LnJlc29sdmUoYiwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBhcmUgPSBpbnRlcm5hbHMuY29tcGFyZShhLCBiLCBhRmlyc3QsIGJGaXJzdCk7XG4gICAgICAgIGlmIChjb21wYXJlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYTtcbiAgICAgICAgaWYgKHR5cGUgIT09IHR5cGVvZiBiKSB7XG4gICAgICAgICAgICB0aHJvdyBzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuc29ydC5taXNtYXRjaGluZycsIHZhbHVlLCBudWxsLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICB0aHJvdyBzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuc29ydC51bnN1cHBvcnRlZCcsIHZhbHVlLCB7IHR5cGUgfSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIChhIC0gYikgKiBvcmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhIDwgYiA/IGFGaXJzdCA6IGJGaXJzdDtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLnNsaWNlKCkuc29ydChzb3J0KSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyIH07XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiLCBhRmlyc3QsIGJGaXJzdCkge1xuXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMTsgICAgICAgICAgIC8vIEFsd2F5cyBsYXN0IHJlZ2FyZGxlc3Mgb2Ygc29ydCBvcmRlclxuICAgIH1cblxuICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xOyAgICAgICAgICAgLy8gQWx3YXlzIGxhc3QgcmVnYXJkbGVzcyBvZiBzb3J0IG9yZGVyXG4gICAgfVxuXG4gICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJGaXJzdDtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYUZpcnN0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/array.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/binary.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/binary.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'binary',\n\n    coerce: {\n        from: ['string', 'object'],\n        method(value, { schema }) {\n\n            if (typeof value === 'string' || (value !== null && value.type === 'Buffer')) {\n                try {\n                    return { value: Buffer.from(value, schema._flags.encoding) };\n                }\n                catch (ignoreErr) { }\n            }\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (!Buffer.isBuffer(value)) {\n            return { value, errors: error('binary.base') };\n        }\n    },\n\n    rules: {\n        encoding: {\n            method(encoding) {\n\n                Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n                return this.$_setFlag('encoding', encoding);\n            }\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', method: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('binary.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        }\n    },\n\n    cast: {\n        string: {\n            from: (value) => Buffer.isBuffer(value),\n            to(value, helpers) {\n\n                return value.toString();\n            }\n        }\n    },\n\n    messages: {\n        'binary.base': '{{#label}} must be a buffer or a string',\n        'binary.length': '{{#label}} must be {{#limit}} bytes',\n        'binary.max': '{{#label}} must be less than or equal to {{#limit}} bytes',\n        'binary.min': '{{#label}} must be at least {{#limit}} bytes'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9iaW5hcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1Qjs7QUFFOUMsWUFBWSxtQkFBTyxDQUFDLHdEQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyx5REFBVzs7O0FBR2xDOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7O0FBRWhDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNCQUFzQixPQUFPOztBQUU3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsd0NBQXdDLDBDQUEwQyxPQUFPLGlCQUFpQjtBQUMxRyxhQUFhO0FBQ2IsdUNBQXVDLE9BQU8sSUFBSSxzQkFBc0I7O0FBRXhFO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsMEJBQTBCO0FBQ25GLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHdDQUF3Qyx1Q0FBdUMsT0FBTyxrQkFBa0I7QUFDeEc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsd0NBQXdDLHVDQUF1QyxPQUFPLGtCQUFrQjtBQUN4RztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkMsNEJBQTRCLFNBQVMsVUFBVSxTQUFTO0FBQ3hELHlCQUF5QixTQUFTLGdDQUFnQyxTQUFTO0FBQzNFLHlCQUF5QixTQUFTLG1CQUFtQixTQUFTO0FBQzlEO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2JpbmFyeS5qcz82MmMzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2JpbmFyeScsXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogWydzdHJpbmcnLCAnb2JqZWN0J10sXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEgfSkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUudHlwZSA9PT0gJ0J1ZmZlcicpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IEJ1ZmZlci5mcm9tKHZhbHVlLCBzY2hlbWEuX2ZsYWdzLmVuY29kaW5nKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoaWdub3JlRXJyKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignYmluYXJ5LmJhc2UnKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIGVuY29kaW5nOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyksICdJbnZhbGlkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZW5jb2RpbmcnLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUubGVuZ3RoLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYmluYXJ5LicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYmluYXJ5LmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nJyxcbiAgICAgICAgJ2JpbmFyeS5sZW5ndGgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIHt7I2xpbWl0fX0gYnl0ZXMnLFxuICAgICAgICAnYmluYXJ5Lm1heCc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gYnl0ZXMnLFxuICAgICAgICAnYmluYXJ5Lm1pbic6ICd7eyNsYWJlbH19IG11c3QgYmUgYXQgbGVhc3Qge3sjbGltaXR9fSBieXRlcydcbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/binary.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/boolean.js":
/*!***********************************************!*\
  !*** ./node_modules/joi/lib/types/boolean.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Values = __webpack_require__(/*! ../values */ \"(rsc)/./node_modules/joi/lib/values.js\");\n\n\nconst internals = {};\n\n\ninternals.isBool = function (value) {\n\n    return typeof value === 'boolean';\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'boolean',\n\n    flags: {\n\n        sensitive: { default: false }\n    },\n\n    terms: {\n\n        falsy: {\n            init: null,\n            manifest: 'values'\n        },\n\n        truthy: {\n            init: null,\n            manifest: 'values'\n        }\n    },\n\n    coerce(value, { schema }) {\n\n        if (typeof value === 'boolean') {\n            return;\n        }\n\n        if (typeof value === 'string') {\n            const normalized = schema._flags.sensitive ? value : value.toLowerCase();\n            value = normalized === 'true' ? true : (normalized === 'false' ? false : value);\n        }\n\n        if (typeof value !== 'boolean') {\n            value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) ||\n                (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);\n        }\n\n        return { value };\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'boolean') {\n            return { value, errors: error('boolean.base') };\n        }\n    },\n\n    rules: {\n        truthy: {\n            method(...values) {\n\n                Common.verifyFlat(values, 'truthy');\n\n                const obj = this.clone();\n                obj.$_terms.truthy = obj.$_terms.truthy || new Values();\n\n                for (let i = 0; i < values.length; ++i) {\n                    const value = values[i];\n\n                    Assert(value !== undefined, 'Cannot call truthy with undefined');\n                    obj.$_terms.truthy.add(value);\n                }\n\n                return obj;\n            }\n        },\n\n        falsy: {\n            method(...values) {\n\n                Common.verifyFlat(values, 'falsy');\n\n                const obj = this.clone();\n                obj.$_terms.falsy = obj.$_terms.falsy || new Values();\n\n                for (let i = 0; i < values.length; ++i) {\n                    const value = values[i];\n\n                    Assert(value !== undefined, 'Cannot call falsy with undefined');\n                    obj.$_terms.falsy.add(value);\n                }\n\n                return obj;\n            }\n        },\n\n        sensitive: {\n            method(enabled = true) {\n\n                return this.$_setFlag('sensitive', enabled);\n            }\n        }\n    },\n\n    cast: {\n        number: {\n            from: internals.isBool,\n            to(value, helpers) {\n\n                return value ? 1 : 0;\n            }\n        },\n        string: {\n            from: internals.isBool,\n            to(value, helpers) {\n\n                return value ? 'true' : 'false';\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.truthy) {\n                obj = obj.truthy(...desc.truthy);\n            }\n\n            if (desc.falsy) {\n                obj = obj.falsy(...desc.falsy);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'boolean.base': '{{#label}} must be a boolean'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw0RUFBdUI7O0FBRTlDLFlBQVksbUJBQU8sQ0FBQyx3REFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMseURBQVc7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLHlEQUFXOzs7QUFHbEM7OztBQUdBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQixLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLG9CQUFvQixRQUFROztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLEtBQUs7O0FBRUwsc0JBQXNCLE9BQU87O0FBRTdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLG1CQUFtQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2Jvb2xlYW4uanM/MTE1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBWYWx1ZXMgPSByZXF1aXJlKCcuLi92YWx1ZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuaXNCb29sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYm9vbGVhbicsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHNlbnNpdGl2ZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgZmFsc3k6IHtcbiAgICAgICAgICAgIGluaXQ6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogJ3ZhbHVlcydcbiAgICAgICAgfSxcblxuICAgICAgICB0cnV0aHk6IHtcbiAgICAgICAgICAgIGluaXQ6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogJ3ZhbHVlcydcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2UodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUgPyB2YWx1ZSA6IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vcm1hbGl6ZWQgPT09ICd0cnVlJyA/IHRydWUgOiAobm9ybWFsaXplZCA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNjaGVtYS4kX3Rlcm1zLnRydXRoeSAmJiBzY2hlbWEuJF90ZXJtcy50cnV0aHkuaGFzKHZhbHVlLCBudWxsLCBudWxsLCAhc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUpIHx8XG4gICAgICAgICAgICAgICAgKHNjaGVtYS4kX3Rlcm1zLmZhbHN5ICYmIHNjaGVtYS4kX3Rlcm1zLmZhbHN5Lmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgIXNjaGVtYS5fZmxhZ3Muc2Vuc2l0aXZlKSA/IGZhbHNlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2Jvb2xlYW4uYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgdHJ1dGh5OiB7XG4gICAgICAgICAgICBtZXRob2QoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICd0cnV0aHknKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy50cnV0aHkgPSBvYmouJF90ZXJtcy50cnV0aHkgfHwgbmV3IFZhbHVlcygpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCB0cnV0aHkgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMudHJ1dGh5LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmYWxzeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnZhbHVlcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAnZmFsc3knKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5mYWxzeSA9IG9iai4kX3Rlcm1zLmZhbHN5IHx8IG5ldyBWYWx1ZXMoKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgZmFsc3kgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuZmFsc3kuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNlbnNpdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3NlbnNpdGl2ZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNCb29sLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0Jvb2wsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy50cnV0aHkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoudHJ1dGh5KC4uLmRlc2MudHJ1dGh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZmFsc3kpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouZmFsc3koLi4uZGVzYy5mYWxzeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Jvb2xlYW4uYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBib29sZWFuJ1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/boolean.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/date.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/date.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Template = __webpack_require__(/*! ../template */ \"(rsc)/./node_modules/joi/lib/template.js\");\n\n\nconst internals = {};\n\n\ninternals.isDate = function (value) {\n\n    return value instanceof Date;\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'date',\n\n    coerce: {\n        from: ['number', 'string'],\n        method(value, { schema }) {\n\n            return { value: internals.parse(value, schema._flags.format) || value };\n        }\n    },\n\n    validate(value, { schema, error, prefs }) {\n\n        if (value instanceof Date &&\n            !isNaN(value.getTime())) {\n\n            return;\n        }\n\n        const format = schema._flags.format;\n\n        if (!prefs.convert ||\n            !format ||\n            typeof value !== 'string') {\n\n            return { value, errors: error('date.base') };\n        }\n\n        return { value, errors: error('date.format', { format }) };\n    },\n\n    rules: {\n\n        compare: {\n            method: false,\n            validate(value, helpers, { date }, { name, operator, args }) {\n\n                const to = date === 'now' ? Date.now() : date.getTime();\n                if (Common.compare(value.getTime(), to, operator)) {\n                    return value;\n                }\n\n                return helpers.error('date.' + name, { limit: args.date, value });\n            },\n            args: [\n                {\n                    name: 'date',\n                    ref: true,\n                    normalize: (date) => {\n\n                        return date === 'now' ? date : internals.parse(date);\n                    },\n                    assert: (date) => date !== null,\n                    message: 'must have a valid date format'\n                }\n            ]\n        },\n\n        format: {\n            method(format) {\n\n                Assert(['iso', 'javascript', 'unix'].includes(format), 'Unknown date format', format);\n\n                return this.$_setFlag('format', format);\n            }\n        },\n\n        greater: {\n            method(date) {\n\n                return this.$_addRule({ name: 'greater', method: 'compare', args: { date }, operator: '>' });\n            }\n        },\n\n        iso: {\n            method() {\n\n                return this.format('iso');\n            }\n        },\n\n        less: {\n            method(date) {\n\n                return this.$_addRule({ name: 'less', method: 'compare', args: { date }, operator: '<' });\n            }\n        },\n\n        max: {\n            method(date) {\n\n                return this.$_addRule({ name: 'max', method: 'compare', args: { date }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(date) {\n\n                return this.$_addRule({ name: 'min', method: 'compare', args: { date }, operator: '>=' });\n            }\n        },\n\n        timestamp: {\n            method(type = 'javascript') {\n\n                Assert(['javascript', 'unix'].includes(type), '\"type\" must be one of \"javascript, unix\"');\n\n                return this.format(type);\n            }\n        }\n    },\n\n    cast: {\n        number: {\n            from: internals.isDate,\n            to(value, helpers) {\n\n                return value.getTime();\n            }\n        },\n        string: {\n            from: internals.isDate,\n            to(value, { prefs }) {\n\n                return Template.date(value, prefs);\n            }\n        }\n    },\n\n    messages: {\n        'date.base': '{{#label}} must be a valid date',\n        'date.format': '{{#label}} must be in {msg(\"date.format.\" + #format) || #format} format',\n        'date.greater': '{{#label}} must be greater than {{:#limit}}',\n        'date.less': '{{#label}} must be less than {{:#limit}}',\n        'date.max': '{{#label}} must be less than or equal to {{:#limit}}',\n        'date.min': '{{#label}} must be greater than or equal to {{:#limit}}',\n\n        // Messages used in date.format\n\n        'date.format.iso': 'ISO 8601 date',\n        'date.format.javascript': 'timestamp or number of milliseconds',\n        'date.format.unix': 'timestamp or number of seconds'\n    }\n});\n\n\n// Helpers\n\ninternals.parse = function (value, format) {\n\n    if (value instanceof Date) {\n        return value;\n    }\n\n    if (typeof value !== 'string' &&\n        (isNaN(value) || !isFinite(value))) {\n\n        return null;\n    }\n\n    if (/^\\s*$/.test(value)) {\n        return null;\n    }\n\n    // ISO\n\n    if (format === 'iso') {\n        if (!Common.isIsoDate(value)) {\n            return null;\n        }\n\n        return internals.date(value.toString());\n    }\n\n    // Normalize number string\n\n    const original = value;\n    if (typeof value === 'string' &&\n        /^[+-]?\\d+(\\.\\d+)?$/.test(value)) {\n\n        value = parseFloat(value);\n    }\n\n    // Timestamp\n\n    if (format) {\n        if (format === 'javascript') {\n            return internals.date(1 * value);        // Casting to number\n        }\n\n        if (format === 'unix') {\n            return internals.date(1000 * value);\n        }\n\n        if (typeof original === 'string') {\n            return null;\n        }\n    }\n\n    // Plain\n\n    return internals.date(value);\n};\n\n\ninternals.date = function (value) {\n\n    const date = new Date(value);\n    if (!isNaN(date.getTime())) {\n        return date;\n    }\n\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9kYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw0RUFBdUI7O0FBRTlDLFlBQVksbUJBQU8sQ0FBQyx3REFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMseURBQVc7QUFDbEMsaUJBQWlCLG1CQUFPLENBQUMsNkRBQWE7OztBQUd0Qzs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixRQUFROztBQUVoQyxxQkFBcUI7QUFDckI7QUFDQSxLQUFLOztBQUVMLHNCQUFzQixzQkFBc0I7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBLGlCQUFpQixzQ0FBc0MsUUFBUTtBQUMvRCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTSxJQUFJLHNCQUFzQjs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVELHlCQUF5QjtBQUNoRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHdDQUF3Qyw0Q0FBNEMsTUFBTSxpQkFBaUI7QUFDM0c7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSx3Q0FBd0MseUNBQXlDLE1BQU0saUJBQWlCO0FBQ3hHO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHdDQUF3Qyx3Q0FBd0MsTUFBTSxrQkFBa0I7QUFDeEc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsd0NBQXdDLHdDQUF3QyxNQUFNLGtCQUFrQjtBQUN4RztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QixPQUFPOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakMsMEJBQTBCLFNBQVMsWUFBWSwwQ0FBMEM7QUFDekYsMkJBQTJCLFNBQVMsdUJBQXVCLFNBQVM7QUFDcEUsd0JBQXdCLFNBQVMsb0JBQW9CLFNBQVM7QUFDOUQsdUJBQXVCLFNBQVMsZ0NBQWdDLFNBQVM7QUFDekUsdUJBQXVCLFNBQVMsbUNBQW1DLFNBQVM7O0FBRTVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvZGF0ZS5qcz8wNjFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuaXNEYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2RhdGUnLFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206IFsnbnVtYmVyJywgJ3N0cmluZyddLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGludGVybmFscy5wYXJzZSh2YWx1ZSwgc2NoZW1hLl9mbGFncy5mb3JtYXQpIHx8IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICAgICAgICAgICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHNjaGVtYS5fZmxhZ3MuZm9ybWF0O1xuXG4gICAgICAgIGlmICghcHJlZnMuY29udmVydCB8fFxuICAgICAgICAgICAgIWZvcm1hdCB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignZGF0ZS5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdkYXRlLmZvcm1hdCcsIHsgZm9ybWF0IH0pIH07XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29tcGFyZToge1xuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGRhdGUgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0byA9IGRhdGUgPT09ICdub3cnID8gRGF0ZS5ub3coKSA6IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5nZXRUaW1lKCksIHRvLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdkYXRlLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmRhdGUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemU6IChkYXRlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlID09PSAnbm93JyA/IGRhdGUgOiBpbnRlcm5hbHMucGFyc2UoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogKGRhdGUpID0+IGRhdGUgIT09IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGhhdmUgYSB2YWxpZCBkYXRlIGZvcm1hdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICBtZXRob2QoZm9ybWF0KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydpc28nLCAnamF2YXNjcmlwdCcsICd1bml4J10uaW5jbHVkZXMoZm9ybWF0KSwgJ1Vua25vd24gZGF0ZSBmb3JtYXQnLCBmb3JtYXQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdmb3JtYXQnLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdyZWF0ZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZChkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3JlYXRlcicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc+JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc286IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCgnaXNvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVzczoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZXNzJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJzwnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRpbWVzdGFtcDoge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnamF2YXNjcmlwdCcpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2phdmFzY3JpcHQnLCAndW5peCddLmluY2x1ZGVzKHR5cGUpLCAnXCJ0eXBlXCIgbXVzdCBiZSBvbmUgb2YgXCJqYXZhc2NyaXB0LCB1bml4XCInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzRGF0ZSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0RhdGUsXG4gICAgICAgICAgICB0byh2YWx1ZSwgeyBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gVGVtcGxhdGUuZGF0ZSh2YWx1ZSwgcHJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdkYXRlLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgZGF0ZScsXG4gICAgICAgICdkYXRlLmZvcm1hdCc6ICd7eyNsYWJlbH19IG11c3QgYmUgaW4ge21zZyhcImRhdGUuZm9ybWF0LlwiICsgI2Zvcm1hdCkgfHwgI2Zvcm1hdH0gZm9ybWF0JyxcbiAgICAgICAgJ2RhdGUuZ3JlYXRlcic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIHt7OiNsaW1pdH19JyxcbiAgICAgICAgJ2RhdGUubGVzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIHt7OiNsaW1pdH19JyxcbiAgICAgICAgJ2RhdGUubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7ezojbGltaXR9fScsXG5cbiAgICAgICAgLy8gTWVzc2FnZXMgdXNlZCBpbiBkYXRlLmZvcm1hdFxuXG4gICAgICAgICdkYXRlLmZvcm1hdC5pc28nOiAnSVNPIDg2MDEgZGF0ZScsXG4gICAgICAgICdkYXRlLmZvcm1hdC5qYXZhc2NyaXB0JzogJ3RpbWVzdGFtcCBvciBudW1iZXIgb2YgbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LnVuaXgnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBzZWNvbmRzJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLnBhcnNlID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoL15cXHMqJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSVNPXG5cbiAgICBpZiAoZm9ybWF0ID09PSAnaXNvJykge1xuICAgICAgICBpZiAoIUNvbW1vbi5pc0lzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgbnVtYmVyIHN0cmluZ1xuXG4gICAgY29uc3Qgb3JpZ2luYWwgPSB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAvXlsrLV0/XFxkKyhcXC5cXGQrKT8kLy50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gVGltZXN0YW1wXG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdqYXZhc2NyaXB0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKDEgKiB2YWx1ZSk7ICAgICAgICAvLyBDYXN0aW5nIHRvIG51bWJlclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3VuaXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMTAwMCAqIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBsYWluXG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUodmFsdWUpO1xufTtcblxuXG5pbnRlcm5hbHMuZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/date.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/function.js":
/*!************************************************!*\
  !*** ./node_modules/joi/lib/types/function.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Keys = __webpack_require__(/*! ./keys */ \"(rsc)/./node_modules/joi/lib/types/keys.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Keys.extend({\n\n    type: 'function',\n\n    properties: {\n        typeof: 'function'\n    },\n\n    rules: {\n        arity: {\n            method(n) {\n\n                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');\n\n                return this.$_addRule({ name: 'arity', args: { n } });\n            },\n            validate(value, helpers, { n }) {\n\n                if (value.length === n) {\n                    return value;\n                }\n\n                return helpers.error('function.arity', { n });\n            }\n        },\n\n        class: {\n            method() {\n\n                return this.$_addRule('class');\n            },\n            validate(value, helpers) {\n\n                if ((/^\\s*class\\s/).test(value.toString())) {\n                    return value;\n                }\n\n                return helpers.error('function.class', { value });\n            }\n        },\n\n        minArity: {\n            method(n) {\n\n                Assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');\n\n                return this.$_addRule({ name: 'minArity', args: { n } });\n            },\n            validate(value, helpers, { n }) {\n\n                if (value.length >= n) {\n                    return value;\n                }\n\n                return helpers.error('function.minArity', { n });\n            }\n        },\n\n        maxArity: {\n            method(n) {\n\n                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');\n\n                return this.$_addRule({ name: 'maxArity', args: { n } });\n            },\n            validate(value, helpers, { n }) {\n\n                if (value.length <= n) {\n                    return value;\n                }\n\n                return helpers.error('function.maxArity', { n });\n            }\n        }\n    },\n\n    messages: {\n        'function.arity': '{{#label}} must have an arity of {{#n}}',\n        'function.class': '{{#label}} must be a class',\n        'function.maxArity': '{{#label}} must have an arity lesser or equal to {{#n}}',\n        'function.minArity': '{{#label}} must have an arity greater or equal to {{#n}}'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9mdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsNEVBQXVCOztBQUU5QyxhQUFhLG1CQUFPLENBQUMsMERBQVE7OztBQUc3Qjs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3Qyx1QkFBdUIsS0FBSztBQUNwRSxhQUFhO0FBQ2IsdUNBQXVDLEdBQUc7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsR0FBRztBQUM1RDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlELE9BQU87QUFDaEU7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDLDBCQUEwQixLQUFLO0FBQ3ZFLGFBQWE7QUFDYix1Q0FBdUMsR0FBRzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLDREQUE0RCxHQUFHO0FBQy9EO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLHdDQUF3QywwQkFBMEIsS0FBSztBQUN2RSxhQUFhO0FBQ2IsdUNBQXVDLEdBQUc7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQsR0FBRztBQUMvRDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDZCQUE2QixTQUFTLHdCQUF3QixJQUFJO0FBQ2xFLDZCQUE2QixTQUFTO0FBQ3RDLGdDQUFnQyxTQUFTLHdDQUF3QyxJQUFJO0FBQ3JGLGdDQUFnQyxTQUFTLHlDQUF5QyxJQUFJO0FBQ3RGO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2Z1bmN0aW9uLmpzPzI1MzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgS2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gS2V5cy5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZW9mOiAnZnVuY3Rpb24nXG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIGFyaXR5OiB7XG4gICAgICAgICAgICBtZXRob2Qobikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPj0gMCwgJ24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdhcml0eScsIGFyZ3M6IHsgbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG4gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLmFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2NsYXNzJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICgoL15cXHMqY2xhc3NcXHMvKS50ZXN0KHZhbHVlLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24uY2xhc3MnLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbkFyaXR5OiB7XG4gICAgICAgICAgICBtZXRob2Qobikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPiAwLCAnbiBtdXN0IGJlIGEgc3RyaWN0IHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW5Bcml0eScsIGFyZ3M6IHsgbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG4gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24ubWluQXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4QXJpdHk6IHtcbiAgICAgICAgICAgIG1ldGhvZChuKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+PSAwLCAnbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heEFyaXR5JywgYXJnczogeyBuIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5tYXhBcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnZnVuY3Rpb24uYXJpdHknOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgYW4gYXJpdHkgb2Yge3sjbn19JyxcbiAgICAgICAgJ2Z1bmN0aW9uLmNsYXNzJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGNsYXNzJyxcbiAgICAgICAgJ2Z1bmN0aW9uLm1heEFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IGxlc3NlciBvciBlcXVhbCB0byB7eyNufX0nLFxuICAgICAgICAnZnVuY3Rpb24ubWluQXJpdHknOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgYW4gYXJpdHkgZ3JlYXRlciBvciBlcXVhbCB0byB7eyNufX0nXG4gICAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/function.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/keys.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/keys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst ApplyToDefaults = __webpack_require__(/*! @hapi/hoek/lib/applyToDefaults */ \"(rsc)/./node_modules/@hapi/hoek/lib/applyToDefaults.js\");\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Topo = __webpack_require__(/*! @hapi/topo */ \"(rsc)/./node_modules/@hapi/topo/lib/index.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ../ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ../template */ \"(rsc)/./node_modules/joi/lib/template.js\");\n\n\nconst internals = {\n    renameDefaults: {\n        alias: false,                   // Keep old value in place\n        multiple: false,                // Allow renaming multiple keys into the same target\n        override: false                 // Overrides an existing key\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: '_keys',\n\n    properties: {\n\n        typeof: 'object'\n    },\n\n    flags: {\n\n        unknown: { default: undefined }\n    },\n\n    terms: {\n\n        dependencies: { init: null },\n        keys: { init: null, manifest: { mapped: { from: 'schema', to: 'key' } } },\n        patterns: { init: null },\n        renames: { init: null }\n    },\n\n    args(schema, keys) {\n\n        return schema.keys(keys);\n    },\n\n    validate(value, { schema, error, state, prefs }) {\n\n        if (!value ||\n            typeof value !== schema.$_property('typeof') ||\n            Array.isArray(value)) {\n\n            return { value, errors: error('object.base', { type: schema.$_property('typeof') }) };\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!schema.$_terms.renames &&\n            !schema.$_terms.dependencies &&\n            !schema.$_terms.keys &&                       // null allows any keys\n            !schema.$_terms.patterns &&\n            !schema.$_terms.externals) {\n\n            return;\n        }\n\n        // Shallow clone value\n\n        value = internals.clone(value, prefs);\n        const errors = [];\n\n        // Rename keys\n\n        if (schema.$_terms.renames &&\n            !internals.rename(schema, value, state, prefs, errors)) {\n\n            return { value, errors };\n        }\n\n        // Anything allowed\n\n        if (!schema.$_terms.keys &&                       // null allows any keys\n            !schema.$_terms.patterns &&\n            !schema.$_terms.dependencies) {\n\n            return { value, errors };\n        }\n\n        // Defined keys\n\n        const unprocessed = new Set(Object.keys(value));\n\n        if (schema.$_terms.keys) {\n            const ancestors = [value, ...state.ancestors];\n\n            for (const child of schema.$_terms.keys) {\n                const key = child.key;\n                const item = value[key];\n\n                unprocessed.delete(key);\n\n                const localState = state.localize([...state.path, key], ancestors, child);\n                const result = child.schema.$_validate(item, localState, prefs);\n\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return { value, errors: result.errors };\n                    }\n\n                    if (result.value !== undefined) {\n                        value[key] = result.value;\n                    }\n\n                    errors.push(...result.errors);\n                }\n                else if (child.schema._flags.result === 'strip' ||\n                    result.value === undefined && item !== undefined) {\n\n                    delete value[key];\n                }\n                else if (result.value !== undefined) {\n                    value[key] = result.value;\n                }\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size ||\n            schema._flags._hasPatternMatch) {\n\n            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);\n            if (early) {\n                return early;\n            }\n        }\n\n        // Validate dependencies\n\n        if (schema.$_terms.dependencies) {\n            for (const dep of schema.$_terms.dependencies) {\n                if (\n                    dep.key !== null &&\n                    internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, { shadow: false })) === false\n                ) {\n\n                    continue;\n                }\n\n                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);\n                if (failed) {\n                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);\n                    if (prefs.abortEarly) {\n                        return { value, errors: report };\n                    }\n\n                    errors.push(report);\n                }\n            }\n        }\n\n        return { value, errors };\n    },\n\n    rules: {\n\n        and: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'and');\n\n                return internals.dependency(this, 'and', null, peers);\n            }\n        },\n\n        append: {\n            method(schema) {\n\n                if (schema === null ||\n                    schema === undefined ||\n                    Object.keys(schema).length === 0) {\n\n                    return this;\n                }\n\n                return this.keys(schema);\n            }\n        },\n\n        assert: {\n            method(subject, schema, message) {\n\n                if (!Template.isTemplate(subject)) {\n                    subject = Compile.ref(subject);\n                }\n\n                Assert(message === undefined || typeof message === 'string', 'Message must be a string');\n\n                schema = this.$_compile(schema, { appendPath: true });\n\n                const obj = this.$_addRule({ name: 'assert', args: { subject, schema, message } });\n                obj.$_mutateRegister(subject);\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate(value, { error, prefs, state }, { subject, schema, message }) {\n\n                const about = subject.resolve(value, state, prefs);\n                const path = Ref.isRef(subject) ? subject.absolute(state) : [];\n                if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {\n                    return value;\n                }\n\n                return error('object.assert', { subject, message });\n            },\n            args: ['subject', 'schema', 'message'],\n            multi: true\n        },\n\n        instance: {\n            method(constructor, name) {\n\n                Assert(typeof constructor === 'function', 'constructor must be a function');\n\n                name = name || constructor.name;\n\n                return this.$_addRule({ name: 'instance', args: { constructor, name } });\n            },\n            validate(value, helpers, { constructor, name }) {\n\n                if (value instanceof constructor) {\n                    return value;\n                }\n\n                return helpers.error('object.instance', { type: name, value });\n            },\n            args: ['constructor', 'name']\n        },\n\n        keys: {\n            method(schema) {\n\n                Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n                Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');\n\n                const obj = this.clone();\n\n                if (!schema) {                                      // Allow all\n                    obj.$_terms.keys = null;\n                }\n                else if (!Object.keys(schema).length) {             // Allow none\n                    obj.$_terms.keys = new internals.Keys();\n                }\n                else {\n                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();\n                    for (const key in schema) {\n                        Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);\n                    }\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(Object.keys(value).length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('object.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        },\n\n        nand: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'nand');\n\n                return internals.dependency(this, 'nand', null, peers);\n            }\n        },\n\n        or: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'or');\n\n                return internals.dependency(this, 'or', null, peers);\n            }\n        },\n\n        oxor: {\n            method(...peers /*, [options] */) {\n\n                return internals.dependency(this, 'oxor', null, peers);\n            }\n        },\n\n        pattern: {\n            method(pattern, schema, options = {}) {\n\n                const isRegExp = pattern instanceof RegExp;\n                if (!isRegExp) {\n                    pattern = this.$_compile(pattern, { appendPath: true });\n                }\n\n                Assert(schema !== undefined, 'Invalid rule');\n                Common.assertOptions(options, ['fallthrough', 'matches']);\n\n                if (isRegExp) {\n                    Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n                }\n\n                schema = this.$_compile(schema, { appendPath: true });\n\n                const obj = this.clone();\n                obj.$_terms.patterns = obj.$_terms.patterns || [];\n                const config = { [isRegExp ? 'regex' : 'schema']: pattern, rule: schema };\n                if (options.matches) {\n                    config.matches = this.$_compile(options.matches);\n                    if (config.matches.type !== 'array') {\n                        config.matches = config.matches.$_root.array().items(config.matches);\n                    }\n\n                    obj.$_mutateRegister(config.matches);\n                    obj.$_setFlag('_hasPatternMatch', true, { clone: false });\n                }\n\n                if (options.fallthrough) {\n                    config.fallthrough = true;\n                }\n\n                obj.$_terms.patterns.push(config);\n                obj.$_mutateRegister(schema);\n                return obj;\n            }\n        },\n\n        ref: {\n            method() {\n\n                return this.$_addRule('ref');\n            },\n            validate(value, helpers) {\n\n                if (Ref.isRef(value)) {\n                    return value;\n                }\n\n                return helpers.error('object.refType', { value });\n            }\n        },\n\n        regex: {\n            method() {\n\n                return this.$_addRule('regex');\n            },\n            validate(value, helpers) {\n\n                if (value instanceof RegExp) {\n                    return value;\n                }\n\n                return helpers.error('object.regex', { value });\n            }\n        },\n\n        rename: {\n            method(from, to, options = {}) {\n\n                Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n                Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');\n                Assert(to !== from, 'Cannot rename key to same name:', from);\n\n                Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);\n\n                const obj = this.clone();\n\n                obj.$_terms.renames = obj.$_terms.renames || [];\n                for (const rename of obj.$_terms.renames) {\n                    Assert(rename.from !== from, 'Cannot rename the same key multiple times');\n                }\n\n                if (to instanceof Template) {\n                    obj.$_mutateRegister(to);\n                }\n\n                obj.$_terms.renames.push({\n                    from,\n                    to,\n                    options: ApplyToDefaults(internals.renameDefaults, options)\n                });\n\n                return obj;\n            }\n        },\n\n        schema: {\n            method(type = 'any') {\n\n                return this.$_addRule({ name: 'schema', args: { type } });\n            },\n            validate(value, helpers, { type }) {\n\n                if (Common.isSchema(value) &&\n                    (type === 'any' || value.type === type)) {\n\n                    return value;\n                }\n\n                return helpers.error('object.schema', { type });\n            }\n        },\n\n        unknown: {\n            method(allow) {\n\n                return this.$_setFlag('unknown', allow !== false);\n            }\n        },\n\n        with: {\n            method(key, peers, options = {}) {\n\n                return internals.dependency(this, 'with', key, peers, options);\n            }\n        },\n\n        without: {\n            method(key, peers, options = {}) {\n\n                return internals.dependency(this, 'without', key, peers, options);\n            }\n        },\n\n        xor: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'xor');\n\n                return internals.dependency(this, 'xor', null, peers);\n            }\n        }\n    },\n\n    overrides: {\n\n        default(value, options) {\n\n            if (value === undefined) {\n                value = Common.symbols.deepDefault;\n            }\n\n            return this.$_parent('default', value, options);\n        }\n    },\n\n    rebuild(schema) {\n\n        if (schema.$_terms.keys) {\n            const topo = new Topo.Sorter();\n            for (const child of schema.$_terms.keys) {\n                Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);\n            }\n\n            schema.$_terms.keys = new internals.Keys(...topo.nodes);\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.keys) {\n                obj = obj.keys(desc.keys);\n            }\n\n            if (desc.dependencies) {\n                for (const { rel, key = null, peers, options } of desc.dependencies) {\n                    obj = internals.dependency(obj, rel, key, peers, options);\n                }\n            }\n\n            if (desc.patterns) {\n                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {\n                    obj = obj.pattern(regex || schema, rule, { fallthrough, matches });\n                }\n            }\n\n            if (desc.renames) {\n                for (const { from, to, options } of desc.renames) {\n                    obj = obj.rename(from, to, options);\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'object.and': '{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',\n        'object.assert': '{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}',\n        'object.base': '{{#label}} must be of type {{#type}}',\n        'object.instance': '{{#label}} must be an instance of {{:#type}}',\n        'object.length': '{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.max': '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.min': '{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.missing': '{{#label}} must contain at least one of {{#peersWithLabels}}',\n        'object.nand': '{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}',\n        'object.oxor': '{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}',\n        'object.pattern.match': '{{#label}} keys failed to match pattern requirements',\n        'object.refType': '{{#label}} must be a Joi reference',\n        'object.regex': '{{#label}} must be a RegExp object',\n        'object.rename.multiple': '{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}',\n        'object.rename.override': '{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists',\n        'object.schema': '{{#label}} must be a Joi schema of {{#type}} type',\n        'object.unknown': '{{#label}} is not allowed',\n        'object.with': '{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}',\n        'object.without': '{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}',\n        'object.xor': '{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}'\n    }\n});\n\n\n// Helpers\n\ninternals.clone = function (value, prefs) {\n\n    // Object\n\n    if (typeof value === 'object') {\n        if (prefs.nonEnumerables) {\n            return Clone(value, { shallow: true });\n        }\n\n        const clone = Object.create(Object.getPrototypeOf(value));\n        Object.assign(clone, value);\n        return clone;\n    }\n\n    // Function\n\n    const clone = function (...args) {\n\n        return value.apply(this, args);\n    };\n\n    clone.prototype = Clone(value.prototype);\n    Object.defineProperty(clone, 'name', { value: value.name, writable: false });\n    Object.defineProperty(clone, 'length', { value: value.length, writable: false });\n    Object.assign(clone, value);\n    return clone;\n};\n\n\ninternals.dependency = function (schema, rel, key, peers, options) {\n\n    Assert(key === null || typeof key === 'string', rel, 'key must be a strings');\n\n    // Extract options from peers array\n\n    if (!options) {\n        options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};\n    }\n\n    Common.assertOptions(options, ['separator', 'isPresent']);\n\n    peers = [].concat(peers);\n\n    // Cast peer paths\n\n    const separator = Common.default(options.separator, '.');\n    const paths = [];\n    for (const peer of peers) {\n        Assert(typeof peer === 'string', rel, 'peers must be strings');\n        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));\n    }\n\n    // Cast key\n\n    if (key !== null) {\n        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });\n    }\n\n    // Add rule\n\n    const obj = schema.clone();\n    obj.$_terms.dependencies = obj.$_terms.dependencies || [];\n    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));\n    return obj;\n};\n\n\ninternals.dependencies = {\n\n    and(schema, dep, value, state, prefs) {\n\n        const missing = [];\n        const present = [];\n        const count = dep.peers.length;\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers) {\n            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {\n                missing.push(peer.key);\n            }\n            else {\n                present.push(peer.key);\n            }\n        }\n\n        if (missing.length !== count &&\n            present.length !== count) {\n\n            return {\n                code: 'object.and',\n                context: {\n                    present,\n                    presentWithLabels: internals.keysToLabels(schema, present),\n                    missing,\n                    missingWithLabels: internals.keysToLabels(schema, missing)\n                }\n            };\n        }\n    },\n\n    nand(schema, dep, value, state, prefs) {\n\n        const present = [];\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers) {\n            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {\n                present.push(peer.key);\n            }\n        }\n\n        if (present.length !== dep.peers.length) {\n            return;\n        }\n\n        const main = dep.paths[0];\n        const values = dep.paths.slice(1);\n        return {\n            code: 'object.nand',\n            context: {\n                main,\n                mainWithLabel: internals.keysToLabels(schema, main),\n                peers: values,\n                peersWithLabels: internals.keysToLabels(schema, values)\n            }\n        };\n    },\n\n    or(schema, dep, value, state, prefs) {\n\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers) {\n            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {\n                return;\n            }\n        }\n\n        return {\n            code: 'object.missing',\n            context: {\n                peers: dep.paths,\n                peersWithLabels: internals.keysToLabels(schema, dep.paths)\n            }\n        };\n    },\n\n    oxor(schema, dep, value, state, prefs) {\n\n        const present = [];\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers) {\n            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {\n                present.push(peer.key);\n            }\n        }\n\n        if (!present.length ||\n            present.length === 1) {\n\n            return;\n        }\n\n        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return { code: 'object.oxor', context };\n    },\n\n    with(schema, dep, value, state, prefs) {\n\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers) {\n            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false })) === false) {\n                return {\n                    code: 'object.with',\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n\n    without(schema, dep, value, state, prefs) {\n\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers) {\n            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {\n                return {\n                    code: 'object.without',\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n\n    xor(schema, dep, value, state, prefs) {\n\n        const present = [];\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers) {\n            if (isPresent(peer.resolve(value, state, prefs, null, { shadow: false }))) {\n                present.push(peer.key);\n            }\n        }\n\n        if (present.length === 1) {\n            return;\n        }\n\n        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };\n        if (present.length === 0) {\n            return { code: 'object.missing', context };\n        }\n\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return { code: 'object.xor', context };\n    }\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    if (Array.isArray(keys)) {\n        return keys.map((key) => schema.$_mapLabels(key));\n    }\n\n    return schema.$_mapLabels(keys);\n};\n\n\ninternals.isPresent = function (options) {\n\n    return typeof options.isPresent === 'function' ? options.isPresent : (resolved) => resolved !== undefined;\n};\n\n\ninternals.rename = function (schema, value, state, prefs, errors) {\n\n    const renamed = {};\n    for (const rename of schema.$_terms.renames) {\n        const matches = [];\n        const pattern = typeof rename.from !== 'string';\n\n        if (!pattern) {\n            if (Object.prototype.hasOwnProperty.call(value, rename.from) &&\n                (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {\n\n                matches.push(rename);\n            }\n        }\n        else {\n            for (const from in value) {\n                if (value[from] === undefined &&\n                    rename.options.ignoreUndefined) {\n\n                    continue;\n                }\n\n                if (from === rename.to) {\n                    continue;\n                }\n\n                const match = rename.from.exec(from);\n                if (!match) {\n                    continue;\n                }\n\n                matches.push({ from, to: rename.to, match });\n            }\n        }\n\n        for (const match of matches) {\n            const from = match.from;\n            let to = match.to;\n            if (to instanceof Template) {\n                to = to.render(value, state, prefs, match.match);\n            }\n\n            if (from === to) {\n                continue;\n            }\n\n            if (!rename.options.multiple &&\n                renamed[to]) {\n\n                errors.push(schema.$_createError('object.rename.multiple', value, { from, to, pattern }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n\n            if (Object.prototype.hasOwnProperty.call(value, to) &&\n                !rename.options.override &&\n                !renamed[to]) {\n\n                errors.push(schema.$_createError('object.rename.override', value, { from, to, pattern }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n\n            if (value[from] === undefined) {\n                delete value[to];\n            }\n            else {\n                value[to] = value[from];\n            }\n\n            renamed[to] = true;\n\n            if (!rename.options.alias) {\n                delete value[from];\n            }\n        }\n    }\n\n    return true;\n};\n\n\ninternals.unknown = function (schema, value, unprocessed, errors, state, prefs) {\n\n    if (schema.$_terms.patterns) {\n        let hasMatches = false;\n        const matches = schema.$_terms.patterns.map((pattern) => {\n\n            if (pattern.matches) {\n                hasMatches = true;\n                return [];\n            }\n        });\n\n        const ancestors = [value, ...state.ancestors];\n\n        for (const key of unprocessed) {\n            const item = value[key];\n            const path = [...state.path, key];\n\n            for (let i = 0; i < schema.$_terms.patterns.length; ++i) {\n                const pattern = schema.$_terms.patterns[i];\n                if (pattern.regex) {\n                    const match = pattern.regex.test(key);\n                    state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');\n                    if (!match) {\n                        continue;\n                    }\n                }\n                else {\n                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {\n                        continue;\n                    }\n                }\n\n                unprocessed.delete(key);\n\n                const localState = state.localize(path, ancestors, { schema: pattern.rule, key });\n                const result = pattern.rule.$_validate(item, localState, prefs);\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return { value, errors: result.errors };\n                    }\n\n                    errors.push(...result.errors);\n                }\n\n                if (pattern.matches) {\n                    matches[i].push(key);\n                }\n\n                value[key] = result.value;\n                if (!pattern.fallthrough) {\n                    break;\n                }\n            }\n        }\n\n        // Validate pattern matches rules\n\n        if (hasMatches) {\n            for (let i = 0; i < matches.length; ++i) {\n                const match = matches[i];\n                if (!match) {\n                    continue;\n                }\n\n                const stpm = schema.$_terms.patterns[i].matches;\n                const localState = state.localize(state.path, ancestors, stpm);\n                const result = stpm.$_validate(match, localState, prefs);\n                if (result.errors) {\n                    const details = Errors.details(result.errors, { override: false });\n                    details.matches = match;\n                    const report = schema.$_createError('object.pattern.match', value, details, state, prefs);\n                    if (prefs.abortEarly) {\n                        return { value, errors: report };\n                    }\n\n                    errors.push(report);\n                }\n            }\n        }\n    }\n\n    if (!unprocessed.size ||\n        !schema.$_terms.keys && !schema.$_terms.patterns) {     // If no keys or patterns specified, unknown keys allowed\n\n        return;\n    }\n\n    if (prefs.stripUnknown && typeof schema._flags.unknown === 'undefined' ||\n        prefs.skipFunctions) {\n\n        const stripUnknown = prefs.stripUnknown ? (prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects) : false;\n\n        for (const key of unprocessed) {\n            if (stripUnknown) {\n                delete value[key];\n                unprocessed.delete(key);\n            }\n            else if (typeof value[key] === 'function') {\n                unprocessed.delete(key);\n            }\n        }\n    }\n\n    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);\n    if (forbidUnknown) {\n        for (const unprocessedKey of unprocessed) {\n            const localState = state.localize([...state.path, unprocessedKey], []);\n            const report = schema.$_createError('object.unknown', value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });\n            if (prefs.abortEarly) {\n                return { value, errors: report };\n            }\n\n            errors.push(report);\n        }\n    }\n};\n\n\ninternals.Dependency = class {\n\n    constructor(rel, key, peers, paths, options) {\n\n        this.rel = rel;\n        this.key = key;\n        this.peers = peers;\n        this.paths = paths;\n        this.options = options;\n    }\n\n    describe() {\n\n        const desc = {\n            rel: this.rel,\n            peers: this.paths\n        };\n\n        if (this.key !== null) {\n            desc.key = this.key.key;\n        }\n\n        if (this.peers[0].separator !== '.') {\n            desc.options = { ...desc.options, separator: this.peers[0].separator };\n        }\n\n        if (this.options.isPresent) {\n            desc.options = { ...desc.options, isPresent: this.options.isPresent };\n        }\n\n        return desc;\n    }\n};\n\n\ninternals.Keys = class extends Array {\n\n    concat(source) {\n\n        const result = this.slice();\n\n        const keys = new Map();\n        for (let i = 0; i < result.length; ++i) {\n            keys.set(result[i].key, i);\n        }\n\n        for (const item of source) {\n            const key = item.key;\n            const pos = keys.get(key);\n            if (pos !== undefined) {\n                result[pos] = { key, schema: result[pos].schema.concat(item.schema) };\n            }\n            else {\n                result.push(item);\n            }\n        }\n\n        return result;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9rZXlzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHdCQUF3QixtQkFBTyxDQUFDLDhGQUFnQztBQUNoRSxlQUFlLG1CQUFPLENBQUMsNEVBQXVCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQywwRUFBc0I7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLGdFQUFZOztBQUVqQyxZQUFZLG1CQUFPLENBQUMsd0RBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHlEQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFZO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyx5REFBVztBQUNsQyxZQUFZLG1CQUFPLENBQUMsbURBQVE7QUFDNUIsaUJBQWlCLG1CQUFPLENBQUMsNkRBQWE7OztBQUd0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLOztBQUVMOztBQUVBLHdCQUF3QixZQUFZO0FBQ3BDLGdCQUFnQix3QkFBd0IsVUFBVSwrQkFBK0I7QUFDakYsb0JBQW9CLFlBQVk7QUFDaEMsbUJBQW1CO0FBQ25CLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMLHNCQUFzQiw2QkFBNkI7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsc0NBQXNDLG1DQUFtQztBQUM5Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLGVBQWU7QUFDakg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0RBQWtELGtCQUFrQjs7QUFFcEUsNkNBQTZDLHdCQUF3Qiw0QkFBNEI7QUFDakc7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhCQUE4QixxQkFBcUIsSUFBSSwwQkFBMEI7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELGtCQUFrQjtBQUNsRSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsMEJBQTBCLHFCQUFxQjtBQUN2RixhQUFhO0FBQ2IsdUNBQXVDLG1CQUFtQjs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxtQkFBbUI7QUFDN0UsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwwQ0FBMEM7QUFDbkg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHdDQUF3Qyx3QkFBd0IsT0FBTyxpQkFBaUI7QUFDeEYsYUFBYTtBQUNiLHVDQUF1QyxPQUFPLElBQUksc0JBQXNCOztBQUV4RTtBQUNBO0FBQ0E7O0FBRUEseURBQXlELDBCQUEwQjtBQUNuRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSx3Q0FBd0MsdUNBQXVDLE9BQU8sa0JBQWtCO0FBQ3hHO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHdDQUF3Qyx1Q0FBdUMsT0FBTyxrQkFBa0I7QUFDeEc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Qsa0JBQWtCOztBQUVwRTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsY0FBYztBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBLFNBQVM7O0FBRVQ7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsd0NBQXdDLHdCQUF3QixRQUFRO0FBQ3hFLGFBQWE7QUFDYix1Q0FBdUMsTUFBTTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdEQUF3RCxNQUFNO0FBQzlEO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMERBQTBEO0FBQ3JIOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLDRDQUE0QztBQUN6RSwrREFBK0Qsc0JBQXNCO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QixTQUFTLFdBQVcscUJBQXFCLDZCQUE2QixvQkFBb0I7QUFDbkgsNEJBQTRCLFNBQVMsb0JBQW9CLG9JQUFvSTtBQUM3TCwwQkFBMEIsU0FBUyxrQkFBa0IsT0FBTztBQUM1RCw4QkFBOEIsU0FBUyx5QkFBeUIsUUFBUTtBQUN4RSw0QkFBNEIsU0FBUyxZQUFZLFNBQVMsSUFBSSx5QkFBeUI7QUFDdkYseUJBQXlCLFNBQVMsa0NBQWtDLFNBQVMsSUFBSSx5QkFBeUI7QUFDMUcseUJBQXlCLFNBQVMscUJBQXFCLFNBQVMsSUFBSSx5QkFBeUI7QUFDN0YsNkJBQTZCLFNBQVMsK0JBQStCLGtCQUFrQjtBQUN2RiwwQkFBMEIsa0JBQWtCLHFDQUFxQyxrQkFBa0I7QUFDbkcsMEJBQTBCLFNBQVMsdURBQXVELGtCQUFrQjtBQUM1RyxtQ0FBbUMsU0FBUztBQUM1Qyw2QkFBNkIsU0FBUztBQUN0QywyQkFBMkIsU0FBUztBQUNwQyxxQ0FBcUMsU0FBUyxnQkFBZ0IsU0FBUywrRUFBK0UsTUFBTTtBQUM1SixxQ0FBcUMsU0FBUyxnQkFBZ0IsU0FBUywwQ0FBMEMsT0FBTztBQUN4SCw0QkFBNEIsU0FBUywwQkFBMEIsUUFBUTtBQUN2RSw2QkFBNkIsU0FBUztBQUN0QywwQkFBMEIsa0JBQWtCLHdCQUF3QixpQkFBaUI7QUFDckYsNkJBQTZCLGtCQUFrQiwrQkFBK0IsaUJBQWlCO0FBQy9GLHlCQUF5QixTQUFTLDhDQUE4QyxrQkFBa0I7QUFDbEc7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxvQ0FBb0M7QUFDL0UsNkNBQTZDLHNDQUFzQztBQUNuRjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZUFBZTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZUFBZTtBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRSxlQUFlO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0UsZUFBZTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZUFBZTtBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLDRCQUE0QjtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvRkFBb0YsbUJBQW1CO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvRkFBb0YsbUJBQW1CO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixFQUFFO0FBQzdGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxRUFBcUUsMkJBQTJCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHVCQUF1Qix1QkFBdUIsY0FBYztBQUN2SjtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMva2V5cy5qcz9mZDY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXBwbHlUb0RlZmF1bHRzID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXBwbHlUb0RlZmF1bHRzJyk7XG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFRvcG8gPSByZXF1aXJlKCdAaGFwaS90b3BvJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICByZW5hbWVEZWZhdWx0czoge1xuICAgICAgICBhbGlhczogZmFsc2UsICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgb2xkIHZhbHVlIGluIHBsYWNlXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZSwgICAgICAgICAgICAgICAgLy8gQWxsb3cgcmVuYW1pbmcgbXVsdGlwbGUga2V5cyBpbnRvIHRoZSBzYW1lIHRhcmdldFxuICAgICAgICBvdmVycmlkZTogZmFsc2UgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBhbiBleGlzdGluZyBrZXlcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnX2tleXMnLFxuXG4gICAgcHJvcGVydGllczoge1xuXG4gICAgICAgIHR5cGVvZjogJ29iamVjdCdcbiAgICB9LFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICB1bmtub3duOiB7IGRlZmF1bHQ6IHVuZGVmaW5lZCB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAga2V5czogeyBpbml0OiBudWxsLCBtYW5pZmVzdDogeyBtYXBwZWQ6IHsgZnJvbTogJ3NjaGVtYScsIHRvOiAna2V5JyB9IH0gfSxcbiAgICAgICAgcGF0dGVybnM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICByZW5hbWVzOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBhcmdzKHNjaGVtYSwga2V5cykge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEua2V5cyhrZXlzKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09IHNjaGVtYS4kX3Byb3BlcnR5KCd0eXBlb2YnKSB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ29iamVjdC5iYXNlJywgeyB0eXBlOiBzY2hlbWEuJF9wcm9wZXJ0eSgndHlwZW9mJykgfSkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgaWYgdGhlcmUgYXJlIG5vIG90aGVyIHJ1bGVzIHRvIHRlc3RcblxuICAgICAgICBpZiAoIXNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoYWxsb3cgY2xvbmUgdmFsdWVcblxuICAgICAgICB2YWx1ZSA9IGludGVybmFscy5jbG9uZSh2YWx1ZSwgcHJlZnMpO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgICAgICAvLyBSZW5hbWUga2V5c1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5yZW5hbWVzICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxzLnJlbmFtZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGVycm9ycykpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW55dGhpbmcgYWxsb3dlZFxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfdGVybXMua2V5cyAmJiAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBhbGxvd3MgYW55IGtleXNcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmVkIGtleXNcblxuICAgICAgICBjb25zdCB1bnByb2Nlc3NlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwga2V5XSwgYW5jZXN0b3JzLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hpbGQuc2NoZW1hLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5zY2hlbWEuX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJyB8fFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpdGVtICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmtub3duIGtleXNcblxuICAgICAgICBpZiAodW5wcm9jZXNzZWQuc2l6ZSB8fFxuICAgICAgICAgICAgc2NoZW1hLl9mbGFncy5faGFzUGF0dGVybk1hdGNoKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGVhcmx5ID0gaW50ZXJuYWxzLnVua25vd24oc2NoZW1hLCB2YWx1ZSwgdW5wcm9jZXNzZWQsIGVycm9ycywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgIGlmIChlYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYXJseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGRlcGVuZGVuY2llc1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwIG9mIHNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZGVwLmtleSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKShkZXAua2V5LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBpbnRlcm5hbHMuZGVwZW5kZW5jaWVzW2RlcC5yZWxdKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKGZhaWxlZC5jb2RlLCB2YWx1ZSwgZmFpbGVkLmNvbnRleHQsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGFuZDoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnYW5kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ2FuZCcsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhcHBlbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXNzZXJ0OiB7XG4gICAgICAgICAgICBtZXRob2Qoc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIVRlbXBsYXRlLmlzVGVtcGxhdGUoc3ViamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdCA9IENvbXBpbGUucmVmKHN1YmplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnLCAnTWVzc2FnZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Fzc2VydCcsIGFyZ3M6IHsgc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlIH0gfSk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yLCBwcmVmcywgc3RhdGUgfSwgeyBzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWJvdXQgPSBzdWJqZWN0LnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFJlZi5pc1JlZihzdWJqZWN0KSA/IHN1YmplY3QuYWJzb2x1dGUoc3RhdGUpIDogW107XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS4kX21hdGNoKGFib3V0LCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc10sIHNjaGVtYSksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdvYmplY3QuYXNzZXJ0JywgeyBzdWJqZWN0LCBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnc3ViamVjdCcsICdzY2hlbWEnLCAnbWVzc2FnZSddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgbWV0aG9kKGNvbnN0cnVjdG9yLCBuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nLCAnY29uc3RydWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2luc3RhbmNlJywgYXJnczogeyBjb25zdHJ1Y3RvciwgbmFtZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGNvbnN0cnVjdG9yLCBuYW1lIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0Lmluc3RhbmNlJywgeyB0eXBlOiBuYW1lLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbnN0cnVjdG9yJywgJ25hbWUnXVxuICAgICAgICB9LFxuXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JywgJ09iamVjdCBzY2hlbWEgbXVzdCBiZSBhIHZhbGlkIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSksICdPYmplY3Qgc2NoZW1hIGNhbm5vdCBiZSBhIGpvaSBzY2hlbWEnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2NoZW1hKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbGxcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCkgeyAgICAgICAgICAgICAvLyBBbGxvdyBub25lXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBuZXcgaW50ZXJuYWxzLktleXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBvYmouJF90ZXJtcy5rZXlzID8gb2JqLiRfdGVybXMua2V5cy5maWx0ZXIoKGNoaWxkKSA9PiAhc2NoZW1hLmhhc093blByb3BlcnR5KGNoaWxkLmtleSkpIDogbmV3IGludGVybmFscy5LZXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IG9iai4kX3Rlcm1zLmtleXMucHVzaCh7IGtleSwgc2NoZW1hOiB0aGlzLiRfY29tcGlsZShzY2hlbWFba2V5XSkgfSksIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuYW5kOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICduYW5kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ25hbmQnLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ29yJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ29yJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG94b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ294b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgbWV0aG9kKHBhdHRlcm4sIHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlZ0V4cCA9IHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy4kX2NvbXBpbGUocGF0dGVybiwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWEgIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgcnVsZScpO1xuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnZmFsbHRocm91Z2gnLCAnbWF0Y2hlcyddKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1JlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXBhdHRlcm4uZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcGF0dGVybi5mbGFncy5pbmNsdWRlcygneScpLCAncGF0dGVybiBzaG91bGQgbm90IHVzZSBnbG9iYWwgb3Igc3RpY2t5IG1vZGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5wYXR0ZXJucyA9IG9iai4kX3Rlcm1zLnBhdHRlcm5zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHsgW2lzUmVnRXhwID8gJ3JlZ2V4JyA6ICdzY2hlbWEnXTogcGF0dGVybiwgcnVsZTogc2NoZW1hIH07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcubWF0Y2hlcyA9IHRoaXMuJF9jb21waWxlKG9wdGlvbnMubWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubWF0Y2hlcy50eXBlICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcubWF0Y2hlcyA9IGNvbmZpZy5tYXRjaGVzLiRfcm9vdC5hcnJheSgpLml0ZW1zKGNvbmZpZy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKGNvbmZpZy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfc2V0RmxhZygnX2hhc1BhdHRlcm5NYXRjaCcsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZhbGx0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5mYWxsdGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucGF0dGVybnMucHVzaChjb25maWcpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncmVmJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChSZWYuaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnJlZlR5cGUnLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ3JlZ2V4Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC5yZWdleCcsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoZnJvbSwgdG8sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyB8fCBmcm9tIGluc3RhbmNlb2YgUmVnRXhwLCAnUmVuYW1lIG1pc3NpbmcgdGhlIGZyb20gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fCB0byBpbnN0YW5jZW9mIFRlbXBsYXRlLCAnSW52YWxpZCByZW5hbWUgdG8gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodG8gIT09IGZyb20sICdDYW5ub3QgcmVuYW1lIGtleSB0byBzYW1lIG5hbWU6JywgZnJvbSk7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsaWFzJywgJ2lnbm9yZVVuZGVmaW5lZCcsICdvdmVycmlkZScsICdtdWx0aXBsZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlbmFtZXMgPSBvYmouJF90ZXJtcy5yZW5hbWVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVuYW1lIG9mIG9iai4kX3Rlcm1zLnJlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHJlbmFtZS5mcm9tICE9PSBmcm9tLCAnQ2Fubm90IHJlbmFtZSB0aGUgc2FtZSBrZXkgbXVsdGlwbGUgdGltZXMnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodG8gaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih0byk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVuYW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMucmVuYW1lRGVmYXVsdHMsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnYW55Jykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NjaGVtYScsIGFyZ3M6IHsgdHlwZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHR5cGUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09ICdhbnknIHx8IHZhbHVlLnR5cGUgPT09IHR5cGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3Quc2NoZW1hJywgeyB0eXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVua25vd246IHtcbiAgICAgICAgICAgIG1ldGhvZChhbGxvdykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bmtub3duJywgYWxsb3cgIT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRoOiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGgnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRob3V0OiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGhvdXQnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB4b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ3hvcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICd4b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlcnJpZGVzOiB7XG5cbiAgICAgICAgZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfcGFyZW50KCdkZWZhdWx0JywgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYnVpbGQoc2NoZW1hKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcG8gPSBuZXcgVG9wby5Tb3J0ZXIoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgICAgIENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0b3BvLmFkZChjaGlsZCwgeyBhZnRlcjogY2hpbGQuc2NoZW1hLiRfcm9vdFJlZmVyZW5jZXMoKSwgZ3JvdXA6IGNoaWxkLmtleSB9KSwgY2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMua2V5cyA9IG5ldyBpbnRlcm5hbHMuS2V5cyguLi50b3BvLm5vZGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLmtleXMoZGVzYy5rZXlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlbCwga2V5ID0gbnVsbCwgcGVlcnMsIG9wdGlvbnMgfSBvZiBkZXNjLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBpbnRlcm5hbHMuZGVwZW5kZW5jeShvYmosIHJlbCwga2V5LCBwZWVycywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5wYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWdleCwgc2NoZW1hLCBydWxlLCBmYWxsdGhyb3VnaCwgbWF0Y2hlcyB9IG9mIGRlc2MucGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnBhdHRlcm4ocmVnZXggfHwgc2NoZW1hLCBydWxlLCB7IGZhbGx0aHJvdWdoLCBtYXRjaGVzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVuYW1lcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBmcm9tLCB0bywgb3B0aW9ucyB9IG9mIGRlc2MucmVuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucmVuYW1lKGZyb20sIHRvLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ29iamVjdC5hbmQnOiAne3sjbGFiZWx9fSBjb250YWlucyB7eyNwcmVzZW50V2l0aExhYmVsc319IHdpdGhvdXQgaXRzIHJlcXVpcmVkIHBlZXJzIHt7I21pc3NpbmdXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LmFzc2VydCc6ICd7eyNsYWJlbH19IGlzIGludmFsaWQgYmVjYXVzZSB7aWYoI3N1YmplY3Qua2V5LCBgXCJgICsgI3N1YmplY3Qua2V5ICsgYFwiIGZhaWxlZCB0byBgICsgKCNtZXNzYWdlIHx8IFwicGFzcyB0aGUgYXNzZXJ0aW9uIHRlc3RcIiksICNtZXNzYWdlIHx8IFwidGhlIGFzc2VydGlvbiBmYWlsZWRcIil9JyxcbiAgICAgICAgJ29iamVjdC5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBvZiB0eXBlIHt7I3R5cGV9fScsXG4gICAgICAgICdvYmplY3QuaW5zdGFuY2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHt7OiN0eXBlfX0nLFxuICAgICAgICAnb2JqZWN0Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWluJzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGF0IGxlYXN0IHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taXNzaW5nJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QubmFuZCc6ICd7ezojbWFpbldpdGhMYWJlbH19IG11c3Qgbm90IGV4aXN0IHNpbXVsdGFuZW91c2x5IHdpdGgge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0Lm94b3InOiAne3sjbGFiZWx9fSBjb250YWlucyBhIGNvbmZsaWN0IGJldHdlZW4gb3B0aW9uYWwgZXhjbHVzaXZlIHBlZXJzIHt7I3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgJ29iamVjdC5wYXR0ZXJuLm1hdGNoJzogJ3t7I2xhYmVsfX0ga2V5cyBmYWlsZWQgdG8gbWF0Y2ggcGF0dGVybiByZXF1aXJlbWVudHMnLFxuICAgICAgICAnb2JqZWN0LnJlZlR5cGUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgSm9pIHJlZmVyZW5jZScsXG4gICAgICAgICdvYmplY3QucmVnZXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgUmVnRXhwIG9iamVjdCcsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm11bHRpcGxlJzogJ3t7I2xhYmVsfX0gY2Fubm90IHJlbmFtZSB7ezojZnJvbX19IGJlY2F1c2UgbXVsdGlwbGUgcmVuYW1lcyBhcmUgZGlzYWJsZWQgYW5kIGFub3RoZXIga2V5IHdhcyBhbHJlYWR5IHJlbmFtZWQgdG8ge3s6I3RvfX0nLFxuICAgICAgICAnb2JqZWN0LnJlbmFtZS5vdmVycmlkZSc6ICd7eyNsYWJlbH19IGNhbm5vdCByZW5hbWUge3s6I2Zyb219fSBiZWNhdXNlIG92ZXJyaWRlIGlzIGRpc2FibGVkIGFuZCB0YXJnZXQge3s6I3RvfX0gZXhpc3RzJyxcbiAgICAgICAgJ29iamVjdC5zY2hlbWEnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgSm9pIHNjaGVtYSBvZiB7eyN0eXBlfX0gdHlwZScsXG4gICAgICAgICdvYmplY3QudW5rbm93bic6ICd7eyNsYWJlbH19IGlzIG5vdCBhbGxvd2VkJyxcbiAgICAgICAgJ29iamVjdC53aXRoJzogJ3t7OiNtYWluV2l0aExhYmVsfX0gbWlzc2luZyByZXF1aXJlZCBwZWVyIHt7OiNwZWVyV2l0aExhYmVsfX0nLFxuICAgICAgICAnb2JqZWN0LndpdGhvdXQnOiAne3s6I21haW5XaXRoTGFiZWx9fSBjb25mbGljdCB3aXRoIGZvcmJpZGRlbiBwZWVyIHt7OiNwZWVyV2l0aExhYmVsfX0nLFxuICAgICAgICAnb2JqZWN0Lnhvcic6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuY2xvbmUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWZzKSB7XG5cbiAgICAvLyBPYmplY3RcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChwcmVmcy5ub25FbnVtZXJhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKHZhbHVlLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY2xvbmUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uXG5cbiAgICBjb25zdCBjbG9uZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjbG9uZS5wcm90b3R5cGUgPSBDbG9uZSh2YWx1ZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgJ25hbWUnLCB7IHZhbHVlOiB2YWx1ZS5uYW1lLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbGVuZ3RoJywgeyB2YWx1ZTogdmFsdWUubGVuZ3RoLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY3kgPSBmdW5jdGlvbiAoc2NoZW1hLCByZWwsIGtleSwgcGVlcnMsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChrZXkgPT09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycsIHJlbCwgJ2tleSBtdXN0IGJlIGEgc3RyaW5ncycpO1xuXG4gICAgLy8gRXh0cmFjdCBvcHRpb25zIGZyb20gcGVlcnMgYXJyYXlcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcGVlcnMubGVuZ3RoID4gMSAmJiB0eXBlb2YgcGVlcnNbcGVlcnMubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnID8gcGVlcnMucG9wKCkgOiB7fTtcbiAgICB9XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3NlcGFyYXRvcicsICdpc1ByZXNlbnQnXSk7XG5cbiAgICBwZWVycyA9IFtdLmNvbmNhdChwZWVycyk7XG5cbiAgICAvLyBDYXN0IHBlZXIgcGF0aHNcblxuICAgIGNvbnN0IHNlcGFyYXRvciA9IENvbW1vbi5kZWZhdWx0KG9wdGlvbnMuc2VwYXJhdG9yLCAnLicpO1xuICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgZm9yIChjb25zdCBwZWVyIG9mIHBlZXJzKSB7XG4gICAgICAgIEFzc2VydCh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycsIHJlbCwgJ3BlZXJzIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICBwYXRocy5wdXNoKENvbXBpbGUucmVmKHBlZXIsIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCwgcHJlZml4OiBmYWxzZSB9KSk7XG4gICAgfVxuXG4gICAgLy8gQ2FzdCBrZXlcblxuICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAga2V5ID0gQ29tcGlsZS5yZWYoa2V5LCB7IHNlcGFyYXRvciwgYW5jZXN0b3I6IDAsIHByZWZpeDogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJ1bGVcblxuICAgIGNvbnN0IG9iaiA9IHNjaGVtYS5jbG9uZSgpO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcyA9IG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcyB8fCBbXTtcbiAgICBvYmouJF90ZXJtcy5kZXBlbmRlbmNpZXMucHVzaChuZXcgaW50ZXJuYWxzLkRlcGVuZGVuY3kocmVsLCBrZXksIHBhdGhzLCBwZWVycywgb3B0aW9ucykpO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5kZXBlbmRlbmNpZXMgPSB7XG5cbiAgICBhbmQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBkZXAucGVlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCAhPT0gY291bnQgJiZcbiAgICAgICAgICAgIHByZXNlbnQubGVuZ3RoICE9PSBjb3VudCkge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3QuYW5kJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnRXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCksXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcsXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgbWlzc2luZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5hbmQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCAhPT0gZGVwLnBlZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFpbiA9IGRlcC5wYXRoc1swXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZGVwLnBhdGhzLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogJ29iamVjdC5uYW5kJyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBtYWluLFxuICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBtYWluKSxcbiAgICAgICAgICAgICAgICBwZWVyczogdmFsdWVzLFxuICAgICAgICAgICAgICAgIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHZhbHVlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiAnb2JqZWN0Lm1pc3NpbmcnLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIHBlZXJzOiBkZXAucGF0aHMsXG4gICAgICAgICAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBveG9yKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXNlbnQubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZXh0ID0geyBwZWVyczogZGVwLnBhdGhzLCBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpIH07XG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3Qub3hvcicsIGNvbnRleHQgfTtcbiAgICB9LFxuXG4gICAgd2l0aChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3Qud2l0aCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGRlcC5rZXkua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5rZXkua2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXI6IHBlZXIua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHBlZXIua2V5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3aXRob3V0KHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gaW50ZXJuYWxzLmlzUHJlc2VudChkZXAub3B0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LndpdGhvdXQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkZXAua2V5LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAua2V5LmtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyOiBwZWVyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwZWVyLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgeG9yKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IHBlZXJzOiBkZXAucGF0aHMsIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocykgfTtcbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb2RlOiAnb2JqZWN0Lm1pc3NpbmcnLCBjb250ZXh0IH07XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnByZXNlbnQgPSBwcmVzZW50O1xuICAgICAgICBjb250ZXh0LnByZXNlbnRXaXRoTGFiZWxzID0gaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHByZXNlbnQpO1xuICAgICAgICByZXR1cm4geyBjb2RlOiAnb2JqZWN0LnhvcicsIGNvbnRleHQgfTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5rZXlzVG9MYWJlbHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBrZXlzKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICByZXR1cm4ga2V5cy5tYXAoKGtleSkgPT4gc2NoZW1hLiRfbWFwTGFiZWxzKGtleSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5cyk7XG59O1xuXG5cbmludGVybmFscy5pc1ByZXNlbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zLmlzUHJlc2VudCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuaXNQcmVzZW50IDogKHJlc29sdmVkKSA9PiByZXNvbHZlZCAhPT0gdW5kZWZpbmVkO1xufTtcblxuXG5pbnRlcm5hbHMucmVuYW1lID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcywgZXJyb3JzKSB7XG5cbiAgICBjb25zdCByZW5hbWVkID0ge307XG4gICAgZm9yIChjb25zdCByZW5hbWUgb2Ygc2NoZW1hLiRfdGVybXMucmVuYW1lcykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0eXBlb2YgcmVuYW1lLmZyb20gIT09ICdzdHJpbmcnO1xuXG4gICAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVuYW1lLmZyb20pICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlW3JlbmFtZS5mcm9tXSAhPT0gdW5kZWZpbmVkIHx8ICFyZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQpKSB7XG5cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gocmVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJvbSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtmcm9tXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHJlbmFtZS5vcHRpb25zLmlnbm9yZVVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSByZW5hbWUudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZW5hbWUuZnJvbS5leGVjKGZyb20pO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHsgZnJvbSwgdG86IHJlbmFtZS50bywgbWF0Y2ggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBtYXRjaC5mcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gbWF0Y2gudG87XG4gICAgICAgICAgICBpZiAodG8gaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHRvID0gdG8ucmVuZGVyKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG1hdGNoLm1hdGNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgICAgICByZW5hbWVkW3RvXSkge1xuXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5yZW5hbWUubXVsdGlwbGUnLCB2YWx1ZSwgeyBmcm9tLCB0bywgcGF0dGVybiB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCB0bykgJiZcbiAgICAgICAgICAgICAgICAhcmVuYW1lLm9wdGlvbnMub3ZlcnJpZGUgJiZcbiAgICAgICAgICAgICAgICAhcmVuYW1lZFt0b10pIHtcblxuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLm92ZXJyaWRlJywgdmFsdWUsIHsgZnJvbSwgdG8sIHBhdHRlcm4gfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlW2Zyb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbdG9dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbdG9dID0gdmFsdWVbZnJvbV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmFtZWRbdG9dID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5hbGlhcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtmcm9tXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMudW5rbm93biA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCB1bnByb2Nlc3NlZCwgZXJyb3JzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucykge1xuICAgICAgICBsZXQgaGFzTWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gc2NoZW1hLiRfdGVybXMucGF0dGVybnMubWFwKChwYXR0ZXJuKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gWy4uLnN0YXRlLnBhdGgsIGtleV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLiRfdGVybXMucGF0dGVybnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2NoZW1hLiRfdGVybXMucGF0dGVybnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXR0ZXJuLnJlZ2V4LnRlc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAncnVsZScsIGBwYXR0ZXJuLiR7aX1gLCBtYXRjaCA/ICdwYXNzJyA6ICdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLnNjaGVtYS4kX21hdGNoKGtleSwgc3RhdGUubmVzdChwYXR0ZXJuLnNjaGVtYSwgYHBhdHRlcm4uJHtpfWApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCB7IHNjaGVtYTogcGF0dGVybi5ydWxlLCBrZXkgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGF0dGVybi5ydWxlLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXN1bHQuZXJyb3JzIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbaV0ucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLmZhbGx0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHBhdHRlcm4gbWF0Y2hlcyBydWxlc1xuXG4gICAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzdHBtID0gc2NoZW1hLiRfdGVybXMucGF0dGVybnNbaV0ubWF0Y2hlcztcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoc3RhdGUucGF0aCwgYW5jZXN0b3JzLCBzdHBtKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdHBtLiRfdmFsaWRhdGUobWF0Y2gsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gRXJyb3JzLmRldGFpbHMocmVzdWx0LmVycm9ycywgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnBhdHRlcm4ubWF0Y2gnLCB2YWx1ZSwgZGV0YWlscywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlcG9ydCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVucHJvY2Vzc2VkLnNpemUgfHxcbiAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmtleXMgJiYgIXNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zKSB7ICAgICAvLyBJZiBubyBrZXlzIG9yIHBhdHRlcm5zIHNwZWNpZmllZCwgdW5rbm93biBrZXlzIGFsbG93ZWRcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByZWZzLnN0cmlwVW5rbm93biAmJiB0eXBlb2Ygc2NoZW1hLl9mbGFncy51bmtub3duID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICBwcmVmcy5za2lwRnVuY3Rpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gcHJlZnMuc3RyaXBVbmtub3duID8gKHByZWZzLnN0cmlwVW5rbm93biA9PT0gdHJ1ZSA/IHRydWUgOiAhIXByZWZzLnN0cmlwVW5rbm93bi5vYmplY3RzKSA6IGZhbHNlO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9yYmlkVW5rbm93biA9ICFDb21tb24uZGVmYXVsdChzY2hlbWEuX2ZsYWdzLnVua25vd24sIHByZWZzLmFsbG93VW5rbm93bik7XG4gICAgaWYgKGZvcmJpZFVua25vd24pIHtcbiAgICAgICAgZm9yIChjb25zdCB1bnByb2Nlc3NlZEtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCB1bnByb2Nlc3NlZEtleV0sIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QudW5rbm93bicsIHZhbHVlW3VucHJvY2Vzc2VkS2V5XSwgeyBjaGlsZDogdW5wcm9jZXNzZWRLZXkgfSwgbG9jYWxTdGF0ZSwgcHJlZnMsIHsgZmxhZ3M6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkRlcGVuZGVuY3kgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWwsIGtleSwgcGVlcnMsIHBhdGhzLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5yZWwgPSByZWw7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnBlZXJzID0gcGVlcnM7XG4gICAgICAgIHRoaXMucGF0aHMgPSBwYXRocztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjID0ge1xuICAgICAgICAgICAgcmVsOiB0aGlzLnJlbCxcbiAgICAgICAgICAgIHBlZXJzOiB0aGlzLnBhdGhzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMua2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZXNjLmtleSA9IHRoaXMua2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBlZXJzWzBdLnNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB7IC4uLmRlc2Mub3B0aW9ucywgc2VwYXJhdG9yOiB0aGlzLnBlZXJzWzBdLnNlcGFyYXRvciB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlc2Mub3B0aW9ucyA9IHsgLi4uZGVzYy5vcHRpb25zLCBpc1ByZXNlbnQ6IHRoaXMub3B0aW9ucy5pc1ByZXNlbnQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLktleXMgPSBjbGFzcyBleHRlbmRzIEFycmF5IHtcblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNsaWNlKCk7XG5cbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGtleXMuc2V0KHJlc3VsdFtpXS5rZXksIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaXRlbS5rZXk7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBrZXlzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Bvc10gPSB7IGtleSwgc2NoZW1hOiByZXN1bHRbcG9zXS5zY2hlbWEuY29uY2F0KGl0ZW0uc2NoZW1hKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/keys.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/link.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/link.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'link',\n\n    properties: {\n        schemaChain: true\n    },\n\n    terms: {\n\n        link: { init: null, manifest: 'single', register: false }\n    },\n\n    args(schema, ref) {\n\n        return schema.ref(ref);\n    },\n\n    validate(value, { schema, state, prefs }) {\n\n        Assert(schema.$_terms.link, 'Uninitialized link schema');\n\n        const linked = internals.generate(schema, value, state, prefs);\n        const ref = schema.$_terms.link[0].ref;\n        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);\n    },\n\n    generate(schema, value, state, prefs) {\n\n        return internals.generate(schema, value, state, prefs);\n    },\n\n    rules: {\n\n        ref: {\n            method(ref) {\n\n                Assert(!this.$_terms.link, 'Cannot reinitialize schema');\n\n                ref = Compile.ref(ref);\n\n                Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);\n                Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');\n\n                const obj = this.clone();\n                obj.$_terms.link = [{ ref }];\n                return obj;\n            }\n        },\n\n        relative: {\n            method(enabled = true) {\n\n                return this.$_setFlag('relative', enabled);\n            }\n        }\n    },\n\n    overrides: {\n\n        concat(source) {\n\n            Assert(this.$_terms.link, 'Uninitialized link schema');\n            Assert(Common.isSchema(source), 'Invalid schema object');\n            Assert(source.type !== 'link', 'Cannot merge type link with another link');\n\n            const obj = this.clone();\n\n            if (!obj.$_terms.whens) {\n                obj.$_terms.whens = [];\n            }\n\n            obj.$_terms.whens.push({ concat: source });\n            return obj.$_mutateRebuild();\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            Assert(desc.link, 'Invalid link description missing link');\n            return obj.ref(desc.link);\n        }\n    }\n});\n\n\n// Helpers\n\ninternals.generate = function (schema, value, state, prefs) {\n\n    let linked = state.mainstay.links.get(schema);\n    if (linked) {\n        return linked._generate(value, state, prefs).schema;\n    }\n\n    const ref = schema.$_terms.link[0].ref;\n    const { perspective, path } = internals.perspective(ref, state);\n    internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);\n\n    try {\n        linked = path.length ? perspective.$_reach(path) : perspective;\n    }\n    catch (ignoreErr) {\n        internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);\n    }\n\n    internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);\n\n    if (!schema._flags.relative) {\n        state.mainstay.links.set(schema, linked);\n    }\n\n    return linked._generate(value, state, prefs).schema;\n};\n\n\ninternals.perspective = function (ref, state) {\n\n    if (ref.type === 'local') {\n        for (const { schema, key } of state.schemas) {                              // From parent to root\n            const id = schema._flags.id || key;\n            if (id === ref.path[0]) {\n                return { perspective: schema, path: ref.path.slice(1) };\n            }\n\n            if (schema.$_terms.shared) {\n                for (const shared of schema.$_terms.shared) {\n                    if (shared._flags.id === ref.path[0]) {\n                        return { perspective: shared, path: ref.path.slice(1) };\n                    }\n                }\n            }\n        }\n\n        return { perspective: null, path: null };\n    }\n\n    if (ref.ancestor === 'root') {\n        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };\n    }\n\n    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };\n};\n\n\ninternals.assert = function (condition, message, ref, schema, state, prefs) {\n\n    if (condition) {                // Manual check to avoid generating error message on success\n        return;\n    }\n\n    Assert(false, `\"${Errors.label(schema._flags, state, prefs)}\" contains link reference \"${ref.display}\" ${message}`);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9saW5rLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw0RUFBdUI7O0FBRTlDLFlBQVksbUJBQU8sQ0FBQyx3REFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMseURBQVc7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVk7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLHlEQUFXOzs7QUFHbEM7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLGdCQUFnQjtBQUNoQixLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxzQkFBc0Isc0JBQXNCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FLFlBQVksR0FBRyxZQUFZO0FBQzlGLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxxQkFBcUIsY0FBYyxpREFBaUQ7QUFDcEY7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLGFBQWE7QUFDYjs7O0FBR0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUEsc0JBQXNCLDBDQUEwQyw2QkFBNkIsWUFBWSxJQUFJLFFBQVE7QUFDckgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MaXN0ZW4vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9saW5rLmpzPzg2NDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4uL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnbGluaycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHNjaGVtYUNoYWluOiB0cnVlXG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgbGluazogeyBpbml0OiBudWxsLCBtYW5pZmVzdDogJ3NpbmdsZScsIHJlZ2lzdGVyOiBmYWxzZSB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCByZWYpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLnJlZihyZWYpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgQXNzZXJ0KHNjaGVtYS4kX3Rlcm1zLmxpbmssICdVbmluaXRpYWxpemVkIGxpbmsgc2NoZW1hJyk7XG5cbiAgICAgICAgY29uc3QgbGlua2VkID0gaW50ZXJuYWxzLmdlbmVyYXRlKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHNjaGVtYS4kX3Rlcm1zLmxpbmtbMF0ucmVmO1xuICAgICAgICByZXR1cm4gbGlua2VkLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3QobGlua2VkLCBgbGluazoke3JlZi5kaXNwbGF5fToke2xpbmtlZC50eXBlfWApLCBwcmVmcyk7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIG1ldGhvZChyZWYpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy4kX3Rlcm1zLmxpbmssICdDYW5ub3QgcmVpbml0aWFsaXplIHNjaGVtYScpO1xuXG4gICAgICAgICAgICAgICAgcmVmID0gQ29tcGlsZS5yZWYocmVmKTtcblxuICAgICAgICAgICAgICAgIEFzc2VydChyZWYudHlwZSA9PT0gJ3ZhbHVlJyB8fCByZWYudHlwZSA9PT0gJ2xvY2FsJywgJ0ludmFsaWQgcmVmZXJlbmNlIHR5cGU6JywgcmVmLnR5cGUpO1xuICAgICAgICAgICAgICAgIEFzc2VydChyZWYudHlwZSA9PT0gJ2xvY2FsJyB8fCByZWYuYW5jZXN0b3IgPT09ICdyb290JyB8fCByZWYuYW5jZXN0b3IgPiAwLCAnTGluayBjYW5ub3QgcmVmZXJlbmNlIGl0c2VsZicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmxpbmsgPSBbeyByZWYgfV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWxhdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3JlbGF0aXZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlcnJpZGVzOiB7XG5cbiAgICAgICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgICAgICBBc3NlcnQodGhpcy4kX3Rlcm1zLmxpbmssICdVbmluaXRpYWxpemVkIGxpbmsgc2NoZW1hJyk7XG4gICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSksICdJbnZhbGlkIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgICAgIEFzc2VydChzb3VyY2UudHlwZSAhPT0gJ2xpbmsnLCAnQ2Fubm90IG1lcmdlIHR5cGUgbGluayB3aXRoIGFub3RoZXIgbGluaycpO1xuXG4gICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy53aGVucyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouJF90ZXJtcy53aGVucy5wdXNoKHsgY29uY2F0OiBzb3VyY2UgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIEFzc2VydChkZXNjLmxpbmssICdJbnZhbGlkIGxpbmsgZGVzY3JpcHRpb24gbWlzc2luZyBsaW5rJyk7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnJlZihkZXNjLmxpbmspO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBsZXQgbGlua2VkID0gc3RhdGUubWFpbnN0YXkubGlua3MuZ2V0KHNjaGVtYSk7XG4gICAgaWYgKGxpbmtlZCkge1xuICAgICAgICByZXR1cm4gbGlua2VkLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG4gICAgfVxuXG4gICAgY29uc3QgcmVmID0gc2NoZW1hLiRfdGVybXMubGlua1swXS5yZWY7XG4gICAgY29uc3QgeyBwZXJzcGVjdGl2ZSwgcGF0aCB9ID0gaW50ZXJuYWxzLnBlcnNwZWN0aXZlKHJlZiwgc3RhdGUpO1xuICAgIGludGVybmFscy5hc3NlcnQocGVyc3BlY3RpdmUsICd3aGljaCBpcyBvdXRzaWRlIG9mIHNjaGVtYSBib3VuZGFyaWVzJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICB0cnkge1xuICAgICAgICBsaW5rZWQgPSBwYXRoLmxlbmd0aCA/IHBlcnNwZWN0aXZlLiRfcmVhY2gocGF0aCkgOiBwZXJzcGVjdGl2ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGlnbm9yZUVycikge1xuICAgICAgICBpbnRlcm5hbHMuYXNzZXJ0KGZhbHNlLCAndG8gbm9uLWV4aXN0aW5nIHNjaGVtYScsIHJlZiwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIGludGVybmFscy5hc3NlcnQobGlua2VkLnR5cGUgIT09ICdsaW5rJywgJ3doaWNoIGlzIGFub3RoZXIgbGluaycsIHJlZiwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpO1xuXG4gICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnJlbGF0aXZlKSB7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmxpbmtzLnNldChzY2hlbWEsIGxpbmtlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmtlZC5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xufTtcblxuXG5pbnRlcm5hbHMucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAocmVmLCBzdGF0ZSkge1xuXG4gICAgaWYgKHJlZi50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBzY2hlbWEsIGtleSB9IG9mIHN0YXRlLnNjaGVtYXMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGcm9tIHBhcmVudCB0byByb290XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNjaGVtYS5fZmxhZ3MuaWQgfHwga2V5O1xuICAgICAgICAgICAgaWYgKGlkID09PSByZWYucGF0aFswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzY2hlbWEsIHBhdGg6IHJlZi5wYXRoLnNsaWNlKDEpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5zaGFyZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNoYXJlZCBvZiBzY2hlbWEuJF90ZXJtcy5zaGFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXJlZC5fZmxhZ3MuaWQgPT09IHJlZi5wYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc2hhcmVkLCBwYXRoOiByZWYucGF0aC5zbGljZSgxKSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IG51bGwsIHBhdGg6IG51bGwgfTtcbiAgICB9XG5cbiAgICBpZiAocmVmLmFuY2VzdG9yID09PSAncm9vdCcpIHtcbiAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHN0YXRlLnNjaGVtYXNbc3RhdGUuc2NoZW1hcy5sZW5ndGggLSAxXS5zY2hlbWEsIHBhdGg6IHJlZi5wYXRoIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHN0YXRlLnNjaGVtYXNbcmVmLmFuY2VzdG9yXSAmJiBzdGF0ZS5zY2hlbWFzW3JlZi5hbmNlc3Rvcl0uc2NoZW1hLCBwYXRoOiByZWYucGF0aCB9O1xufTtcblxuXG5pbnRlcm5hbHMuYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgbWVzc2FnZSwgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKGNvbmRpdGlvbikgeyAgICAgICAgICAgICAgICAvLyBNYW51YWwgY2hlY2sgdG8gYXZvaWQgZ2VuZXJhdGluZyBlcnJvciBtZXNzYWdlIG9uIHN1Y2Nlc3NcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEFzc2VydChmYWxzZSwgYFwiJHtFcnJvcnMubGFiZWwoc2NoZW1hLl9mbGFncywgc3RhdGUsIHByZWZzKX1cIiBjb250YWlucyBsaW5rIHJlZmVyZW5jZSBcIiR7cmVmLmRpc3BsYXl9XCIgJHttZXNzYWdlfWApO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/link.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/number.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/number.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    numberRx: /^\\s*[+-]?(?:(?:\\d+(?:\\.\\d*)?)|(?:\\.\\d+))(?:e([+-]?\\d+))?\\s*$/i,\n    precisionRx: /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/,\n    exponentialPartRegex: /[eE][+-]?\\d+$/,\n    leadingSignAndZerosRegex: /^[+-]?(0*)?/,\n    dotRegex: /\\./,\n    trailingZerosRegex: /0+$/,\n    decimalPlaces(value) {\n\n        const str = value.toString();\n        const dindex = str.indexOf('.');\n        const eindex = str.indexOf('e');\n        return (\n            (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) +\n            (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))))\n        );\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'number',\n\n    flags: {\n\n        unsafe: { default: false }\n    },\n\n    coerce: {\n        from: 'string',\n        method(value, { schema, error }) {\n\n            const matches = value.match(internals.numberRx);\n            if (!matches) {\n                return;\n            }\n\n            value = value.trim();\n            const result = { value: parseFloat(value) };\n\n            if (result.value === 0) {\n                result.value = 0;           // -0\n            }\n\n            if (!schema._flags.unsafe) {\n                if (value.match(/e/i)) {\n                    if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {\n                        result.errors = error('number.unsafe');\n                        return result;\n                    }\n                }\n                else {\n                    const string = result.value.toString();\n                    if (string.match(/e/i)) {\n                        return result;\n                    }\n\n                    if (string !== internals.normalizeDecimal(value)) {\n                        result.errors = error('number.unsafe');\n                        return result;\n                    }\n                }\n            }\n\n            return result;\n        }\n    },\n\n    validate(value, { schema, error, prefs }) {\n\n        if (value === Infinity ||\n            value === -Infinity) {\n\n            return { value, errors: error('number.infinity') };\n        }\n\n        if (!Common.isNumber(value)) {\n            return { value, errors: error('number.base') };\n        }\n\n        const result = { value };\n\n        if (prefs.convert) {\n            const rule = schema.$_getRule('precision');\n            if (rule) {\n                const precision = Math.pow(10, rule.args.limit);                    // This is conceptually equivalent to using toFixed but it should be much faster\n                result.value = Math.round(result.value * precision) / precision;\n            }\n        }\n\n        if (result.value === 0) {\n            result.value = 0;           // -0\n        }\n\n        if (!schema._flags.unsafe &&\n            (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {\n\n            result.errors = error('number.unsafe');\n        }\n\n        return result;\n    },\n\n    rules: {\n\n        compare: {\n            method: false,\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('number.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.isNumber,\n                    message: 'must be a number'\n                }\n            ]\n        },\n\n        greater: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'greater', method: 'compare', args: { limit }, operator: '>' });\n            }\n        },\n\n        integer: {\n            method() {\n\n                return this.$_addRule('integer');\n            },\n            validate(value, helpers) {\n\n                if (Math.trunc(value) - value === 0) {\n                    return value;\n                }\n\n                return helpers.error('number.integer');\n            }\n        },\n\n        less: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'less', method: 'compare', args: { limit }, operator: '<' });\n            }\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'compare', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'compare', args: { limit }, operator: '>=' });\n            }\n        },\n\n        multiple: {\n            method(base) {\n\n                const baseDecimalPlace = typeof base === 'number' ? internals.decimalPlaces(base) : null;\n                const pfactor = Math.pow(10, baseDecimalPlace);\n\n                return this.$_addRule({\n                    name: 'multiple',\n                    args: {\n                        base,\n                        baseDecimalPlace,\n                        pfactor\n                    }\n                });\n            },\n            validate(value, helpers, { base, baseDecimalPlace, pfactor }, options) {\n\n                const valueDecimalPlace = internals.decimalPlaces(value);\n\n                if (valueDecimalPlace > baseDecimalPlace) {\n                    // Value with higher precision than base can never be a multiple\n                    return helpers.error('number.multiple', { multiple: options.args.base, value });\n                }\n\n                return Math.round(pfactor * value) % Math.round(pfactor * base) === 0 ?\n                    value :\n                    helpers.error('number.multiple', { multiple: options.args.base, value });\n            },\n            args: [\n                {\n                    name: 'base',\n                    ref: true,\n                    assert: (value) => typeof value === 'number' && isFinite(value) && value > 0,\n                    message: 'must be a positive number'\n                },\n                'baseDecimalPlace',\n                'pfactor'\n            ],\n            multi: true\n        },\n\n        negative: {\n            method() {\n\n                return this.sign('negative');\n            }\n        },\n\n        port: {\n            method() {\n\n                return this.$_addRule('port');\n            },\n            validate(value, helpers) {\n\n                if (Number.isSafeInteger(value) &&\n                    value >= 0 &&\n                    value <= 65535) {\n\n                    return value;\n                }\n\n                return helpers.error('number.port');\n            }\n        },\n\n        positive: {\n            method() {\n\n                return this.sign('positive');\n            }\n        },\n\n        precision: {\n            method(limit) {\n\n                Assert(Number.isSafeInteger(limit), 'limit must be an integer');\n\n                return this.$_addRule({ name: 'precision', args: { limit } });\n            },\n            validate(value, helpers, { limit }) {\n\n                const places = value.toString().match(internals.precisionRx);\n                const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n                if (decimals <= limit) {\n                    return value;\n                }\n\n                return helpers.error('number.precision', { limit, value });\n            },\n            convert: true\n        },\n\n        sign: {\n            method(sign) {\n\n                Assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);\n\n                return this.$_addRule({ name: 'sign', args: { sign } });\n            },\n            validate(value, helpers, { sign }) {\n\n                if (sign === 'negative' && value < 0 ||\n                    sign === 'positive' && value > 0) {\n\n                    return value;\n                }\n\n                return helpers.error(`number.${sign}`);\n            }\n        },\n\n        unsafe: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_setFlag('unsafe', enabled);\n            }\n        }\n    },\n\n    cast: {\n        string: {\n            from: (value) => typeof value === 'number',\n            to(value, helpers) {\n\n                return value.toString();\n            }\n        }\n    },\n\n    messages: {\n        'number.base': '{{#label}} must be a number',\n        'number.greater': '{{#label}} must be greater than {{#limit}}',\n        'number.infinity': '{{#label}} cannot be infinity',\n        'number.integer': '{{#label}} must be an integer',\n        'number.less': '{{#label}} must be less than {{#limit}}',\n        'number.max': '{{#label}} must be less than or equal to {{#limit}}',\n        'number.min': '{{#label}} must be greater than or equal to {{#limit}}',\n        'number.multiple': '{{#label}} must be a multiple of {{#multiple}}',\n        'number.negative': '{{#label}} must be a negative number',\n        'number.port': '{{#label}} must be a valid port',\n        'number.positive': '{{#label}} must be a positive number',\n        'number.precision': '{{#label}} must have no more than {{#limit}} decimal places',\n        'number.unsafe': '{{#label}} must be a safe number'\n    }\n});\n\n\n// Helpers\n\ninternals.extractSignificantDigits = function (value) {\n\n    return value\n        .replace(internals.exponentialPartRegex, '')\n        .replace(internals.dotRegex, '')\n        .replace(internals.trailingZerosRegex, '')\n        .replace(internals.leadingSignAndZerosRegex, '');\n};\n\n\ninternals.normalizeDecimal = function (str) {\n\n    str = str\n        // Remove leading plus signs\n        .replace(/^\\+/, '')\n        // Remove trailing zeros if there is a decimal point and unecessary decimal points\n        .replace(/\\.0*$/, '')\n        // Add a integer 0 if the numbers starts with a decimal point\n        .replace(/^(-?)\\.([^\\.]*)$/, '$10.$2')\n        // Remove leading zeros\n        .replace(/^(-?)0+([0-9])/, '$1$2');\n\n    if (str.includes('.') &&\n        str.endsWith('0')) {\n\n        str = str.replace(/0+$/, '');\n    }\n\n    if (str === '-0') {\n        return '0';\n    }\n\n    return str;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1Qjs7QUFFOUMsWUFBWSxtQkFBTyxDQUFDLHdEQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyx5REFBVzs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNCQUFzQixzQkFBc0I7O0FBRTVDO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTyxJQUFJLHNCQUFzQjs7QUFFeEU7QUFDQTtBQUNBOztBQUVBLHlEQUF5RCwwQkFBMEI7QUFDbkYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsd0NBQXdDLDRDQUE0QyxPQUFPLGlCQUFpQjtBQUM1RztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSx3Q0FBd0MseUNBQXlDLE9BQU8saUJBQWlCO0FBQ3pHO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHdDQUF3Qyx3Q0FBd0MsT0FBTyxrQkFBa0I7QUFDekc7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsd0NBQXdDLHdDQUF3QyxPQUFPLGtCQUFrQjtBQUN6RztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYix1Q0FBdUMsaUNBQWlDOztBQUV4RTs7QUFFQTtBQUNBO0FBQ0EsOERBQThELG9DQUFvQztBQUNsRzs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELG9DQUFvQztBQUMzRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLHdDQUF3QywyQkFBMkIsU0FBUztBQUM1RSxhQUFhO0FBQ2IsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELGNBQWM7QUFDekUsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLHdDQUF3QyxzQkFBc0IsUUFBUTtBQUN0RSxhQUFhO0FBQ2IsdUNBQXVDLE1BQU07O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwwQkFBMEIsU0FBUztBQUNuQyw2QkFBNkIsU0FBUyx1QkFBdUIsUUFBUTtBQUNyRSw4QkFBOEIsU0FBUztBQUN2Qyw2QkFBNkIsU0FBUztBQUN0QywwQkFBMEIsU0FBUyxvQkFBb0IsUUFBUTtBQUMvRCx5QkFBeUIsU0FBUyxnQ0FBZ0MsUUFBUTtBQUMxRSx5QkFBeUIsU0FBUyxtQ0FBbUMsUUFBUTtBQUM3RSw4QkFBOEIsU0FBUyx3QkFBd0IsV0FBVztBQUMxRSw4QkFBOEIsU0FBUztBQUN2QywwQkFBMEIsU0FBUztBQUNuQyw4QkFBOEIsU0FBUztBQUN2QywrQkFBK0IsU0FBUyx5QkFBeUIsU0FBUztBQUMxRSw0QkFBNEIsU0FBUztBQUNyQztBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL251bWJlci5qcz85YzYwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbnVtYmVyUng6IC9eXFxzKlsrLV0/KD86KD86XFxkKyg/OlxcLlxcZCopPyl8KD86XFwuXFxkKykpKD86ZShbKy1dP1xcZCspKT9cXHMqJC9pLFxuICAgIHByZWNpc2lvblJ4OiAvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvLFxuICAgIGV4cG9uZW50aWFsUGFydFJlZ2V4OiAvW2VFXVsrLV0/XFxkKyQvLFxuICAgIGxlYWRpbmdTaWduQW5kWmVyb3NSZWdleDogL15bKy1dPygwKik/LyxcbiAgICBkb3RSZWdleDogL1xcLi8sXG4gICAgdHJhaWxpbmdaZXJvc1JlZ2V4OiAvMCskLyxcbiAgICBkZWNpbWFsUGxhY2VzKHZhbHVlKSB7XG5cbiAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZGluZGV4ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgY29uc3QgZWluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChkaW5kZXggPCAwID8gMCA6IChlaW5kZXggPCAwID8gc3RyLmxlbmd0aCA6IGVpbmRleCkgLSBkaW5kZXggLSAxKSArXG4gICAgICAgICAgICAoZWluZGV4IDwgMCA/IDAgOiBNYXRoLm1heCgwLCAtcGFyc2VJbnQoc3RyLnNsaWNlKGVpbmRleCArIDEpKSkpXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ251bWJlcicsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHVuc2FmZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goaW50ZXJuYWxzLm51bWJlclJ4KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSB9O1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gMDsgICAgICAgICAgIC8vIC0wXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy51bnNhZmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL2UvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHModmFsdWUpICE9PSBpbnRlcm5hbHMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKFN0cmluZyhyZXN1bHQudmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmcgPSByZXN1bHQudmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaCgvZS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IGludGVybmFscy5ub3JtYWxpemVEZWNpbWFsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHByZWZzIH0pIHtcblxuICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdudW1iZXIuaW5maW5pdHknKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFDb21tb24uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignbnVtYmVyLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZSB9O1xuXG4gICAgICAgIGlmIChwcmVmcy5jb252ZXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLiRfZ2V0UnVsZSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBydWxlLmFyZ3MubGltaXQpOyAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBjb25jZXB0dWFsbHkgZXF1aXZhbGVudCB0byB1c2luZyB0b0ZpeGVkIGJ1dCBpdCBzaG91bGQgYmUgbXVjaCBmYXN0ZXJcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJlc3VsdC52YWx1ZSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSAwOyAgICAgICAgICAgLy8gLTBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NoZW1hLl9mbGFncy51bnNhZmUgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IHZhbHVlIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjb21wYXJlOiB7XG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24uaXNOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBncmVhdGVyOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdncmVhdGVyJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbnRlZ2VyOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2ludGVnZXInKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgudHJ1bmModmFsdWUpIC0gdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIuaW50ZWdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlc3M6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlc3MnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzwnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtdWx0aXBsZToge1xuICAgICAgICAgICAgbWV0aG9kKGJhc2UpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VEZWNpbWFsUGxhY2UgPSB0eXBlb2YgYmFzZSA9PT0gJ251bWJlcicgPyBpbnRlcm5hbHMuZGVjaW1hbFBsYWNlcyhiYXNlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgcGZhY3RvciA9IE1hdGgucG93KDEwLCBiYXNlRGVjaW1hbFBsYWNlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlRGVjaW1hbFBsYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGZhY3RvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgYmFzZSwgYmFzZURlY2ltYWxQbGFjZSwgcGZhY3RvciB9LCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURlY2ltYWxQbGFjZSA9IGludGVybmFscy5kZWNpbWFsUGxhY2VzKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZURlY2ltYWxQbGFjZSA+IGJhc2VEZWNpbWFsUGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsdWUgd2l0aCBoaWdoZXIgcHJlY2lzaW9uIHRoYW4gYmFzZSBjYW4gbmV2ZXIgYmUgYSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogb3B0aW9ucy5hcmdzLmJhc2UsIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBmYWN0b3IgKiB2YWx1ZSkgJSBNYXRoLnJvdW5kKHBmYWN0b3IgKiBiYXNlKSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgaGVscGVycy5lcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogb3B0aW9ucy5hcmdzLmJhc2UsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdiYXNlRGVjaW1hbFBsYWNlJyxcbiAgICAgICAgICAgICAgICAncGZhY3RvcidcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG5lZ2F0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduKCduZWdhdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncG9ydCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPD0gNjU1MzUpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5wb3J0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24oJ3Bvc2l0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlY2lzaW9uOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCksICdsaW1pdCBtdXN0IGJlIGFuIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdwcmVjaXNpb24nLCBhcmdzOiB7IGxpbWl0IH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaChpbnRlcm5hbHMucHJlY2lzaW9uUngpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gTWF0aC5tYXgoKHBsYWNlc1sxXSA/IHBsYWNlc1sxXS5sZW5ndGggOiAwKSAtIChwbGFjZXNbMl0gPyBwYXJzZUludChwbGFjZXNbMl0sIDEwKSA6IDApLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbHMgPD0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIucHJlY2lzaW9uJywgeyBsaW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpZ246IHtcbiAgICAgICAgICAgIG1ldGhvZChzaWduKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWyduZWdhdGl2ZScsICdwb3NpdGl2ZSddLmluY2x1ZGVzKHNpZ24pLCAnSW52YWxpZCBzaWduJywgc2lnbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc2lnbicsIGFyZ3M6IHsgc2lnbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHNpZ24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpZ24gPT09ICduZWdhdGl2ZScgJiYgdmFsdWUgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPT09ICdwb3NpdGl2ZScgJiYgdmFsdWUgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGBudW1iZXIuJHtzaWdufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc2FmZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5zYWZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnbnVtYmVyLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5ncmVhdGVyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIuaW5maW5pdHknOiAne3sjbGFiZWx9fSBjYW5ub3QgYmUgaW5maW5pdHknLFxuICAgICAgICAnbnVtYmVyLmludGVnZXInOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgICAnbnVtYmVyLmxlc3MnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tdWx0aXBsZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBtdWx0aXBsZSBvZiB7eyNtdWx0aXBsZX19JyxcbiAgICAgICAgJ251bWJlci5uZWdhdGl2ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLnBvcnQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgcG9ydCcsXG4gICAgICAgICdudW1iZXIucG9zaXRpdmUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5wcmVjaXNpb24nOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgbm8gbW9yZSB0aGFuIHt7I2xpbWl0fX0gZGVjaW1hbCBwbGFjZXMnLFxuICAgICAgICAnbnVtYmVyLnVuc2FmZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzYWZlIG51bWJlcidcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMuZXhwb25lbnRpYWxQYXJ0UmVnZXgsICcnKVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMuZG90UmVnZXgsICcnKVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMudHJhaWxpbmdaZXJvc1JlZ2V4LCAnJylcbiAgICAgICAgLnJlcGxhY2UoaW50ZXJuYWxzLmxlYWRpbmdTaWduQW5kWmVyb3NSZWdleCwgJycpO1xufTtcblxuXG5pbnRlcm5hbHMubm9ybWFsaXplRGVjaW1hbCA9IGZ1bmN0aW9uIChzdHIpIHtcblxuICAgIHN0ciA9IHN0clxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBwbHVzIHNpZ25zXG4gICAgICAgIC5yZXBsYWNlKC9eXFwrLywgJycpXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcyBpZiB0aGVyZSBpcyBhIGRlY2ltYWwgcG9pbnQgYW5kIHVuZWNlc3NhcnkgZGVjaW1hbCBwb2ludHNcbiAgICAgICAgLnJlcGxhY2UoL1xcLjAqJC8sICcnKVxuICAgICAgICAvLyBBZGQgYSBpbnRlZ2VyIDAgaWYgdGhlIG51bWJlcnMgc3RhcnRzIHdpdGggYSBkZWNpbWFsIHBvaW50XG4gICAgICAgIC5yZXBsYWNlKC9eKC0/KVxcLihbXlxcLl0qKSQvLCAnJDEwLiQyJylcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pMCsoWzAtOV0pLywgJyQxJDInKTtcblxuICAgIGlmIChzdHIuaW5jbHVkZXMoJy4nKSAmJlxuICAgICAgICBzdHIuZW5kc1dpdGgoJzAnKSkge1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8wKyQvLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0ciA9PT0gJy0wJykge1xuICAgICAgICByZXR1cm4gJzAnO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/number.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/object.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/object.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Keys = __webpack_require__(/*! ./keys */ \"(rsc)/./node_modules/joi/lib/types/keys.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = Keys.extend({\n\n    type: 'object',\n\n    cast: {\n        map: {\n            from: (value) => value && typeof value === 'object',\n            to(value, helpers) {\n\n                return new Map(Object.entries(value));\n            }\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9vYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDBEQUFROzs7QUFHN0I7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL29iamVjdC5qcz9iMzhkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgS2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gS2V5cy5leHRlbmQoe1xuXG4gICAgdHlwZTogJ29iamVjdCcsXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICAgZnJvbTogKHZhbHVlKSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/object.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/string.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/string.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Domain = __webpack_require__(/*! @sideway/address/lib/domain */ \"(rsc)/./node_modules/@sideway/address/lib/domain.js\");\nconst Email = __webpack_require__(/*! @sideway/address/lib/email */ \"(rsc)/./node_modules/@sideway/address/lib/email.js\");\nconst Ip = __webpack_require__(/*! @sideway/address/lib/ip */ \"(rsc)/./node_modules/@sideway/address/lib/ip.js\");\nconst EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ \"(rsc)/./node_modules/@hapi/hoek/lib/escapeRegex.js\");\nconst Tlds = __webpack_require__(/*! @sideway/address/lib/tlds */ \"(rsc)/./node_modules/@sideway/address/lib/tlds.js\");\nconst Uri = __webpack_require__(/*! @sideway/address/lib/uri */ \"(rsc)/./node_modules/@sideway/address/lib/uri.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\n\n\nconst internals = {\n    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,              // $lab:coverage:ignore$\n    base64Regex: {\n        // paddingRequired\n        true: {\n            // urlSafe\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}==|[\\w\\-]{3}=)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n        },\n        false: {\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}(==)?|[\\w\\-]{3}=?)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/\n        }\n    },\n    dataUriRegex: /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/,\n    hexRegex: {\n        withPrefix: /^0x[0-9a-f]+$/i,\n        withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,\n        withoutPrefix: /^[0-9a-f]+$/i\n    },\n    ipRegex: Ip.regex({ cidr: 'forbidden' }).regex,\n    isoDurationRegex: /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/,\n\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5',\n        uuidv6: '6',\n        uuidv7: '7',\n        uuidv8: '8'\n    },\n    guidSeparators: new Set([undefined, true, false, '-', ':']),\n\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'string',\n\n    flags: {\n\n        insensitive: { default: false },\n        truncate: { default: false }\n    },\n\n    terms: {\n\n        replacements: { init: null }\n    },\n\n    coerce: {\n        from: 'string',\n        method(value, { schema, state, prefs }) {\n\n            const normalize = schema.$_getRule('normalize');\n            if (normalize) {\n                value = value.normalize(normalize.args.form);\n            }\n\n            const casing = schema.$_getRule('case');\n            if (casing) {\n                value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n            }\n\n            const trim = schema.$_getRule('trim');\n            if (trim &&\n                trim.args.enabled) {\n\n                value = value.trim();\n            }\n\n            if (schema.$_terms.replacements) {\n                for (const replacement of schema.$_terms.replacements) {\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            const hex = schema.$_getRule('hex');\n            if (hex &&\n                hex.args.options.byteAligned &&\n                value.length % 2 !== 0) {\n\n                value = `0${value}`;\n            }\n\n            if (schema.$_getRule('isoDate')) {\n                const iso = internals.isoDate(value);\n                if (iso) {\n                    value = iso;\n                }\n            }\n\n            if (schema._flags.truncate) {\n                const rule = schema.$_getRule('max');\n                if (rule) {\n                    let limit = rule.args.limit;\n                    if (Common.isResolvable(limit)) {\n                        limit = limit.resolve(value, state, prefs);\n                        if (!Common.limit(limit)) {\n                            return { value, errors: schema.$_createError('any.ref', limit, { ref: rule.args.limit, arg: 'limit', reason: 'must be a positive integer' }, state, prefs) };\n                        }\n                    }\n\n                    value = value.slice(0, limit);\n                }\n            }\n\n            return { value };\n        }\n    },\n\n    validate(value, { schema, error }) {\n\n        if (typeof value !== 'string') {\n            return { value, errors: error('string.base') };\n        }\n\n        if (value === '') {\n            const min = schema.$_getRule('min');\n            if (min &&\n                min.args.limit === 0) {\n\n                return;\n            }\n\n            return { value, errors: error('string.empty') };\n        }\n    },\n\n    rules: {\n\n        alphanum: {\n            method() {\n\n                return this.$_addRule('alphanum');\n            },\n            validate(value, helpers) {\n\n                if (/^[a-zA-Z0-9]+$/.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.alphanum');\n            }\n        },\n\n        base64: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['paddingRequired', 'urlSafe']);\n\n                options = { urlSafe: false, paddingRequired: true, ...options };\n                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n                Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');\n\n                return this.$_addRule({ name: 'base64', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];\n                if (regex.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.base64');\n            }\n        },\n\n        case: {\n            method(direction) {\n\n                Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);\n\n                return this.$_addRule({ name: 'case', args: { direction } });\n            },\n            validate(value, helpers, { direction }) {\n\n                if (direction === 'lower' && value === value.toLocaleLowerCase() ||\n                    direction === 'upper' && value === value.toLocaleUpperCase()) {\n\n                    return value;\n                }\n\n                return helpers.error(`string.${direction}case`);\n            },\n            convert: true\n        },\n\n        creditCard: {\n            method() {\n\n                return this.$_addRule('creditCard');\n            },\n            validate(value, helpers) {\n\n                let i = value.length;\n                let sum = 0;\n                let mul = 1;\n\n                while (i--) {\n                    const char = value.charAt(i) * mul;\n                    sum = sum + (char - (char > 9) * 9);\n                    mul = mul ^ 3;\n                }\n\n                if (sum > 0 &&\n                    sum % 10 === 0) {\n\n                    return value;\n                }\n\n                return helpers.error('string.creditCard');\n            }\n        },\n\n        dataUri: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['paddingRequired']);\n\n                options = { paddingRequired: true, ...options };\n                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n\n                return this.$_addRule({ name: 'dataUri', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const matches = value.match(internals.dataUriRegex);\n\n                if (matches) {\n                    if (!matches[2]) {\n                        return value;\n                    }\n\n                    if (matches[2] !== 'base64') {\n                        return value;\n                    }\n\n                    const base64regex = internals.base64Regex[options.paddingRequired].false;\n                    if (base64regex.test(matches[3])) {\n                        return value;\n                    }\n                }\n\n                return helpers.error('string.dataUri');\n            }\n        },\n\n        domain: {\n            method(options) {\n\n                if (options) {\n                    Common.assertOptions(options, ['allowFullyQualified', 'allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);\n                }\n\n                const address = internals.addressOptions(options);\n                return this.$_addRule({ name: 'domain', args: { options }, address });\n            },\n            validate(value, helpers, args, { address }) {\n\n                if (Domain.isValid(value, address)) {\n                    return value;\n                }\n\n                return helpers.error('string.domain');\n            }\n        },\n\n        email: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['allowFullyQualified', 'allowUnicode', 'ignoreLength', 'maxDomainSegments', 'minDomainSegments', 'multiple', 'separator', 'tlds']);\n                Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');\n\n                const address = internals.addressOptions(options);\n                const regex = new RegExp(`\\\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\\\s*`);\n\n                return this.$_addRule({ name: 'email', args: { options }, regex, address });\n            },\n            validate(value, helpers, { options }, { regex, address }) {\n\n                const emails = options.multiple ? value.split(regex) : [value];\n                const invalids = [];\n                for (const email of emails) {\n                    if (!Email.isValid(email, address)) {\n                        invalids.push(email);\n                    }\n                }\n\n                if (!invalids.length) {\n                    return value;\n                }\n\n                return helpers.error('string.email', { value, invalids });\n            }\n        },\n\n        guid: {\n            alias: 'uuid',\n            method(options = {}) {\n\n                Common.assertOptions(options, ['version', 'separator']);\n\n                let versionNumbers = '';\n\n                if (options.version) {\n                    const versions = [].concat(options.version);\n\n                    Assert(versions.length >= 1, 'version must have at least 1 valid version specified');\n                    const set = new Set();\n\n                    for (let i = 0; i < versions.length; ++i) {\n                        const version = versions[i];\n                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                        const versionNumber = internals.guidVersions[version.toLowerCase()];\n                        Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                        Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');\n\n                        versionNumbers += versionNumber;\n                        set.add(versionNumber);\n                    }\n                }\n\n                Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, \"-\", or \":\"');\n                const separator = options.separator === undefined ? '[:-]?' :\n                    options.separator === true ? '[:-]' :\n                        options.separator === false ? '[]?' : `\\\\${options.separator}`;\n\n                const regex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n                return this.$_addRule({ name: 'guid', args: { options }, regex });\n            },\n            validate(value, helpers, args, { regex }) {\n\n                const results = regex.exec(value);\n\n                if (!results) {\n                    return helpers.error('string.guid');\n                }\n\n                // Matching braces\n\n                if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                    return helpers.error('string.guid');\n                }\n\n                return value;\n            }\n        },\n\n        hex: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['byteAligned', 'prefix']);\n\n                options = { byteAligned: false, prefix: false, ...options };\n                Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');\n                Assert(typeof options.prefix === 'boolean' || options.prefix === 'optional', 'prefix must be boolean or \"optional\"');\n\n                return this.$_addRule({ name: 'hex', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const re = options.prefix === 'optional' ?\n                    internals.hexRegex.withOptionalPrefix :\n                    options.prefix === true ?\n                        internals.hexRegex.withPrefix :\n                        internals.hexRegex.withoutPrefix;\n                if (!re.test(value)) {\n                    return helpers.error('string.hex');\n                }\n\n                if (options.byteAligned &&\n                    value.length % 2 !== 0) {\n\n                    return helpers.error('string.hexAlign');\n                }\n\n                return value;\n            }\n        },\n\n        hostname: {\n            method() {\n\n                return this.$_addRule('hostname');\n            },\n            validate(value, helpers) {\n\n                if (Domain.isValid(value, { minDomainSegments: 1 }) ||\n                    internals.ipRegex.test(value)) {\n\n                    return value;\n                }\n\n                return helpers.error('string.hostname');\n            }\n        },\n\n        insensitive: {\n            method() {\n\n                return this.$_setFlag('insensitive', true);\n            }\n        },\n\n        ip: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['cidr', 'version']);\n\n                const { cidr, versions, regex } = Ip.regex(options);\n                const version = options.version ? versions : undefined;\n                return this.$_addRule({ name: 'ip', args: { options: { cidr, version } }, regex });\n            },\n            validate(value, helpers, { options }, { regex }) {\n\n                if (regex.test(value)) {\n                    return value;\n                }\n\n                if (options.version) {\n                    return helpers.error('string.ipVersion', { value, cidr: options.cidr, version: options.version });\n                }\n\n                return helpers.error('string.ip', { value, cidr: options.cidr });\n            }\n        },\n\n        isoDate: {\n            method() {\n\n                return this.$_addRule('isoDate');\n            },\n            validate(value, { error }) {\n\n                if (internals.isoDate(value)) {\n                    return value;\n                }\n\n                return error('string.isoDate');\n            }\n        },\n\n        isoDuration: {\n            method() {\n\n                return this.$_addRule('isoDuration');\n            },\n            validate(value, helpers) {\n\n                if (internals.isoDurationRegex.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.isoDuration');\n            }\n        },\n\n        length: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'length', limit, '=', encoding);\n            },\n            validate(value, helpers, { limit, encoding }, { name, operator, args }) {\n\n                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;      // $lab:coverage:ignore$\n                if (Common.compare(length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('string.' + name, { limit: args.limit, value, encoding });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                },\n                'encoding'\n            ]\n        },\n\n        lowercase: {\n            method() {\n\n                return this.case('lower');\n            }\n        },\n\n        max: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'max', limit, '<=', encoding);\n            },\n            args: ['limit', 'encoding']\n        },\n\n        min: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'min', limit, '>=', encoding);\n            },\n            args: ['limit', 'encoding']\n        },\n\n        normalize: {\n            method(form = 'NFC') {\n\n                Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n                return this.$_addRule({ name: 'normalize', args: { form } });\n            },\n            validate(value, { error }, { form }) {\n\n                if (value === value.normalize(form)) {\n                    return value;\n                }\n\n                return error('string.normalize', { value, form });\n            },\n            convert: true\n        },\n\n        pattern: {\n            alias: 'regex',\n            method(regex, options = {}) {\n\n                Assert(regex instanceof RegExp, 'regex must be a RegExp');\n                Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');\n\n                if (typeof options === 'string') {\n                    options = { name: options };\n                }\n\n                Common.assertOptions(options, ['invert', 'name']);\n\n                const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');\n                return this.$_addRule({ name: 'pattern', args: { regex, options }, errorCode });\n            },\n            validate(value, helpers, { regex, options }, { errorCode }) {\n\n                const patternMatch = regex.test(value);\n\n                if (patternMatch ^ options.invert) {\n                    return value;\n                }\n\n                return helpers.error(errorCode, { name: options.name, regex, value });\n            },\n            args: ['regex', 'options'],\n            multi: true\n        },\n\n        replace: {\n            method(pattern, replacement) {\n\n                if (typeof pattern === 'string') {\n                    pattern = new RegExp(EscapeRegex(pattern), 'g');\n                }\n\n                Assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n                Assert(typeof replacement === 'string', 'replacement must be a String');\n\n                const obj = this.clone();\n\n                if (!obj.$_terms.replacements) {\n                    obj.$_terms.replacements = [];\n                }\n\n                obj.$_terms.replacements.push({ pattern, replacement });\n                return obj;\n            }\n        },\n\n        token: {\n            method() {\n\n                return this.$_addRule('token');\n            },\n            validate(value, helpers) {\n\n                if (/^\\w+$/.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.token');\n            }\n        },\n\n        trim: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_addRule({ name: 'trim', args: { enabled } });\n            },\n            validate(value, helpers, { enabled }) {\n\n                if (!enabled ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return helpers.error('string.trim');\n            },\n            convert: true\n        },\n\n        truncate: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_setFlag('truncate', enabled);\n            }\n        },\n\n        uppercase: {\n            method() {\n\n                return this.case('upper');\n            }\n        },\n\n        uri: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme', 'encodeUri']);\n\n                if (options.domain) {\n                    Common.assertOptions(options.domain, ['allowFullyQualified', 'allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);\n                }\n\n                const { regex, scheme } = Uri.regex(options);\n                const domain = options.domain ? internals.addressOptions(options.domain) : null;\n                return this.$_addRule({ name: 'uri', args: { options }, regex, domain, scheme });\n            },\n            validate(value, helpers, { options }, { regex, domain, scheme }) {\n\n                if (['http:/', 'https:/'].includes(value)) {            // scheme:/ is technically valid but makes no sense\n                    return helpers.error('string.uri');\n                }\n\n                let match = regex.exec(value);\n\n                if (!match && helpers.prefs.convert && options.encodeUri) {\n                    const encoded = encodeURI(value);\n                    match = regex.exec(encoded);\n                    if (match) {\n                        value = encoded;\n                    }\n                }\n\n                if (match) {\n                    const matched = match[1] || match[2];\n                    if (domain &&\n                        (!options.allowRelative || matched) &&\n                        !Domain.isValid(matched, domain)) {\n\n                        return helpers.error('string.domain', { value: matched });\n                    }\n\n                    return value;\n                }\n\n                if (options.relativeOnly) {\n                    return helpers.error('string.uriRelativeOnly');\n                }\n\n                if (options.scheme) {\n                    return helpers.error('string.uriCustomScheme', { scheme, value });\n                }\n\n                return helpers.error('string.uri');\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.replacements) {\n                for (const { pattern, replacement } of desc.replacements) {\n                    obj = obj.replace(pattern, replacement);\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'string.alphanum': '{{#label}} must only contain alpha-numeric characters',\n        'string.base': '{{#label}} must be a string',\n        'string.base64': '{{#label}} must be a valid base64 string',\n        'string.creditCard': '{{#label}} must be a credit card',\n        'string.dataUri': '{{#label}} must be a valid dataUri string',\n        'string.domain': '{{#label}} must contain a valid domain name',\n        'string.email': '{{#label}} must be a valid email',\n        'string.empty': '{{#label}} is not allowed to be empty',\n        'string.guid': '{{#label}} must be a valid GUID',\n        'string.hex': '{{#label}} must only contain hexadecimal characters',\n        'string.hexAlign': '{{#label}} hex decoded representation must be byte aligned',\n        'string.hostname': '{{#label}} must be a valid hostname',\n        'string.ip': '{{#label}} must be a valid ip address with a {{#cidr}} CIDR',\n        'string.ipVersion': '{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',\n        'string.isoDate': '{{#label}} must be in iso format',\n        'string.isoDuration': '{{#label}} must be a valid ISO 8601 duration',\n        'string.length': '{{#label}} length must be {{#limit}} characters long',\n        'string.lowercase': '{{#label}} must only contain lowercase characters',\n        'string.max': '{{#label}} length must be less than or equal to {{#limit}} characters long',\n        'string.min': '{{#label}} length must be at least {{#limit}} characters long',\n        'string.normalize': '{{#label}} must be unicode normalized in the {{#form}} form',\n        'string.token': '{{#label}} must only contain alpha-numeric and underscore characters',\n        'string.pattern.base': '{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}',\n        'string.pattern.name': '{{#label}} with value {:[.]} fails to match the {{#name}} pattern',\n        'string.pattern.invert.base': '{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}',\n        'string.pattern.invert.name': '{{#label}} with value {:[.]} matches the inverted {{#name}} pattern',\n        'string.trim': '{{#label}} must not have leading or trailing whitespace',\n        'string.uri': '{{#label}} must be a valid uri',\n        'string.uriCustomScheme': '{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern',\n        'string.uriRelativeOnly': '{{#label}} must be a valid relative uri',\n        'string.uppercase': '{{#label}} must only contain uppercase characters'\n    }\n});\n\n\n// Helpers\n\ninternals.addressOptions = function (options) {\n\n    if (!options) {\n        return internals.tlds || options;      // $lab:coverage:ignore$\n    }\n\n    // minDomainSegments\n\n    Assert(options.minDomainSegments === undefined ||\n        Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer');\n\n    // maxDomainSegments\n\n    Assert(options.maxDomainSegments === undefined ||\n        Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, 'maxDomainSegments must be a positive integer');\n\n    // tlds\n\n    if (options.tlds === false) {\n        return options;\n    }\n\n    if (options.tlds === true ||\n        options.tlds === undefined) {\n\n        Assert(internals.tlds, 'Built-in TLD list disabled');\n        return Object.assign({}, options, internals.tlds);\n    }\n\n    Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');\n\n    const deny = options.tlds.deny;\n    if (deny) {\n        if (Array.isArray(deny)) {\n            options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });\n        }\n\n        Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');\n        Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');\n        internals.validateTlds(options.tlds.deny, 'tlds.deny');\n        return options;\n    }\n\n    const allow = options.tlds.allow;\n    if (!allow) {\n        return options;\n    }\n\n    if (allow === true) {\n        Assert(internals.tlds, 'Built-in TLD list disabled');\n        return Object.assign({}, options, internals.tlds);\n    }\n\n    if (Array.isArray(allow)) {\n        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });\n    }\n\n    Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n    internals.validateTlds(options.tlds.allow, 'tlds.allow');\n    return options;\n};\n\n\ninternals.validateTlds = function (set, source) {\n\n    for (const tld of set) {\n        Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);\n    }\n};\n\n\ninternals.isoDate = function (value) {\n\n    if (!Common.isIsoDate(value)) {\n        return null;\n    }\n\n    if (/.*T.*[+-]\\d\\d$/.test(value)) {             // Add missing trailing zeros to timeshift\n        value += '00';\n    }\n\n    const date = new Date(value);\n    if (isNaN(date.getTime())) {\n        return null;\n    }\n\n    return date.toISOString();\n};\n\n\ninternals.length = function (schema, name, limit, operator, encoding) {\n\n    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);      // $lab:coverage:ignore$\n\n    return schema.$_addRule({ name, method: 'length', args: { limit, encoding }, operator });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1QjtBQUM5QyxlQUFlLG1CQUFPLENBQUMsd0ZBQTZCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyxzRkFBNEI7QUFDbEQsV0FBVyxtQkFBTyxDQUFDLGdGQUF5QjtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBNEI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLG9GQUEyQjtBQUNoRCxZQUFZLG1CQUFPLENBQUMsa0ZBQTBCOztBQUU5QyxZQUFZLG1CQUFPLENBQUMsd0RBQU87QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHlEQUFXOzs7QUFHbEM7QUFDQSxrQ0FBa0MsUUFBUSw0QkFBNEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRTtBQUNuRSx1Q0FBdUMsRUFBRSxlQUFlLEVBQUUsb0JBQW9CLEVBQUUsa0JBQWtCLEVBQUU7QUFDcEcsU0FBUztBQUNUO0FBQ0EsOEJBQThCLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUU7QUFDdEUsdUNBQXVDLEVBQUUsZUFBZSxFQUFFLG9CQUFvQixFQUFFLHFCQUFxQixFQUFFO0FBQ3ZHO0FBQ0EsS0FBSztBQUNMLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0IsbUJBQW1CO0FBQzNDOztBQUVBO0FBQ0EsVUFBVSxLQUFLO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLG9CQUFvQjtBQUNwQixLQUFLOztBQUVMOztBQUVBLHdCQUF3QjtBQUN4QixLQUFLOztBQUVMO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixNQUFNO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3REFBd0QsMEVBQTBFO0FBQ3ZLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7O0FBRUwsc0JBQXNCLGVBQWU7O0FBRXJDO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUEsd0NBQXdDLHdCQUF3QixXQUFXO0FBQzNFLGFBQWE7QUFDYix1Q0FBdUMsU0FBUzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQSx3Q0FBd0Msc0JBQXNCLGFBQWE7QUFDM0UsYUFBYTtBQUNiLHVDQUF1QyxXQUFXOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFVBQVU7QUFDekQsYUFBYTtBQUNiO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBLHdDQUF3Qyx5QkFBeUIsV0FBVztBQUM1RSxhQUFhO0FBQ2IsdUNBQXVDLFNBQVM7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHdCQUF3QixTQUFTLFdBQVc7QUFDcEYsYUFBYTtBQUNiLDZDQUE2QyxTQUFTOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQseURBQXlEOztBQUUxRyx3Q0FBd0MsdUJBQXVCLFNBQVMsa0JBQWtCO0FBQzFGLGFBQWE7QUFDYix1Q0FBdUMsU0FBUyxJQUFJLGdCQUFnQjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGtCQUFrQjs7QUFFckYsaURBQWlELGVBQWUsRUFBRSxHQUFHLFVBQVUsVUFBVSxFQUFFLE9BQU8sMkJBQTJCLFVBQVUsRUFBRSxPQUFPLG1DQUFtQyxVQUFVLEVBQUUsYUFBYSxHQUFHLE1BQU07O0FBRXJOLHdDQUF3QyxzQkFBc0IsU0FBUyxTQUFTO0FBQ2hGLGFBQWE7QUFDYiw2Q0FBNkMsT0FBTzs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUEsd0NBQXdDLHFCQUFxQixXQUFXO0FBQ3hFLGFBQWE7QUFDYix1Q0FBdUMsU0FBUzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUEsd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBLHdDQUF3QyxvQkFBb0IsV0FBVyxpQkFBaUIsU0FBUztBQUNqRyxhQUFhO0FBQ2IsdUNBQXVDLFNBQVMsSUFBSSxPQUFPOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QscURBQXFEO0FBQ3BIOztBQUVBLG9EQUFvRCwyQkFBMkI7QUFDL0U7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsOEJBQThCLE9BQU87O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLHVDQUF1QyxpQkFBaUIsSUFBSSxzQkFBc0I7O0FBRWxGLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7O0FBRUEseURBQXlELG9DQUFvQztBQUM3RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQSx3Q0FBd0MsMkJBQTJCLFFBQVE7QUFDM0UsYUFBYTtBQUNiLDhCQUE4QixPQUFPLElBQUksTUFBTTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxhQUFhO0FBQ2hFLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTtBQUNBLHdDQUF3Qyx5QkFBeUIsZ0JBQWdCLGFBQWE7QUFDOUYsYUFBYTtBQUNiLHVDQUF1QyxnQkFBZ0IsSUFBSSxXQUFXOztBQUV0RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELGtDQUFrQztBQUNwRixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLHdDQUF3QyxzQkFBc0IsV0FBVztBQUN6RSxhQUFhO0FBQ2IsdUNBQXVDLFNBQVM7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBLHdDQUF3QyxxQkFBcUIsU0FBUyx5QkFBeUI7QUFDL0YsYUFBYTtBQUNiLHVDQUF1QyxTQUFTLElBQUksdUJBQXVCOztBQUUzRSx3RUFBd0U7QUFDeEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRSxnQkFBZ0I7QUFDaEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4QkFBOEIsU0FBUztBQUN2QywwQkFBMEIsU0FBUztBQUNuQyw0QkFBNEIsU0FBUztBQUNyQyxnQ0FBZ0MsU0FBUztBQUN6Qyw2QkFBNkIsU0FBUztBQUN0Qyw0QkFBNEIsU0FBUztBQUNyQywyQkFBMkIsU0FBUztBQUNwQywyQkFBMkIsU0FBUztBQUNwQywwQkFBMEIsU0FBUztBQUNuQyx5QkFBeUIsU0FBUztBQUNsQyw4QkFBOEIsU0FBUztBQUN2Qyw4QkFBOEIsU0FBUztBQUN2Qyx3QkFBd0IsU0FBUyxvQ0FBb0MsUUFBUTtBQUM3RSwrQkFBK0IsU0FBUyw4REFBOEQsV0FBVyxTQUFTLFFBQVE7QUFDbEksNkJBQTZCLFNBQVM7QUFDdEMsaUNBQWlDLFNBQVM7QUFDMUMsNEJBQTRCLFNBQVMsaUJBQWlCLFNBQVM7QUFDL0QsK0JBQStCLFNBQVM7QUFDeEMseUJBQXlCLFNBQVMsdUNBQXVDLFNBQVM7QUFDbEYseUJBQXlCLFNBQVMsMEJBQTBCLFNBQVM7QUFDckUsK0JBQStCLFNBQVMsb0NBQW9DLFFBQVE7QUFDcEYsMkJBQTJCLFNBQVM7QUFDcEMsa0NBQWtDLFNBQVMsWUFBWSxNQUFNLHVDQUF1QyxRQUFRO0FBQzVHLGtDQUFrQyxTQUFTLFlBQVksTUFBTSxxQkFBcUIsUUFBUTtBQUMxRix5Q0FBeUMsU0FBUyxZQUFZLE1BQU0sZ0NBQWdDLFFBQVE7QUFDNUcseUNBQXlDLFNBQVMsWUFBWSxNQUFNLHVCQUF1QixRQUFRO0FBQ25HLDBCQUEwQixTQUFTO0FBQ25DLHlCQUF5QixTQUFTO0FBQ2xDLHFDQUFxQyxTQUFTLGlEQUFpRCxVQUFVO0FBQ3pHLHFDQUFxQyxTQUFTO0FBQzlDLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLFFBQVEsdUJBQXVCO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBLGtDQUFrQyxhQUFhLFFBQVEseUJBQXlCO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLHFDQUFxQyw0Q0FBNEMsTUFBTSxRQUFRO0FBQy9GO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSxvR0FBb0c7O0FBRXBHLDhCQUE4QixnQ0FBZ0MsaUJBQWlCLFlBQVk7QUFDM0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MaXN0ZW4vLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zdHJpbmcuanM/ZWRiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRG9tYWluID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvZG9tYWluJyk7XG5jb25zdCBFbWFpbCA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL2VtYWlsJyk7XG5jb25zdCBJcCA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL2lwJyk7XG5jb25zdCBFc2NhcGVSZWdleCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2VzY2FwZVJlZ2V4Jyk7XG5jb25zdCBUbGRzID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvdGxkcycpO1xuY29uc3QgVXJpID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvdXJpJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdGxkczogVGxkcyBpbnN0YW5jZW9mIFNldCA/IHsgdGxkczogeyBhbGxvdzogVGxkcywgZGVueTogbnVsbCB9IH0gOiBmYWxzZSwgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGJhc2U2NFJlZ2V4OiB7XG4gICAgICAgIC8vIHBhZGRpbmdSZXF1aXJlZFxuICAgICAgICB0cnVlOiB7XG4gICAgICAgICAgICAvLyB1cmxTYWZlXG4gICAgICAgICAgICB0cnVlOiAvXig/OltcXHdcXC1dezJ9W1xcd1xcLV17Mn0pKig/OltcXHdcXC1dezJ9PT18W1xcd1xcLV17M309KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9PT18W0EtWmEtejAtOStcXC9dezN9PSk/JC9cbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2U6IHtcbiAgICAgICAgICAgIHRydWU6IC9eKD86W1xcd1xcLV17Mn1bXFx3XFwtXXsyfSkqKD86W1xcd1xcLV17Mn0oPT0pP3xbXFx3XFwtXXszfT0/KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9KD09KT98W0EtWmEtejAtOStcXC9dezN9PT8pPyQvXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGFVcmlSZWdleDogL15kYXRhOltcXHcrLi1dK1xcL1tcXHcrLi1dKzsoKGNoYXJzZXQ9W1xcdy1dK3xiYXNlNjQpLCk/KC4qKSQvLFxuICAgIGhleFJlZ2V4OiB7XG4gICAgICAgIHdpdGhQcmVmaXg6IC9eMHhbMC05YS1mXSskL2ksXG4gICAgICAgIHdpdGhPcHRpb25hbFByZWZpeDogL14oPzoweCk/WzAtOWEtZl0rJC9pLFxuICAgICAgICB3aXRob3V0UHJlZml4OiAvXlswLTlhLWZdKyQvaVxuICAgIH0sXG4gICAgaXBSZWdleDogSXAucmVnZXgoeyBjaWRyOiAnZm9yYmlkZGVuJyB9KS5yZWdleCxcbiAgICBpc29EdXJhdGlvblJlZ2V4OiAvXlAoPyEkKShcXGQrWSk/KFxcZCtNKT8oXFxkK1cpPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT8kLyxcblxuICAgIGd1aWRCcmFja2V0czoge1xuICAgICAgICAneyc6ICd9JywgJ1snOiAnXScsICcoJzogJyknLCAnJzogJydcbiAgICB9LFxuICAgIGd1aWRWZXJzaW9uczoge1xuICAgICAgICB1dWlkdjE6ICcxJyxcbiAgICAgICAgdXVpZHYyOiAnMicsXG4gICAgICAgIHV1aWR2MzogJzMnLFxuICAgICAgICB1dWlkdjQ6ICc0JyxcbiAgICAgICAgdXVpZHY1OiAnNScsXG4gICAgICAgIHV1aWR2NjogJzYnLFxuICAgICAgICB1dWlkdjc6ICc3JyxcbiAgICAgICAgdXVpZHY4OiAnOCdcbiAgICB9LFxuICAgIGd1aWRTZXBhcmF0b3JzOiBuZXcgU2V0KFt1bmRlZmluZWQsIHRydWUsIGZhbHNlLCAnLScsICc6J10pLFxuXG4gICAgbm9ybWFsaXphdGlvbkZvcm1zOiBbJ05GQycsICdORkQnLCAnTkZLQycsICdORktEJ11cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdzdHJpbmcnLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBpbnNlbnNpdGl2ZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICB0cnVuY2F0ZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgcmVwbGFjZW1lbnRzOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZSA9IHNjaGVtYS4kX2dldFJ1bGUoJ25vcm1hbGl6ZScpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubm9ybWFsaXplKG5vcm1hbGl6ZS5hcmdzLmZvcm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjYXNpbmcgPSBzY2hlbWEuJF9nZXRSdWxlKCdjYXNlJyk7XG4gICAgICAgICAgICBpZiAoY2FzaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjYXNpbmcuYXJncy5kaXJlY3Rpb24gPT09ICd1cHBlcicgPyB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpIDogdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHJpbSA9IHNjaGVtYS4kX2dldFJ1bGUoJ3RyaW0nKTtcbiAgICAgICAgICAgIGlmICh0cmltICYmXG4gICAgICAgICAgICAgICAgdHJpbS5hcmdzLmVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXBsYWNlbWVudCBvZiBzY2hlbWEuJF90ZXJtcy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlcGxhY2VtZW50LnBhdHRlcm4sIHJlcGxhY2VtZW50LnJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhleCA9IHNjaGVtYS4kX2dldFJ1bGUoJ2hleCcpO1xuICAgICAgICAgICAgaWYgKGhleCAmJlxuICAgICAgICAgICAgICAgIGhleC5hcmdzLm9wdGlvbnMuYnl0ZUFsaWduZWQgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGAwJHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRfZ2V0UnVsZSgnaXNvRGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNvID0gaW50ZXJuYWxzLmlzb0RhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc28pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpc287XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy50cnVuY2F0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuJF9nZXRSdWxlKCdtYXgnKTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBydWxlLmFyZ3MubGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBsaW1pdC5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFDb21tb24ubGltaXQobGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCBsaW1pdCwgeyByZWY6IHJ1bGUuYXJncy5saW1pdCwgYXJnOiAnbGltaXQnLCByZWFzb246ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicgfSwgc3RhdGUsIHByZWZzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3RyaW5nLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgY29uc3QgbWluID0gc2NoZW1hLiRfZ2V0UnVsZSgnbWluJyk7XG4gICAgICAgICAgICBpZiAobWluICYmXG4gICAgICAgICAgICAgICAgbWluLmFyZ3MubGltaXQgPT09IDApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N0cmluZy5lbXB0eScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBhbHBoYW51bToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdhbHBoYW51bScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoL15bYS16QS1aMC05XSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5hbHBoYW51bScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJhc2U2NDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydwYWRkaW5nUmVxdWlyZWQnLCAndXJsU2FmZSddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IHVybFNhZmU6IGZhbHNlLCBwYWRkaW5nUmVxdWlyZWQ6IHRydWUsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSAnYm9vbGVhbicsICdwYWRkaW5nUmVxdWlyZWQgbXVzdCBiZSBib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnVybFNhZmUgPT09ICdib29sZWFuJywgJ3VybFNhZmUgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYmFzZTY0JywgYXJnczogeyBvcHRpb25zIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGludGVybmFscy5iYXNlNjRSZWdleFtvcHRpb25zLnBhZGRpbmdSZXF1aXJlZF1bb3B0aW9ucy51cmxTYWZlXTtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuYmFzZTY0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FzZToge1xuICAgICAgICAgICAgbWV0aG9kKGRpcmVjdGlvbikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnbG93ZXInLCAndXBwZXInXS5pbmNsdWRlcyhkaXJlY3Rpb24pLCAnSW52YWxpZCBjYXNlOicsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnY2FzZScsIGFyZ3M6IHsgZGlyZWN0aW9uIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgZGlyZWN0aW9uIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdsb3dlcicgJiYgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID09PSAndXBwZXInICYmIHZhbHVlID09PSB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGBzdHJpbmcuJHtkaXJlY3Rpb259Y2FzZWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVkaXRDYXJkOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2NyZWRpdENhcmQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgbGV0IGkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IG11bCA9IDE7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXIgPSB2YWx1ZS5jaGFyQXQoaSkgKiBtdWw7XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIChjaGFyIC0gKGNoYXIgPiA5KSAqIDkpO1xuICAgICAgICAgICAgICAgICAgICBtdWwgPSBtdWwgXiAzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdW0gPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIHN1bSAlIDEwID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuY3JlZGl0Q2FyZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRhdGFVcmk6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsncGFkZGluZ1JlcXVpcmVkJ10pO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgcGFkZGluZ1JlcXVpcmVkOiB0cnVlLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gJ2Jvb2xlYW4nLCAncGFkZGluZ1JlcXVpcmVkIG11c3QgYmUgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2RhdGFVcmknLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChpbnRlcm5hbHMuZGF0YVVyaVJlZ2V4KTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMl0gIT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjRyZWdleCA9IGludGVybmFscy5iYXNlNjRSZWdleFtvcHRpb25zLnBhZGRpbmdSZXF1aXJlZF0uZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlNjRyZWdleC50ZXN0KG1hdGNoZXNbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmRhdGFVcmknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkb21haW46IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93RnVsbHlRdWFsaWZpZWQnLCAnYWxsb3dVbmljb2RlJywgJ21heERvbWFpblNlZ21lbnRzJywgJ21pbkRvbWFpblNlZ21lbnRzJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZG9tYWluJywgYXJnczogeyBvcHRpb25zIH0sIGFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHsgYWRkcmVzcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoRG9tYWluLmlzVmFsaWQodmFsdWUsIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmRvbWFpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVtYWlsOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93RnVsbHlRdWFsaWZpZWQnLCAnYWxsb3dVbmljb2RlJywgJ2lnbm9yZUxlbmd0aCcsICdtYXhEb21haW5TZWdtZW50cycsICdtaW5Eb21haW5TZWdtZW50cycsICdtdWx0aXBsZScsICdzZXBhcmF0b3InLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5tdWx0aXBsZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLm11bHRpcGxlID09PSAnYm9vbGVhbicsICdtdWx0aXBsZSBvcHRpb24gbXVzdCBiZSBhbiBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXHMqWyR7b3B0aW9ucy5zZXBhcmF0b3IgPyBFc2NhcGVSZWdleChvcHRpb25zLnNlcGFyYXRvcikgOiAnLCd9XVxcXFxzKmApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2VtYWlsJywgYXJnczogeyBvcHRpb25zIH0sIHJlZ2V4LCBhZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyByZWdleCwgYWRkcmVzcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbHMgPSBvcHRpb25zLm11bHRpcGxlID8gdmFsdWUuc3BsaXQocmVnZXgpIDogW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1haWwgb2YgZW1haWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghRW1haWwuaXNWYWxpZChlbWFpbCwgYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRzLnB1c2goZW1haWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnZhbGlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZW1haWwnLCB7IHZhbHVlLCBpbnZhbGlkcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBndWlkOiB7XG4gICAgICAgICAgICBhbGlhczogJ3V1aWQnLFxuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWyd2ZXJzaW9uJywgJ3NlcGFyYXRvciddKTtcblxuICAgICAgICAgICAgICAgIGxldCB2ZXJzaW9uTnVtYmVycyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IFtdLmNvbmNhdChvcHRpb25zLnZlcnNpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2ZXJzaW9ucy5sZW5ndGggPj0gMSwgJ3ZlcnNpb24gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmFsaWQgdmVyc2lvbiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uTnVtYmVyID0gaW50ZXJuYWxzLmd1aWRWZXJzaW9uc1t2ZXJzaW9uLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZlcnNpb25OdW1iZXIsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoaW50ZXJuYWxzLmd1aWRWZXJzaW9ucykuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXNldC5oYXModmVyc2lvbk51bWJlciksICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IG5vdCBiZSBhIGR1cGxpY2F0ZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uTnVtYmVycyArPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LmFkZCh2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChpbnRlcm5hbHMuZ3VpZFNlcGFyYXRvcnMuaGFzKG9wdGlvbnMuc2VwYXJhdG9yKSwgJ3NlcGFyYXRvciBtdXN0IGJlIG9uZSBvZiB0cnVlLCBmYWxzZSwgXCItXCIsIG9yIFwiOlwiJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucy5zZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICdbOi1dPycgOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcGFyYXRvciA9PT0gdHJ1ZSA/ICdbOi1dJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcGFyYXRvciA9PT0gZmFsc2UgPyAnW10/JyA6IGBcXFxcJHtvcHRpb25zLnNlcGFyYXRvcn1gO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeKFtcXFxcW3tcXFxcKF0/KVswLTlBLUZdezh9KCR7c2VwYXJhdG9yfSlbMC05QS1GXXs0fVxcXFwyP1ske3ZlcnNpb25OdW1iZXJzIHx8ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1ske3ZlcnNpb25OdW1iZXJzID8gJzg5QUInIDogJzAtOUEtRid9XVswLTlBLUZdezN9XFxcXDI/WzAtOUEtRl17MTJ9KFtcXFxcXX1cXFxcKV0/KSRgLCAnaScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2d1aWQnLCBhcmdzOiB7IG9wdGlvbnMgfSwgcmVnZXggfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHsgcmVnZXggfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZ3VpZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoaW5nIGJyYWNlc1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5ndWlkQnJhY2tldHNbcmVzdWx0c1sxXV0gIT09IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmd1aWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGV4OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2J5dGVBbGlnbmVkJywgJ3ByZWZpeCddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGJ5dGVBbGlnbmVkOiBmYWxzZSwgcHJlZml4OiBmYWxzZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5ieXRlQWxpZ25lZCA9PT0gJ2Jvb2xlYW4nLCAnYnl0ZUFsaWduZWQgbXVzdCBiZSBib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gJ2Jvb2xlYW4nIHx8IG9wdGlvbnMucHJlZml4ID09PSAnb3B0aW9uYWwnLCAncHJlZml4IG11c3QgYmUgYm9vbGVhbiBvciBcIm9wdGlvbmFsXCInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdoZXgnLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlID0gb3B0aW9ucy5wcmVmaXggPT09ICdvcHRpb25hbCcgP1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaGV4UmVnZXgud2l0aE9wdGlvbmFsUHJlZml4IDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXggPT09IHRydWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmhleFJlZ2V4LndpdGhQcmVmaXggOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmhleFJlZ2V4LndpdGhvdXRQcmVmaXg7XG4gICAgICAgICAgICAgICAgaWYgKCFyZS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhleCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVBbGlnbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhleEFsaWduJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhvc3RuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2hvc3RuYW1lJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChEb21haW4uaXNWYWxpZCh2YWx1ZSwgeyBtaW5Eb21haW5TZWdtZW50czogMSB9KSB8fFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaXBSZWdleC50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhvc3RuYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaW5zZW5zaXRpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpcDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydjaWRyJywgJ3ZlcnNpb24nXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGNpZHIsIHZlcnNpb25zLCByZWdleCB9ID0gSXAucmVnZXgob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/IHZlcnNpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdpcCcsIGFyZ3M6IHsgb3B0aW9uczogeyBjaWRyLCB2ZXJzaW9uIH0gfSwgcmVnZXggfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4IH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlwVmVyc2lvbicsIHsgdmFsdWUsIGNpZHI6IG9wdGlvbnMuY2lkciwgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaXAnLCB7IHZhbHVlLCBjaWRyOiBvcHRpb25zLmNpZHIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvRGF0ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpc29EYXRlJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5pc29EYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcuaXNvRGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzb0R1cmF0aW9uOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2lzb0R1cmF0aW9uJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNvRHVyYXRpb25SZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pc29EdXJhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ2xlbmd0aCcsIGxpbWl0LCAnPScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCwgZW5jb2RpbmcgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGluZyA/IEJ1ZmZlciAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmcpIDogdmFsdWUubGVuZ3RoOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZShsZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlLCBlbmNvZGluZyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZW5jb2RpbmcnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG93ZXJjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXNlKCdsb3dlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ21heCcsIGxpbWl0LCAnPD0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydsaW1pdCcsICdlbmNvZGluZyddXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbWluJywgbGltaXQsICc+PScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2xpbWl0JywgJ2VuY29kaW5nJ11cbiAgICAgICAgfSxcblxuICAgICAgICBub3JtYWxpemU6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtID0gJ05GQycpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmluY2x1ZGVzKGZvcm0pLCAnbm9ybWFsaXphdGlvbiBmb3JtIG11c3QgYmUgb25lIG9mICcgKyBpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmpvaW4oJywgJykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ25vcm1hbGl6ZScsIGFyZ3M6IHsgZm9ybSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0sIHsgZm9ybSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZhbHVlLm5vcm1hbGl6ZShmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcubm9ybWFsaXplJywgeyB2YWx1ZSwgZm9ybSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgYWxpYXM6ICdyZWdleCcsXG4gICAgICAgICAgICBtZXRob2QocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwLCAncmVnZXggbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ3knKSwgJ3JlZ2V4IHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0geyBuYW1lOiBvcHRpb25zIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpbnZlcnQnLCAnbmFtZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IFsnc3RyaW5nLnBhdHRlcm4nLCBvcHRpb25zLmludmVydCA/ICcuaW52ZXJ0JyA6ICcnLCBvcHRpb25zLm5hbWUgPyAnLm5hbWUnIDogJy5iYXNlJ10uam9pbignJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3BhdHRlcm4nLCBhcmdzOiB7IHJlZ2V4LCBvcHRpb25zIH0sIGVycm9yQ29kZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyByZWdleCwgb3B0aW9ucyB9LCB7IGVycm9yQ29kZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSByZWdleC50ZXN0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuTWF0Y2ggXiBvcHRpb25zLmludmVydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoZXJyb3JDb2RlLCB7IG5hbWU6IG9wdGlvbnMubmFtZSwgcmVnZXgsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsncmVnZXgnLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgcmVwbGFjZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoRXNjYXBlUmVnZXgocGF0dGVybiksICdnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAsICdwYXR0ZXJuIG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnc3RyaW5nJywgJ3JlcGxhY2VtZW50IG11c3QgYmUgYSBTdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cy5wdXNoKHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCd0b2tlbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoL15cXHcrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudG9rZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmltOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3RyaW0nLCBhcmdzOiB7IGVuYWJsZWQgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBlbmFibGVkIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdmFsdWUudHJpbSgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudHJpbScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICB0cnVuY2F0ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndHJ1bmNhdGUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cHBlcmNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhc2UoJ3VwcGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXJpOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93UmVsYXRpdmUnLCAnYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzJywgJ2RvbWFpbicsICdyZWxhdGl2ZU9ubHknLCAnc2NoZW1lJywgJ2VuY29kZVVyaSddKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLmRvbWFpbiwgWydhbGxvd0Z1bGx5UXVhbGlmaWVkJywgJ2FsbG93VW5pY29kZScsICdtYXhEb21haW5TZWdtZW50cycsICdtaW5Eb21haW5TZWdtZW50cycsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVnZXgsIHNjaGVtZSB9ID0gVXJpLnJlZ2V4KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluID8gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMuZG9tYWluKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3VyaScsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgZG9tYWluLCBzY2hlbWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4LCBkb21haW4sIHNjaGVtZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoWydodHRwOi8nLCAnaHR0cHM6LyddLmluY2x1ZGVzKHZhbHVlKSkgeyAgICAgICAgICAgIC8vIHNjaGVtZTovIGlzIHRlY2huaWNhbGx5IHZhbGlkIGJ1dCBtYWtlcyBubyBzZW5zZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCAmJiBoZWxwZXJzLnByZWZzLmNvbnZlcnQgJiYgb3B0aW9ucy5lbmNvZGVVcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZVVSSSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhlbmNvZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVuY29kZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuYWxsb3dSZWxhdGl2ZSB8fCBtYXRjaGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIURvbWFpbi5pc1ZhbGlkKG1hdGNoZWQsIGRvbWFpbikpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5kb21haW4nLCB7IHZhbHVlOiBtYXRjaGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaVJlbGF0aXZlT25seScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaUN1c3RvbVNjaGVtZScsIHsgc2NoZW1lLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBwYXR0ZXJuLCByZXBsYWNlbWVudCB9IG9mIGRlc2MucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ3N0cmluZy5hbHBoYW51bSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzdHJpbmcnLFxuICAgICAgICAnc3RyaW5nLmJhc2U2NCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBiYXNlNjQgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5jcmVkaXRDYXJkJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGNyZWRpdCBjYXJkJyxcbiAgICAgICAgJ3N0cmluZy5kYXRhVXJpJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGRhdGFVcmkgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5kb21haW4nOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYSB2YWxpZCBkb21haW4gbmFtZScsXG4gICAgICAgICdzdHJpbmcuZW1haWwnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICAgICAgICAnc3RyaW5nLmVtcHR5JzogJ3t7I2xhYmVsfX0gaXMgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHknLFxuICAgICAgICAnc3RyaW5nLmd1aWQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgR1VJRCcsXG4gICAgICAgICdzdHJpbmcuaGV4JzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcuaGV4QWxpZ24nOiAne3sjbGFiZWx9fSBoZXggZGVjb2RlZCByZXByZXNlbnRhdGlvbiBtdXN0IGJlIGJ5dGUgYWxpZ25lZCcsXG4gICAgICAgICdzdHJpbmcuaG9zdG5hbWUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgaG9zdG5hbWUnLFxuICAgICAgICAnc3RyaW5nLmlwJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgd2l0aCBhIHt7I2NpZHJ9fSBDSURSJyxcbiAgICAgICAgJ3N0cmluZy5pcFZlcnNpb24nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcyBvZiBvbmUgb2YgdGhlIGZvbGxvd2luZyB2ZXJzaW9ucyB7eyN2ZXJzaW9ufX0gd2l0aCBhIHt7I2NpZHJ9fSBDSURSJyxcbiAgICAgICAgJ3N0cmluZy5pc29EYXRlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBpbiBpc28gZm9ybWF0JyxcbiAgICAgICAgJ3N0cmluZy5pc29EdXJhdGlvbic6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBJU08gODYwMSBkdXJhdGlvbicsXG4gICAgICAgICdzdHJpbmcubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbGVuZ3RoIG11c3QgYmUge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLmxvd2VyY2FzZSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5tYXgnOiAne3sjbGFiZWx9fSBsZW5ndGggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLm1pbic6ICd7eyNsYWJlbH19IGxlbmd0aCBtdXN0IGJlIGF0IGxlYXN0IHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5ub3JtYWxpemUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIHVuaWNvZGUgbm9ybWFsaXplZCBpbiB0aGUge3sjZm9ybX19IGZvcm0nLFxuICAgICAgICAnc3RyaW5nLnRva2VuJzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBhbmQgdW5kZXJzY29yZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmJhc2UnOiAne3sjbGFiZWx9fSB3aXRoIHZhbHVlIHs6Wy5dfSBmYWlscyB0byBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVybjoge3sjcmVnZXh9fScsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5uYW1lJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gZmFpbHMgdG8gbWF0Y2ggdGhlIHt7I25hbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmludmVydC5iYXNlJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gbWF0Y2hlcyB0aGUgaW52ZXJ0ZWQgcGF0dGVybjoge3sjcmVnZXh9fScsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5pbnZlcnQubmFtZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IG1hdGNoZXMgdGhlIGludmVydGVkIHt7I25hbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgJ3N0cmluZy50cmltJzogJ3t7I2xhYmVsfX0gbXVzdCBub3QgaGF2ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UnLFxuICAgICAgICAnc3RyaW5nLnVyaSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCB1cmknLFxuICAgICAgICAnc3RyaW5nLnVyaUN1c3RvbVNjaGVtZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCB1cmkgd2l0aCBhIHNjaGVtZSBtYXRjaGluZyB0aGUge3sjc2NoZW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcudXJpUmVsYXRpdmVPbmx5JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIHJlbGF0aXZlIHVyaScsXG4gICAgICAgICdzdHJpbmcudXBwZXJjYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gdXBwZXJjYXNlIGNoYXJhY3RlcnMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMudGxkcyB8fCBvcHRpb25zOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIH1cblxuICAgIC8vIG1pbkRvbWFpblNlZ21lbnRzXG5cbiAgICBBc3NlcnQob3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMpICYmIG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgPiAwLCAnbWluRG9tYWluU2VnbWVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgIC8vIG1heERvbWFpblNlZ21lbnRzXG5cbiAgICBBc3NlcnQob3B0aW9ucy5tYXhEb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpICYmIG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMgPiAwLCAnbWF4RG9tYWluU2VnbWVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgIC8vIHRsZHNcblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IHRydWUgfHxcbiAgICAgICAgb3B0aW9ucy50bGRzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLnRsZHMsICdCdWlsdC1pbiBUTEQgbGlzdCBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgaW50ZXJuYWxzLnRsZHMpO1xuICAgIH1cblxuICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy50bGRzID09PSAnb2JqZWN0JywgJ3RsZHMgbXVzdCBiZSB0cnVlLCBmYWxzZSwgb3IgYW4gb2JqZWN0Jyk7XG5cbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy50bGRzLmRlbnk7XG4gICAgaWYgKGRlbnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVueSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IHsgZGVueTogbmV3IFNldChkZW55KSB9IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMudGxkcy5kZW55IGluc3RhbmNlb2YgU2V0LCAndGxkcy5kZW55IG11c3QgYmUgYW4gYXJyYXksIFNldCwgb3IgYm9vbGVhbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMudGxkcy5hbGxvdywgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggdGxkcy5hbGxvdyBhbmQgdGxkcy5kZW55IGxpc3RzJyk7XG4gICAgICAgIGludGVybmFscy52YWxpZGF0ZVRsZHMob3B0aW9ucy50bGRzLmRlbnksICd0bGRzLmRlbnknKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLnRsZHMuYWxsb3c7XG4gICAgaWYgKCFhbGxvdykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoYWxsb3cgPT09IHRydWUpIHtcbiAgICAgICAgQXNzZXJ0KGludGVybmFscy50bGRzLCAnQnVpbHQtaW4gVExEIGxpc3QgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIGludGVybmFscy50bGRzKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxvdykpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxkczogeyBhbGxvdzogbmV3IFNldChhbGxvdykgfSB9KTtcbiAgICB9XG5cbiAgICBBc3NlcnQob3B0aW9ucy50bGRzLmFsbG93IGluc3RhbmNlb2YgU2V0LCAndGxkcy5hbGxvdyBtdXN0IGJlIGFuIGFycmF5LCBTZXQsIG9yIGJvb2xlYW4nKTtcbiAgICBpbnRlcm5hbHMudmFsaWRhdGVUbGRzKG9wdGlvbnMudGxkcy5hbGxvdywgJ3RsZHMuYWxsb3cnKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlVGxkcyA9IGZ1bmN0aW9uIChzZXQsIHNvdXJjZSkge1xuXG4gICAgZm9yIChjb25zdCB0bGQgb2Ygc2V0KSB7XG4gICAgICAgIEFzc2VydChEb21haW4uaXNWYWxpZCh0bGQsIHsgbWluRG9tYWluU2VnbWVudHM6IDEsIG1heERvbWFpblNlZ21lbnRzOiAxIH0pLCBgJHtzb3VyY2V9IG11c3QgY29udGFpbiB2YWxpZCB0b3AgbGV2ZWwgZG9tYWluIG5hbWVzYCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuaXNvRGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgaWYgKCFDb21tb24uaXNJc29EYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoLy4qVC4qWystXVxcZFxcZCQvLnRlc3QodmFsdWUpKSB7ICAgICAgICAgICAgIC8vIEFkZCBtaXNzaW5nIHRyYWlsaW5nIHplcm9zIHRvIHRpbWVzaGlmdFxuICAgICAgICB2YWx1ZSArPSAnMDAnO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xufTtcblxuXG5pbnRlcm5hbHMubGVuZ3RoID0gZnVuY3Rpb24gKHNjaGVtYSwgbmFtZSwgbGltaXQsIG9wZXJhdG9yLCBlbmNvZGluZykge1xuXG4gICAgQXNzZXJ0KCFlbmNvZGluZyB8fCBCdWZmZXIgJiYgQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7ICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG5cbiAgICByZXR1cm4gc2NoZW1hLiRfYWRkUnVsZSh7IG5hbWUsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQsIGVuY29kaW5nIH0sIG9wZXJhdG9yIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/symbol.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/symbol.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\n\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\n\n\nconst internals = {};\n\n\ninternals.Map = class extends Map {\n\n    slice() {\n\n        return new internals.Map(this);\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'symbol',\n\n    terms: {\n\n        map: { init: new internals.Map() }\n    },\n\n    coerce: {\n        method(value, { schema, error }) {\n\n            const lookup = schema.$_terms.map.get(value);\n            if (lookup) {\n                value = lookup;\n            }\n\n            if (!schema._flags.only ||\n                typeof value === 'symbol') {\n\n                return { value };\n            }\n\n            return { value, errors: error('symbol.map', { map: schema.$_terms.map }) };\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'symbol') {\n            return { value, errors: error('symbol.base') };\n        }\n    },\n\n    rules: {\n        map: {\n            method(iterable) {\n\n                if (iterable &&\n                    !iterable[Symbol.iterator] &&\n                    typeof iterable === 'object') {\n\n                    iterable = Object.entries(iterable);\n                }\n\n                Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');\n\n                const obj = this.clone();\n\n                const symbols = [];\n                for (const entry of iterable) {\n                    Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');\n                    const [key, value] = entry;\n\n                    Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');\n                    Assert(typeof value === 'symbol', 'Value must be a Symbol');\n\n                    obj.$_terms.map.set(key, value);\n                    symbols.push(value);\n                }\n\n                return obj.valid(...symbols);\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.map) {\n                obj = obj.map(desc.map);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'symbol.base': '{{#label}} must be a symbol',\n        'symbol.map': '{{#label}} must be one of {{#map}}'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zeW1ib2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1Qjs7QUFFOUMsWUFBWSxtQkFBTyxDQUFDLHdEQUFPOzs7QUFHM0I7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTtBQUNmLEtBQUs7O0FBRUw7QUFDQSx3QkFBd0IsZUFBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUEscUJBQXFCLHFDQUFxQyx5QkFBeUI7QUFDbkY7QUFDQSxLQUFLOztBQUVMLHNCQUFzQixPQUFPOztBQUU3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkMseUJBQXlCLFNBQVMsaUJBQWlCLE1BQU07QUFDekQ7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vTGlzdGVuLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvc3ltYm9sLmpzPzMzMmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuTWFwID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuXG4gICAgc2xpY2UoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuTWFwKHRoaXMpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdzeW1ib2wnLFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBtYXA6IHsgaW5pdDogbmV3IGludGVybmFscy5NYXAoKSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IHNjaGVtYS4kX3Rlcm1zLm1hcC5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbG9va3VwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3Mub25seSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzeW1ib2wubWFwJywgeyBtYXA6IHNjaGVtYS4kX3Rlcm1zLm1hcCB9KSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N5bWJvbC5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIG1ldGhvZChpdGVyYWJsZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICFpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVyYWJsZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdC5lbnRyaWVzKGl0ZXJhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSwgJ0l0ZXJhYmxlIG11c3QgYmUgYW4gaXRlcmFibGUgb3Igb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoZW50cnkgJiYgZW50cnlbU3ltYm9sLml0ZXJhdG9yXSwgJ0VudHJ5IG11c3QgYmUgYW4gaXRlcmFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gZW50cnk7XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBrZXkgIT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGtleSAhPT0gJ3N5bWJvbCcsICdLZXkgbXVzdCBub3QgYmUgb2YgdHlwZSBvYmplY3QsIGZ1bmN0aW9uLCBvciBTeW1ib2wnKTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcsICdWYWx1ZSBtdXN0IGJlIGEgU3ltYm9sJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9scy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLnZhbGlkKC4uLnN5bWJvbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm1hcCkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5tYXAoZGVzYy5tYXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdzeW1ib2wuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzeW1ib2wnLFxuICAgICAgICAnc3ltYm9sLm1hcCc6ICd7eyNsYWJlbH19IG11c3QgYmUgb25lIG9mIHt7I21hcH19J1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/symbol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/validator.js":
/*!*******************************************!*\
  !*** ./node_modules/joi/lib/validator.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Ignore = __webpack_require__(/*! @hapi/hoek/lib/ignore */ \"(rsc)/./node_modules/@hapi/hoek/lib/ignore.js\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"(rsc)/./node_modules/@hapi/hoek/lib/reach.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst State = __webpack_require__(/*! ./state */ \"(rsc)/./node_modules/joi/lib/state.js\");\n\n\nconst internals = {\n    result: Symbol('result')\n};\n\n\nexports.entry = function (value, schema, prefs) {\n\n    let settings = Common.defaults;\n    if (prefs) {\n        Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');\n        Assert(prefs.artifacts === undefined, 'Cannot override artifacts preference in synchronous validation');\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n\n    const result = internals.entry(value, schema, settings);\n    Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');\n    const outcome = { value: result.value };\n\n    if (result.error) {\n        outcome.error = result.error;\n    }\n\n    if (result.mainstay.warnings.length) {\n        outcome.warning = Errors.details(result.mainstay.warnings);\n    }\n\n    if (result.mainstay.debug) {\n        outcome.debug = result.mainstay.debug;\n    }\n\n    if (result.mainstay.artifacts) {\n        outcome.artifacts = result.mainstay.artifacts;\n    }\n\n    return outcome;\n};\n\n\nexports.entryAsync = async function (value, schema, prefs) {\n\n    let settings = Common.defaults;\n    if (prefs) {\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n\n    const result = internals.entry(value, schema, settings);\n    const mainstay = result.mainstay;\n    if (result.error) {\n        if (mainstay.debug) {\n            result.error.debug = mainstay.debug;\n        }\n\n        throw result.error;\n    }\n\n    if (mainstay.externals.length) {\n        let root = result.value;\n        const errors = [];\n        for (const external of mainstay.externals) {\n            const path = external.state.path;\n            const linked = external.schema.type === 'link' ? mainstay.links.get(external.schema) : null;\n            let node = root;\n            let key;\n            let parent;\n\n            const ancestors = path.length ? [root] : [];\n            const original = path.length ? Reach(value, path) : value;\n\n            if (path.length) {\n                key = path[path.length - 1];\n\n                let current = root;\n                for (const segment of path.slice(0, -1)) {\n                    current = current[segment];\n                    ancestors.unshift(current);\n                }\n\n                parent = ancestors[0];\n                node = parent[key];\n            }\n\n            try {\n                const createError = (code, local) => (linked || external.schema).$_createError(code, node, local, external.state, settings);\n                const output = await external.method(node, {\n                    schema: external.schema,\n                    linked,\n                    state: external.state,\n                    prefs,\n                    original,\n                    error: createError,\n                    errorsArray: internals.errorsArray,\n                    warn: (code, local) => mainstay.warnings.push((linked || external.schema).$_createError(code, node, local, external.state, settings)),\n                    message: (messages, local) => (linked || external.schema).$_createError('external', node, local, external.state, settings, { messages })\n                });\n\n                if (output === undefined ||\n                    output === node) {\n\n                    continue;\n                }\n\n                if (output instanceof Errors.Report) {\n                    mainstay.tracer.log(external.schema, external.state, 'rule', 'external', 'error');\n                    errors.push(output);\n\n                    if (settings.abortEarly) {\n                        break;\n                    }\n\n                    continue;\n                }\n\n                if (Array.isArray(output) &&\n                    output[Common.symbols.errors]) {\n                    mainstay.tracer.log(external.schema, external.state, 'rule', 'external', 'error');\n                    errors.push(...output);\n\n                    if (settings.abortEarly) {\n                        break;\n                    }\n\n                    continue;\n                }\n\n                if (parent) {\n                    mainstay.tracer.value(external.state, 'rule', node, output, 'external');\n                    parent[key] = output;\n                }\n                else {\n                    mainstay.tracer.value(external.state, 'rule', root, output, 'external');\n                    root = output;\n                }\n            }\n            catch (err) {\n                if (settings.errors.label) {\n                    err.message += ` (${(external.label)})`;       // Change message to include path\n                }\n\n                throw err;\n            }\n        }\n\n        result.value = root;\n\n        if (errors.length) {\n            result.error = Errors.process(errors, value, settings);\n\n            if (mainstay.debug) {\n                result.error.debug = mainstay.debug;\n            }\n\n            throw result.error;\n        }\n    }\n\n    if (!settings.warnings &&\n        !settings.debug &&\n        !settings.artifacts) {\n\n        return result.value;\n    }\n\n    const outcome = { value: result.value };\n    if (mainstay.warnings.length) {\n        outcome.warning = Errors.details(mainstay.warnings);\n    }\n\n    if (mainstay.debug) {\n        outcome.debug = mainstay.debug;\n    }\n\n    if (mainstay.artifacts) {\n        outcome.artifacts = mainstay.artifacts;\n    }\n\n    return outcome;\n};\n\n\ninternals.Mainstay = class {\n\n    constructor(tracer, debug, links) {\n\n        this.externals = [];\n        this.warnings = [];\n        this.tracer = tracer;\n        this.debug = debug;\n        this.links = links;\n        this.shadow = null;\n        this.artifacts = null;\n\n        this._snapshots = [];\n    }\n\n    snapshot() {\n\n        this._snapshots.push({\n            externals: this.externals.slice(),\n            warnings: this.warnings.slice()\n        });\n    }\n\n    restore() {\n\n        const snapshot = this._snapshots.pop();\n        this.externals = snapshot.externals;\n        this.warnings = snapshot.warnings;\n    }\n\n    commit() {\n\n        this._snapshots.pop();\n    }\n};\n\n\ninternals.entry = function (value, schema, prefs) {\n\n    // Prepare state\n\n    const { tracer, cleanup } = internals.tracer(schema, prefs);\n    const debug = prefs.debug ? [] : null;\n    const links = schema._ids._schemaChain ? new Map() : null;\n    const mainstay = new internals.Mainstay(tracer, debug, links);\n    const schemas = schema._ids._schemaChain ? [{ schema }] : null;\n    const state = new State([], [], { mainstay, schemas });\n\n    // Validate value\n\n    const result = exports.validate(value, schema, state, prefs);\n\n    // Process value and errors\n\n    if (cleanup) {\n        schema.$_root.untrace();\n    }\n\n    const error = Errors.process(result.errors, value, prefs);\n    return { value: result.value, error, mainstay };\n};\n\n\ninternals.tracer = function (schema, prefs) {\n\n    if (schema.$_root._tracer) {\n        return { tracer: schema.$_root._tracer._register(schema) };\n    }\n\n    if (prefs.debug) {\n        Assert(schema.$_root.trace, 'Debug mode not supported');\n        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };\n    }\n\n    return { tracer: internals.ignore };\n};\n\n\nexports.validate = function (value, schema, state, prefs, overrides = {}) {\n\n    if (schema.$_terms.whens) {\n        schema = schema._generate(value, state, prefs).schema;\n    }\n\n    // Setup state and settings\n\n    if (schema._preferences) {\n        prefs = internals.prefs(schema, prefs);\n    }\n\n    // Cache\n\n    if (schema._cache &&\n        prefs.cache) {\n\n        const result = schema._cache.get(value);\n        state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);\n        if (result) {\n            return result;\n        }\n    }\n\n    // Helpers\n\n    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);\n    const helpers = {\n        original: value,\n        prefs,\n        schema,\n        state,\n        error: createError,\n        errorsArray: internals.errorsArray,\n        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),\n        message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, { messages })\n    };\n\n    // Prepare\n\n    state.mainstay.tracer.entry(schema, state);\n\n    const def = schema._definition;\n    if (def.prepare &&\n        value !== undefined &&\n        prefs.convert) {\n\n        const prepared = def.prepare(value, helpers);\n        if (prepared) {\n            state.mainstay.tracer.value(state, 'prepare', value, prepared.value);\n            if (prepared.errors) {\n                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);         // Prepare error always aborts early\n            }\n\n            value = prepared.value;\n        }\n    }\n\n    // Type coercion\n\n    if (def.coerce &&\n        value !== undefined &&\n        prefs.convert &&\n        (!def.coerce.from || def.coerce.from.includes(typeof value))) {\n\n        const coerced = def.coerce.method(value, helpers);\n        if (coerced) {\n            state.mainstay.tracer.value(state, 'coerced', value, coerced.value);\n            if (coerced.errors) {\n                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);           // Coerce error always aborts early\n            }\n\n            value = coerced.value;\n        }\n    }\n\n    // Empty value\n\n    const empty = schema._flags.empty;\n    if (empty &&\n        empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {\n\n        state.mainstay.tracer.value(state, 'empty', value, undefined);\n        value = undefined;\n    }\n\n    // Presence requirements (required, optional, forbidden)\n\n    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);\n    if (value === undefined) {\n        if (presence === 'forbidden') {\n            return internals.finalize(value, null, helpers);\n        }\n\n        if (presence === 'required') {\n            return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);\n        }\n\n        if (presence === 'optional') {\n            if (schema._flags.default !== Common.symbols.deepDefault) {\n                return internals.finalize(value, null, helpers);\n            }\n\n            state.mainstay.tracer.value(state, 'default', value, {});\n            value = {};\n        }\n    }\n    else if (presence === 'forbidden') {\n        return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);\n    }\n\n    // Allowed values\n\n    const errors = [];\n\n    if (schema._valids) {\n        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            if (prefs.convert) {\n                state.mainstay.tracer.value(state, 'valids', value, match.value);\n                value = match.value;\n            }\n\n            state.mainstay.tracer.filter(schema, state, 'valid', match);\n            return internals.finalize(value, null, helpers);\n        }\n\n        if (schema._flags.only) {\n            const report = schema.$_createError('any.only', value, { valids: schema._valids.values({ display: true }) }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [report], helpers);\n            }\n\n            errors.push(report);\n        }\n    }\n\n    // Denied values\n\n    if (schema._invalids) {\n        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            state.mainstay.tracer.filter(schema, state, 'invalid', match);\n            const report = schema.$_createError('any.invalid', value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [report], helpers);\n            }\n\n            errors.push(report);\n        }\n    }\n\n    // Base type\n\n    if (def.validate) {\n        const base = def.validate(value, helpers);\n        if (base) {\n            state.mainstay.tracer.value(state, 'base', value, base.value);\n            value = base.value;\n\n            if (base.errors) {\n                if (!Array.isArray(base.errors)) {\n                    errors.push(base.errors);\n                    return internals.finalize(value, errors, helpers);          // Base error always aborts early\n                }\n\n                if (base.errors.length) {\n                    errors.push(...base.errors);\n                    return internals.finalize(value, errors, helpers);          // Base error always aborts early\n                }\n            }\n        }\n    }\n\n    // Validate tests\n\n    if (!schema._rules.length) {\n        return internals.finalize(value, errors, helpers);\n    }\n\n    return internals.rules(value, errors, helpers);\n};\n\n\ninternals.rules = function (value, errors, helpers) {\n\n    const { schema, state, prefs } = helpers;\n\n    for (const rule of schema._rules) {\n        const definition = schema._definition.rules[rule.method];\n\n        // Skip rules that are also applied in coerce step\n\n        if (definition.convert &&\n            prefs.convert) {\n\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');\n            continue;\n        }\n\n        // Resolve references\n\n        let ret;\n        let args = rule.args;\n        if (rule._resolve.length) {\n            args = Object.assign({}, args);                                     // Shallow copy\n            for (const key of rule._resolve) {\n                const resolver = definition.argsByName.get(key);\n\n                const resolved = args[key].resolve(value, state, prefs);\n                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;\n\n                const invalid = Common.validateArg(normalized, null, resolver);\n                if (invalid) {\n                    ret = schema.$_createError('any.ref', resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);\n                    break;\n                }\n\n                args[key] = normalized;\n            }\n        }\n\n        // Test rule\n\n        ret = ret || definition.validate(value, helpers, args, rule);           // Use ret if already set to reference error\n\n        const result = internals.rule(ret, rule);\n        if (result.errors) {\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');\n\n            if (rule.warn) {\n                state.mainstay.warnings.push(...result.errors);\n                continue;\n            }\n\n            if (prefs.abortEarly) {\n                return internals.finalize(value, result.errors, helpers);\n            }\n\n            errors.push(...result.errors);\n        }\n        else {\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');\n            state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);\n            value = result.value;\n        }\n    }\n\n    return internals.finalize(value, errors, helpers);\n};\n\n\ninternals.rule = function (ret, rule) {\n\n    if (ret instanceof Errors.Report) {\n        internals.error(ret, rule);\n        return { errors: [ret], value: null };\n    }\n\n    if (Array.isArray(ret) &&\n        ret[Common.symbols.errors]) {\n\n        ret.forEach((report) => internals.error(report, rule));\n        return { errors: ret, value: null };\n    }\n\n    return { errors: null, value: ret };\n};\n\n\ninternals.error = function (report, rule) {\n\n    if (rule.message) {\n        report._setTemplate(rule.message);\n    }\n\n    return report;\n};\n\n\ninternals.finalize = function (value, errors, helpers) {\n\n    errors = errors || [];\n    const { schema, state, prefs } = helpers;\n\n    // Failover value\n\n    if (errors.length) {\n        const failover = internals.default('failover', undefined, errors, helpers);\n        if (failover !== undefined) {\n            state.mainstay.tracer.value(state, 'failover', value, failover);\n            value = failover;\n            errors = [];\n        }\n    }\n\n    // Error override\n\n    if (errors.length &&\n        schema._flags.error) {\n\n        if (typeof schema._flags.error === 'function') {\n            errors = schema._flags.error(errors);\n            if (!Array.isArray(errors)) {\n                errors = [errors];\n            }\n\n            for (const error of errors) {\n                Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');\n            }\n        }\n        else {\n            errors = [schema._flags.error];\n        }\n    }\n\n    // Default\n\n    if (value === undefined) {\n        const defaulted = internals.default('default', value, errors, helpers);\n        state.mainstay.tracer.value(state, 'default', value, defaulted);\n        value = defaulted;\n    }\n\n    // Cast\n\n    if (schema._flags.cast &&\n        value !== undefined) {\n\n        const caster = schema._definition.cast[schema._flags.cast];\n        if (caster.from(value)) {\n            const casted = caster.to(value, helpers);\n            state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);\n            value = casted;\n        }\n    }\n\n    // Externals\n\n    if (schema.$_terms.externals &&\n        prefs.externals &&\n        prefs._externals !== false) {                       // Disabled for matching\n\n        for (const { method } of schema.$_terms.externals) {\n            state.mainstay.externals.push({ method, schema, state, label: Errors.label(schema._flags, state, prefs) });\n        }\n    }\n\n    // Result\n\n    const result = { value, errors: errors.length ? errors : null };\n\n    if (schema._flags.result) {\n        result.value = schema._flags.result === 'strip' ? undefined : /* raw */ helpers.original;\n        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);\n        state.shadow(value, schema._flags.result);\n    }\n\n    // Cache\n\n    if (schema._cache &&\n        prefs.cache !== false &&\n        !schema._refs.length) {\n\n        schema._cache.set(helpers.original, result);\n    }\n\n    // Artifacts\n\n    if (value !== undefined &&\n        !result.errors &&\n        schema._flags.artifact !== undefined) {\n\n        state.mainstay.artifacts = state.mainstay.artifacts || new Map();\n        if (!state.mainstay.artifacts.has(schema._flags.artifact)) {\n            state.mainstay.artifacts.set(schema._flags.artifact, []);\n        }\n\n        state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);\n    }\n\n    return result;\n};\n\n\ninternals.prefs = function (schema, prefs) {\n\n    const isDefaultOptions = prefs === Common.defaults;\n    if (isDefaultOptions &&\n        schema._preferences[Common.symbols.prefs]) {\n\n        return schema._preferences[Common.symbols.prefs];\n    }\n\n    prefs = Common.preferences(prefs, schema._preferences);\n    if (isDefaultOptions) {\n        schema._preferences[Common.symbols.prefs] = prefs;\n    }\n\n    return prefs;\n};\n\n\ninternals.default = function (flag, value, errors, helpers) {\n\n    const { schema, state, prefs } = helpers;\n    const source = schema._flags[flag];\n    if (prefs.noDefaults ||\n        source === undefined) {\n\n        return value;\n    }\n\n    state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');\n\n    if (!source) {\n        return source;\n    }\n\n    if (typeof source === 'function') {\n        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];\n\n        try {\n            return source(...args);\n        }\n        catch (err) {\n            errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));\n            return;\n        }\n    }\n\n    if (typeof source !== 'object') {\n        return source;\n    }\n\n    if (source[Common.symbols.literal]) {\n        return source.literal;\n    }\n\n    if (Common.isResolvable(source)) {\n        return source.resolve(value, state, prefs);\n    }\n\n    return Clone(source);\n};\n\n\ninternals.trim = function (value, schema) {\n\n    if (typeof value !== 'string') {\n        return value;\n    }\n\n    const trim = schema.$_getRule('trim');\n    if (!trim ||\n        !trim.args.enabled) {\n\n        return value;\n    }\n\n    return value.trim();\n};\n\n\ninternals.ignore = {\n    active: false,\n    debug: Ignore,\n    entry: Ignore,\n    filter: Ignore,\n    log: Ignore,\n    resolve: Ignore,\n    value: Ignore\n};\n\n\ninternals.errorsArray = function () {\n\n    const errors = [];\n    errors[Common.symbols.errors] = true;\n    return errors;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1QjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsMEVBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyw0RUFBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLDBFQUFzQjs7QUFFNUMsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsc0RBQVM7OztBQUcvQjtBQUNBO0FBQ0E7OztBQUdBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlKQUFpSixVQUFVO0FBQzNKLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQixVQUFVO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQsc0NBQXNDLG1CQUFtQjs7QUFFekQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOzs7QUFHQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLGFBQWE7QUFDYjs7O0FBR0EsZ0JBQWdCLHdEQUF3RDs7QUFFeEU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsVUFBVTtBQUM3Rzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4Rzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsZ0NBQWdDLGVBQWUsR0FBRztBQUN2SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLG9DQUFvQyxlQUFlLEdBQUc7QUFDOUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSxZQUFZLHVCQUF1Qjs7QUFFbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkNBQTZDO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLDJDQUEyQztBQUNqSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnRkFBZ0Y7O0FBRWhGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsYUFBYTtBQUNiOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxZQUFZLHVCQUF1Qjs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQscUJBQXFCLFNBQVM7QUFDOUIsNENBQTRDLHlFQUF5RTtBQUNySDtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLLFdBQVcsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MaXN0ZW4vLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWxpZGF0b3IuanM/NzUzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgSWdub3JlID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvaWdub3JlJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgU3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlc3VsdDogU3ltYm9sKCdyZXN1bHQnKVxufTtcblxuXG5leHBvcnRzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKHByZWZzKSB7XG4gICAgICAgIEFzc2VydChwcmVmcy53YXJuaW5ncyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIHdhcm5pbmdzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBBc3NlcnQocHJlZnMuYXJ0aWZhY3RzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgYXJ0aWZhY3RzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBzZXR0aW5ncyA9IENvbW1vbi5wcmVmZXJlbmNlcyhDb21tb24uZGVmYXVsdHMsIHByZWZzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuZW50cnkodmFsdWUsIHNjaGVtYSwgc2V0dGluZ3MpO1xuICAgIEFzc2VydCghcmVzdWx0Lm1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgsICdTY2hlbWEgd2l0aCBleHRlcm5hbCBydWxlcyBtdXN0IHVzZSB2YWxpZGF0ZUFzeW5jKCknKTtcbiAgICBjb25zdCBvdXRjb21lID0geyB2YWx1ZTogcmVzdWx0LnZhbHVlIH07XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIG91dGNvbWUuZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMocmVzdWx0Lm1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgIG91dGNvbWUuZGVidWcgPSByZXN1bHQubWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSByZXN1bHQubWFpbnN0YXkuYXJ0aWZhY3RzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xufTtcblxuXG5leHBvcnRzLmVudHJ5QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBDb21tb24ucHJlZmVyZW5jZXMoQ29tbW9uLmRlZmF1bHRzLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmVudHJ5KHZhbHVlLCBzY2hlbWEsIHNldHRpbmdzKTtcbiAgICBjb25zdCBtYWluc3RheSA9IHJlc3VsdC5tYWluc3RheTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV4dGVybmFsIG9mIG1haW5zdGF5LmV4dGVybmFscykge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGV4dGVybmFsLnN0YXRlLnBhdGg7XG4gICAgICAgICAgICBjb25zdCBsaW5rZWQgPSBleHRlcm5hbC5zY2hlbWEudHlwZSA9PT0gJ2xpbmsnID8gbWFpbnN0YXkubGlua3MuZ2V0KGV4dGVybmFsLnNjaGVtYSkgOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSByb290O1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IHBhdGgubGVuZ3RoID8gW3Jvb3RdIDogW107XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHBhdGgubGVuZ3RoID8gUmVhY2godmFsdWUsIHBhdGgpIDogdmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcm9vdDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aC5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbc2VnbWVudF07XG4gICAgICAgICAgICAgICAgICAgIGFuY2VzdG9ycy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGFuY2VzdG9yc1swXTtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlRXJyb3IgPSAoY29kZSwgbG9jYWwpID0+IChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKGNvZGUsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGV4dGVybmFsLm1ldGhvZChub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZXh0ZXJuYWwuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBsaW5rZWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBleHRlcm5hbC5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZnMsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yc0FycmF5OiBpbnRlcm5hbHMuZXJyb3JzQXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHdhcm46IChjb2RlLCBsb2NhbCkgPT4gbWFpbnN0YXkud2FybmluZ3MucHVzaCgobGlua2VkIHx8IGV4dGVybmFsLnNjaGVtYSkuJF9jcmVhdGVFcnJvcihjb2RlLCBub2RlLCBsb2NhbCwgZXh0ZXJuYWwuc3RhdGUsIHNldHRpbmdzKSksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChtZXNzYWdlcywgbG9jYWwpID0+IChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKCdleHRlcm5hbCcsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MsIHsgbWVzc2FnZXMgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPT09IG5vZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIubG9nKGV4dGVybmFsLnNjaGVtYSwgZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgJ2V4dGVybmFsJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0KSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIubG9nKGV4dGVybmFsLnNjaGVtYSwgZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgJ2V4dGVybmFsJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLm91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIudmFsdWUoZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgbm9kZSwgb3V0cHV0LCAnZXh0ZXJuYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIudmFsdWUoZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgcm9vdCwgb3V0cHV0LCAnZXh0ZXJuYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArPSBgICgkeyhleHRlcm5hbC5sYWJlbCl9KWA7ICAgICAgIC8vIENoYW5nZSBtZXNzYWdlIHRvIGluY2x1ZGUgcGF0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHJvb3Q7XG5cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IEVycm9ycy5wcm9jZXNzKGVycm9ycywgdmFsdWUsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgaWYgKG1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2V0dGluZ3Mud2FybmluZ3MgJiZcbiAgICAgICAgIXNldHRpbmdzLmRlYnVnICYmXG4gICAgICAgICFzZXR0aW5ncy5hcnRpZmFjdHMpIHtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGNvbWUgPSB7IHZhbHVlOiByZXN1bHQudmFsdWUgfTtcbiAgICBpZiAobWFpbnN0YXkud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG91dGNvbWUud2FybmluZyA9IEVycm9ycy5kZXRhaWxzKG1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAobWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgb3V0Y29tZS5kZWJ1ZyA9IG1haW5zdGF5LmRlYnVnO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSBtYWluc3RheS5hcnRpZmFjdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG59O1xuXG5cbmludGVybmFscy5NYWluc3RheSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHRyYWNlciwgZGVidWcsIGxpbmtzKSB7XG5cbiAgICAgICAgdGhpcy5leHRlcm5hbHMgPSBbXTtcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLnRyYWNlciA9IHRyYWNlcjtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICB0aGlzLmxpbmtzID0gbGlua3M7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NuYXBzaG90cyA9IFtdO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIHRoaXMuX3NuYXBzaG90cy5wdXNoKHtcbiAgICAgICAgICAgIGV4dGVybmFsczogdGhpcy5leHRlcm5hbHMuc2xpY2UoKSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzLnNsaWNlKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcblxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuX3NuYXBzaG90cy5wb3AoKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbHMgPSBzbmFwc2hvdC5leHRlcm5hbHM7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBzbmFwc2hvdC53YXJuaW5ncztcbiAgICB9XG5cbiAgICBjb21taXQoKSB7XG5cbiAgICAgICAgdGhpcy5fc25hcHNob3RzLnBvcCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICAvLyBQcmVwYXJlIHN0YXRlXG5cbiAgICBjb25zdCB7IHRyYWNlciwgY2xlYW51cCB9ID0gaW50ZXJuYWxzLnRyYWNlcihzY2hlbWEsIHByZWZzKTtcbiAgICBjb25zdCBkZWJ1ZyA9IHByZWZzLmRlYnVnID8gW10gOiBudWxsO1xuICAgIGNvbnN0IGxpbmtzID0gc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluID8gbmV3IE1hcCgpIDogbnVsbDtcbiAgICBjb25zdCBtYWluc3RheSA9IG5ldyBpbnRlcm5hbHMuTWFpbnN0YXkodHJhY2VyLCBkZWJ1ZywgbGlua3MpO1xuICAgIGNvbnN0IHNjaGVtYXMgPSBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4gPyBbeyBzY2hlbWEgfV0gOiBudWxsO1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKFtdLCBbXSwgeyBtYWluc3RheSwgc2NoZW1hcyB9KTtcblxuICAgIC8vIFZhbGlkYXRlIHZhbHVlXG5cbiAgICBjb25zdCByZXN1bHQgPSBleHBvcnRzLnZhbGlkYXRlKHZhbHVlLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICAvLyBQcm9jZXNzIHZhbHVlIGFuZCBlcnJvcnNcblxuICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgIHNjaGVtYS4kX3Jvb3QudW50cmFjZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gRXJyb3JzLnByb2Nlc3MocmVzdWx0LmVycm9ycywgdmFsdWUsIHByZWZzKTtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBlcnJvciwgbWFpbnN0YXkgfTtcbn07XG5cblxuaW50ZXJuYWxzLnRyYWNlciA9IGZ1bmN0aW9uIChzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC5fdHJhY2VyLl9yZWdpc3RlcihzY2hlbWEpIH07XG4gICAgfVxuXG4gICAgaWYgKHByZWZzLmRlYnVnKSB7XG4gICAgICAgIEFzc2VydChzY2hlbWEuJF9yb290LnRyYWNlLCAnRGVidWcgbW9kZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC50cmFjZSgpLl9yZWdpc3RlcihzY2hlbWEpLCBjbGVhbnVwOiB0cnVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhY2VyOiBpbnRlcm5hbHMuaWdub3JlIH07XG59O1xuXG5cbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMgPSB7fSkge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYS5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xuICAgIH1cblxuICAgIC8vIFNldHVwIHN0YXRlIGFuZCBzZXR0aW5nc1xuXG4gICAgaWYgKHNjaGVtYS5fcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgcHJlZnMgPSBpbnRlcm5hbHMucHJlZnMoc2NoZW1hLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGVcblxuICAgIGlmIChzY2hlbWEuX2NhY2hlICYmXG4gICAgICAgIHByZWZzLmNhY2hlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9jYWNoZS5nZXQodmFsdWUpO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICd2YWxpZGF0ZScsICdjYWNoZWQnLCAhIXJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzXG5cbiAgICBjb25zdCBjcmVhdGVFcnJvciA9IChjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoY29kZSwgdmFsdWUsIGxvY2FsLCBsb2NhbFN0YXRlIHx8IHN0YXRlLCBwcmVmcyk7XG4gICAgY29uc3QgaGVscGVycyA9IHtcbiAgICAgICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgICAgICBwcmVmcyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yLFxuICAgICAgICBlcnJvcnNBcnJheTogaW50ZXJuYWxzLmVycm9yc0FycmF5LFxuICAgICAgICB3YXJuOiAoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpID0+IHN0YXRlLm1haW5zdGF5Lndhcm5pbmdzLnB1c2goY3JlYXRlRXJyb3IoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpKSxcbiAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VzLCBsb2NhbCkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2N1c3RvbScsIHZhbHVlLCBsb2NhbCwgc3RhdGUsIHByZWZzLCB7IG1lc3NhZ2VzIH0pXG4gICAgfTtcblxuICAgIC8vIFByZXBhcmVcblxuICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5lbnRyeShzY2hlbWEsIHN0YXRlKTtcblxuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmLnByZXBhcmUgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0KSB7XG5cbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBkZWYucHJlcGFyZSh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChwcmVwYXJlZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAncHJlcGFyZScsIHZhbHVlLCBwcmVwYXJlZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShwcmVwYXJlZC52YWx1ZSwgW10uY29uY2F0KHByZXBhcmVkLmVycm9ycyksIGhlbHBlcnMpOyAgICAgICAgIC8vIFByZXBhcmUgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHByZXBhcmVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHlwZSBjb2VyY2lvblxuXG4gICAgaWYgKGRlZi5jb2VyY2UgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0ICYmXG4gICAgICAgICghZGVmLmNvZXJjZS5mcm9tIHx8IGRlZi5jb2VyY2UuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSkge1xuXG4gICAgICAgIGNvbnN0IGNvZXJjZWQgPSBkZWYuY29lcmNlLm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChjb2VyY2VkKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdjb2VyY2VkJywgdmFsdWUsIGNvZXJjZWQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShjb2VyY2VkLnZhbHVlLCBbXS5jb25jYXQoY29lcmNlZC5lcnJvcnMpLCBoZWxwZXJzKTsgICAgICAgICAgIC8vIENvZXJjZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtcHR5IHZhbHVlXG5cbiAgICBjb25zdCBlbXB0eSA9IHNjaGVtYS5fZmxhZ3MuZW1wdHk7XG4gICAgaWYgKGVtcHR5ICYmXG4gICAgICAgIGVtcHR5LiRfbWF0Y2goaW50ZXJuYWxzLnRyaW0odmFsdWUsIHNjaGVtYSksIHN0YXRlLm5lc3QoZW1wdHkpLCBDb21tb24uZGVmYXVsdHMpKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZW1wdHknLCB2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUHJlc2VuY2UgcmVxdWlyZW1lbnRzIChyZXF1aXJlZCwgb3B0aW9uYWwsIGZvcmJpZGRlbilcblxuICAgIGNvbnN0IHByZXNlbmNlID0gb3ZlcnJpZGVzLnByZXNlbmNlIHx8IHNjaGVtYS5fZmxhZ3MucHJlc2VuY2UgfHwgKHNjaGVtYS5fZmxhZ3MuX2VuZGVkU3dpdGNoID8gbnVsbCA6IHByZWZzLnByZXNlbmNlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3NjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVxdWlyZWQnLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5kZWZhdWx0ICE9PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdkZWZhdWx0JywgdmFsdWUsIHt9KTtcbiAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnVua25vd24nLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgIH1cblxuICAgIC8vIEFsbG93ZWQgdmFsdWVzXG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5fdmFsaWRzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBzY2hlbWEuX2ZsYWdzLmluc2Vuc2l0aXZlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3ZhbGlkcycsIHZhbHVlLCBtYXRjaC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmZpbHRlcihzY2hlbWEsIHN0YXRlLCAndmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm9ubHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkub25seScsIHZhbHVlLCB7IHZhbGlkczogc2NoZW1hLl92YWxpZHMudmFsdWVzKHsgZGlzcGxheTogdHJ1ZSB9KSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbcmVwb3J0XSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZW5pZWQgdmFsdWVzXG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5faW52YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYS5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5maWx0ZXIoc2NoZW1hLCBzdGF0ZSwgJ2ludmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LmludmFsaWQnLCB2YWx1ZSwgeyBpbnZhbGlkczogc2NoZW1hLl9pbnZhbGlkcy52YWx1ZXMoeyBkaXNwbGF5OiB0cnVlIH0pIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtyZXBvcnRdLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJhc2UgdHlwZVxuXG4gICAgaWYgKGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gZGVmLnZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Jhc2UnLCB2YWx1ZSwgYmFzZS52YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2UudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChiYXNlLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXNlLmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpOyAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmJhc2UuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTsgICAgICAgICAgLy8gQmFzZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGVzdHNcblxuICAgIGlmICghc2NoZW1hLl9ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnJ1bGVzKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSBmdW5jdGlvbiAodmFsdWUsIGVycm9ycywgaGVscGVycykge1xuXG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBzY2hlbWEuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5tZXRob2RdO1xuXG4gICAgICAgIC8vIFNraXAgcnVsZXMgdGhhdCBhcmUgYWxzbyBhcHBsaWVkIGluIGNvZXJjZSBzdGVwXG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29udmVydCAmJlxuICAgICAgICAgICAgcHJlZnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAnZnVsbCcpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHJlZmVyZW5jZXNcblxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgYXJncyA9IHJ1bGUuYXJncztcbiAgICAgICAgaWYgKHJ1bGUuX3Jlc29sdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcmdzID0gT2JqZWN0LmFzc2lnbih7fSwgYXJncyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcnVsZS5fcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhcmdzW2tleV0ucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gcmVzb2x2ZXIubm9ybWFsaXplID8gcmVzb2x2ZXIubm9ybWFsaXplKHJlc29sdmVkKSA6IHJlc29sdmVkO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZCA9IENvbW1vbi52YWxpZGF0ZUFyZyhub3JtYWxpemVkLCBudWxsLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCByZXNvbHZlZCwgeyBhcmc6IGtleSwgcmVmOiBhcmdzW2tleV0sIHJlYXNvbjogaW52YWxpZCB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBydWxlXG5cbiAgICAgICAgcmV0ID0gcmV0IHx8IGRlZmluaXRpb24udmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHJ1bGUpOyAgICAgICAgICAgLy8gVXNlIHJldCBpZiBhbHJlYWR5IHNldCB0byByZWZlcmVuY2UgZXJyb3JcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMucnVsZShyZXQsIHJ1bGUpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ2Vycm9yJyk7XG5cbiAgICAgICAgICAgIGlmIChydWxlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS53YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIHJlc3VsdC5lcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdwYXNzJyk7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdydWxlJywgdmFsdWUsIHJlc3VsdC52YWx1ZSwgcnVsZS5uYW1lKTtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJ1bGUgPSBmdW5jdGlvbiAocmV0LCBydWxlKSB7XG5cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICBpbnRlcm5hbHMuZXJyb3IocmV0LCBydWxlKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBbcmV0XSwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXQpICYmXG4gICAgICAgIHJldFtDb21tb24uc3ltYm9scy5lcnJvcnNdKSB7XG5cbiAgICAgICAgcmV0LmZvckVhY2goKHJlcG9ydCkgPT4gaW50ZXJuYWxzLmVycm9yKHJlcG9ydCwgcnVsZSkpO1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IHJldCwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IG51bGwsIHZhbHVlOiByZXQgfTtcbn07XG5cblxuaW50ZXJuYWxzLmVycm9yID0gZnVuY3Rpb24gKHJlcG9ydCwgcnVsZSkge1xuXG4gICAgaWYgKHJ1bGUubWVzc2FnZSkge1xuICAgICAgICByZXBvcnQuX3NldFRlbXBsYXRlKHJ1bGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydDtcbn07XG5cblxuaW50ZXJuYWxzLmZpbmFsaXplID0gZnVuY3Rpb24gKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpIHtcblxuICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuXG4gICAgLy8gRmFpbG92ZXIgdmFsdWVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZhaWxvdmVyID0gaW50ZXJuYWxzLmRlZmF1bHQoJ2ZhaWxvdmVyJywgdW5kZWZpbmVkLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoZmFpbG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZmFpbG92ZXInLCB2YWx1ZSwgZmFpbG92ZXIpO1xuICAgICAgICAgICAgdmFsdWUgPSBmYWlsb3ZlcjtcbiAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXJyb3Igb3ZlcnJpZGVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoICYmXG4gICAgICAgIHNjaGVtYS5fZmxhZ3MuZXJyb3IpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5fZmxhZ3MuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IHNjaGVtYS5fZmxhZ3MuZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW2Vycm9yc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0LCAnZXJyb3IoKSBtdXN0IHJldHVybiBhbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IFtzY2hlbWEuX2ZsYWdzLmVycm9yXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHRcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRlZCA9IGludGVybmFscy5kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIGVycm9ycywgaGVscGVycyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2RlZmF1bHQnLCB2YWx1ZSwgZGVmYXVsdGVkKTtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0ZWQ7XG4gICAgfVxuXG4gICAgLy8gQ2FzdFxuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MuY2FzdCAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgY29uc3QgY2FzdGVyID0gc2NoZW1hLl9kZWZpbml0aW9uLmNhc3Rbc2NoZW1hLl9mbGFncy5jYXN0XTtcbiAgICAgICAgaWYgKGNhc3Rlci5mcm9tKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgY2FzdGVkID0gY2FzdGVyLnRvKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Nhc3QnLCB2YWx1ZSwgY2FzdGVkLCBzY2hlbWEuX2ZsYWdzLmNhc3QpO1xuICAgICAgICAgICAgdmFsdWUgPSBjYXN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRlcm5hbHNcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMgJiZcbiAgICAgICAgcHJlZnMuZXh0ZXJuYWxzICYmXG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlZCBmb3IgbWF0Y2hpbmdcblxuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0aG9kIH0gb2Ygc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5leHRlcm5hbHMucHVzaCh7IG1ldGhvZCwgc2NoZW1hLCBzdGF0ZSwgbGFiZWw6IEVycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzdWx0XG5cbiAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlLCBlcnJvcnM6IGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiBudWxsIH07XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5yZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgPyB1bmRlZmluZWQgOiAvKiByYXcgKi8gaGVscGVycy5vcmlnaW5hbDtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCBzY2hlbWEuX2ZsYWdzLnJlc3VsdCwgdmFsdWUsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHN0YXRlLnNoYWRvdyh2YWx1ZSwgc2NoZW1hLl9mbGFncy5yZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIENhY2hlXG5cbiAgICBpZiAoc2NoZW1hLl9jYWNoZSAmJlxuICAgICAgICBwcmVmcy5jYWNoZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgIXNjaGVtYS5fcmVmcy5sZW5ndGgpIHtcblxuICAgICAgICBzY2hlbWEuX2NhY2hlLnNldChoZWxwZXJzLm9yaWdpbmFsLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIEFydGlmYWN0c1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXJlc3VsdC5lcnJvcnMgJiZcbiAgICAgICAgc2NoZW1hLl9mbGFncy5hcnRpZmFjdCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzID0gc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuaGFzKHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuc2V0KHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmFydGlmYWN0cy5nZXQoc2NoZW1hLl9mbGFncy5hcnRpZmFjdCkucHVzaChzdGF0ZS5wYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5pbnRlcm5hbHMucHJlZnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmcykge1xuXG4gICAgY29uc3QgaXNEZWZhdWx0T3B0aW9ucyA9IHByZWZzID09PSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMgJiZcbiAgICAgICAgc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc10pIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgfVxuXG4gICAgcHJlZnMgPSBDb21tb24ucHJlZmVyZW5jZXMocHJlZnMsIHNjaGVtYS5fcHJlZmVyZW5jZXMpO1xuICAgIGlmIChpc0RlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHNjaGVtYS5fcHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdID0gcHJlZnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZzO1xufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbGFnLCB2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuICAgIGNvbnN0IHNvdXJjZSA9IHNjaGVtYS5fZmxhZ3NbZmxhZ107XG4gICAgaWYgKHByZWZzLm5vRGVmYXVsdHMgfHxcbiAgICAgICAgc291cmNlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIGZsYWcsICdmdWxsJyk7XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzb3VyY2UubGVuZ3RoID8gW0Nsb25lKHN0YXRlLmFuY2VzdG9yc1swXSksIGhlbHBlcnNdIDogW107XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoYGFueS4ke2ZsYWd9YCwgbnVsbCwgeyBlcnJvcjogZXJyIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVtDb21tb24uc3ltYm9scy5saXRlcmFsXSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpdGVyYWw7XG4gICAgfVxuXG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENsb25lKHNvdXJjZSk7XG59O1xuXG5cbmludGVybmFscy50cmltID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEpIHtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmltID0gc2NoZW1hLiRfZ2V0UnVsZSgndHJpbScpO1xuICAgIGlmICghdHJpbSB8fFxuICAgICAgICAhdHJpbS5hcmdzLmVuYWJsZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbn07XG5cblxuaW50ZXJuYWxzLmlnbm9yZSA9IHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRlYnVnOiBJZ25vcmUsXG4gICAgZW50cnk6IElnbm9yZSxcbiAgICBmaWx0ZXI6IElnbm9yZSxcbiAgICBsb2c6IElnbm9yZSxcbiAgICByZXNvbHZlOiBJZ25vcmUsXG4gICAgdmFsdWU6IElnbm9yZVxufTtcblxuXG5pbnRlcm5hbHMuZXJyb3JzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBlcnJvcnNbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSA9IHRydWU7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/values.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/values.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"(rsc)/./node_modules/@hapi/hoek/lib/deepEqual.js\");\n\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\n\n\nconst internals = {};\n\n\nmodule.exports = internals.Values = class {\n\n    constructor(values, refs) {\n\n        this._values = new Set(values);\n        this._refs = new Set(refs);\n        this._lowercase = internals.lowercases(values);\n\n        this._override = false;\n    }\n\n    get length() {\n\n        return this._values.size + this._refs.size;\n    }\n\n    add(value, refs) {\n\n        // Reference\n\n        if (Common.isResolvable(value)) {\n            if (!this._refs.has(value)) {\n                this._refs.add(value);\n\n                if (refs) {                     // Skipped in a merge\n                    refs.register(value);\n                }\n            }\n\n            return;\n        }\n\n        // Value\n\n        if (!this.has(value, null, null, false)) {\n            this._values.add(value);\n\n            if (typeof value === 'string') {\n                this._lowercase.set(value.toLowerCase(), value);\n            }\n        }\n    }\n\n    static merge(target, source, remove) {\n\n        target = target || new internals.Values();\n\n        if (source) {\n            if (source._override) {\n                return source.clone();\n            }\n\n            for (const item of [...source._values, ...source._refs]) {\n                target.add(item);\n            }\n        }\n\n        if (remove) {\n            for (const item of [...remove._values, ...remove._refs]) {\n                target.remove(item);\n            }\n        }\n\n        return target.length ? target : null;\n    }\n\n    remove(value) {\n\n        // Reference\n\n        if (Common.isResolvable(value)) {\n            this._refs.delete(value);\n            return;\n        }\n\n        // Value\n\n        this._values.delete(value);\n\n        if (typeof value === 'string') {\n            this._lowercase.delete(value.toLowerCase());\n        }\n    }\n\n    has(value, state, prefs, insensitive) {\n\n        return !!this.get(value, state, prefs, insensitive);\n    }\n\n    get(value, state, prefs, insensitive) {\n\n        if (!this.length) {\n            return false;\n        }\n\n        // Simple match\n\n        if (this._values.has(value)) {\n            return { value };\n        }\n\n        // Case insensitive string match\n\n        if (typeof value === 'string' &&\n            value &&\n            insensitive) {\n\n            const found = this._lowercase.get(value.toLowerCase());\n            if (found) {\n                return { value: found };\n            }\n        }\n\n        if (!this._refs.size &&\n            typeof value !== 'object') {\n\n            return false;\n        }\n\n        // Objects\n\n        if (typeof value === 'object') {\n            for (const item of this._values) {\n                if (DeepEqual(item, value)) {\n                    return { value: item };\n                }\n            }\n        }\n\n        // References\n\n        if (state) {\n            for (const ref of this._refs) {\n                const resolved = ref.resolve(value, state, prefs, null, { in: true });\n                if (resolved === undefined) {\n                    continue;\n                }\n\n                const items = !ref.in || typeof resolved !== 'object'\n                    ? [resolved]\n                    : Array.isArray(resolved) ? resolved : Object.keys(resolved);\n\n                for (const item of items) {\n                    if (typeof item !== typeof value) {\n                        continue;\n                    }\n\n                    if (insensitive &&\n                        value &&\n                        typeof value === 'string') {\n\n                        if (item.toLowerCase() === value.toLowerCase()) {\n                            return { value: item, ref };\n                        }\n                    }\n                    else {\n                        if (DeepEqual(item, value)) {\n                            return { value: item, ref };\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    override() {\n\n        this._override = true;\n    }\n\n    values(options) {\n\n        if (options &&\n            options.display) {\n\n            const values = [];\n\n            for (const item of [...this._values, ...this._refs]) {\n                if (item !== undefined) {\n                    values.push(item);\n                }\n            }\n\n            return values;\n        }\n\n        return Array.from([...this._values, ...this._refs]);\n    }\n\n    clone() {\n\n        const set = new internals.Values(this._values, this._refs);\n        set._override = this._override;\n        return set;\n    }\n\n    concat(source) {\n\n        Assert(!source._override, 'Cannot concat override set of values');\n\n        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);\n        set._override = this._override;\n        return set;\n    }\n\n    describe() {\n\n        const normalized = [];\n\n        if (this._override) {\n            normalized.push({ override: true });\n        }\n\n        for (const value of this._values.values()) {\n            normalized.push(value && typeof value === 'object' ? { value } : value);\n        }\n\n        for (const value of this._refs.values()) {\n            normalized.push(value.describe());\n        }\n\n        return normalized;\n    }\n};\n\n\ninternals.Values.prototype[Common.symbols.values] = true;\n\n\n// Aliases\n\ninternals.Values.prototype.slice = internals.Values.prototype.clone;\n\n\n// Helpers\n\ninternals.lowercases = function (from) {\n\n    const map = new Map();\n\n    if (from) {\n        for (const value of from) {\n            if (typeof value === 'string') {\n                map.set(value.toLowerCase(), value);\n            }\n        }\n    }\n\n    return map;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWx1ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRFQUF1QjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBMEI7O0FBRXBELGVBQWUsbUJBQU8sQ0FBQyx3REFBVTs7O0FBR2pDOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5Qzs7QUFFQTtBQUNBLG1FQUFtRSxRQUFRO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0xpc3Rlbi8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3ZhbHVlcy5qcz8wN2VkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5WYWx1ZXMgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMsIHJlZnMpIHtcblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBuZXcgU2V0KHZhbHVlcyk7XG4gICAgICAgIHRoaXMuX3JlZnMgPSBuZXcgU2V0KHJlZnMpO1xuICAgICAgICB0aGlzLl9sb3dlcmNhc2UgPSBpbnRlcm5hbHMubG93ZXJjYXNlcyh2YWx1ZXMpO1xuXG4gICAgICAgIHRoaXMuX292ZXJyaWRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLnNpemUgKyB0aGlzLl9yZWZzLnNpemU7XG4gICAgfVxuXG4gICAgYWRkKHZhbHVlLCByZWZzKSB7XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlZnMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZnMuYWRkKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWZzKSB7ICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcHBlZCBpbiBhIG1lcmdlXG4gICAgICAgICAgICAgICAgICAgIHJlZnMucmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsdWVcblxuICAgICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlLCBudWxsLCBudWxsLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvd2VyY2FzZS5zZXQodmFsdWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIG1lcmdlKHRhcmdldCwgc291cmNlLCByZW1vdmUpIHtcblxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IGludGVybmFscy5WYWx1ZXMoKTtcblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFsuLi5zb3VyY2UuX3ZhbHVlcywgLi4uc291cmNlLl9yZWZzXSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnJlbW92ZS5fdmFsdWVzLCAuLi5yZW1vdmUuX3JlZnNdKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQubGVuZ3RoID8gdGFyZ2V0IDogbnVsbDtcbiAgICB9XG5cbiAgICByZW1vdmUodmFsdWUpIHtcblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZnMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbHVlXG5cbiAgICAgICAgdGhpcy5fdmFsdWVzLmRlbGV0ZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvd2VyY2FzZS5kZWxldGUodmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYXModmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSk7XG4gICAgfVxuXG4gICAgZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2ltcGxlIG1hdGNoXG5cbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZSBpbnNlbnNpdGl2ZSBzdHJpbmcgbWF0Y2hcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgIGluc2Vuc2l0aXZlKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fbG93ZXJjYXNlLmdldCh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBmb3VuZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZWZzLnNpemUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2JqZWN0c1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKERlZXBFcXVhbChpdGVtLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWZlcmVuY2VzXG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiB0aGlzLl9yZWZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZWYucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IGluOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gIXJlZi5pbiB8fCB0eXBlb2YgcmVzb2x2ZWQgIT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgID8gW3Jlc29sdmVkXVxuICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkocmVzb2x2ZWQpID8gcmVzb2x2ZWQgOiBPYmplY3Qua2V5cyhyZXNvbHZlZCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2Vuc2l0aXZlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIHJlZiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKERlZXBFcXVhbChpdGVtLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgcmVmIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUoKSB7XG5cbiAgICAgICAgdGhpcy5fb3ZlcnJpZGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhbHVlcyhvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuZGlzcGxheSkge1xuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFsuLi50aGlzLl92YWx1ZXMsIC4uLnRoaXMuX3JlZnNdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShbLi4udGhpcy5fdmFsdWVzLCAuLi50aGlzLl9yZWZzXSk7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IGludGVybmFscy5WYWx1ZXModGhpcy5fdmFsdWVzLCB0aGlzLl9yZWZzKTtcbiAgICAgICAgc2V0Ll9vdmVycmlkZSA9IHRoaXMuX292ZXJyaWRlO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBBc3NlcnQoIXNvdXJjZS5fb3ZlcnJpZGUsICdDYW5ub3QgY29uY2F0IG92ZXJyaWRlIHNldCBvZiB2YWx1ZXMnKTtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgaW50ZXJuYWxzLlZhbHVlcyhbLi4udGhpcy5fdmFsdWVzLCAuLi5zb3VyY2UuX3ZhbHVlc10sIFsuLi50aGlzLl9yZWZzLCAuLi5zb3VyY2UuX3JlZnNdKTtcbiAgICAgICAgc2V0Ll9vdmVycmlkZSA9IHRoaXMuX292ZXJyaWRlO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCh7IG92ZXJyaWRlOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLl92YWx1ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8geyB2YWx1ZSB9IDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLl9yZWZzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2godmFsdWUuZGVzY3JpYmUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5WYWx1ZXMucHJvdG90eXBlW0NvbW1vbi5zeW1ib2xzLnZhbHVlc10gPSB0cnVlO1xuXG5cbi8vIEFsaWFzZXNcblxuaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGUuc2xpY2UgPSBpbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZS5jbG9uZTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5sb3dlcmNhc2VzID0gZnVuY3Rpb24gKGZyb20pIHtcblxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGlmIChmcm9tKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZnJvbSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KHZhbHVlLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/values.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/package.json":
/*!***************************************!*\
  !*** ./node_modules/joi/package.json ***!
  \***************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"joi","description":"Object schema validation","version":"17.13.3","repository":"git://github.com/hapijs/joi","main":"lib/index.js","types":"lib/index.d.ts","browser":"dist/joi-browser.min.js","files":["lib/**/*","dist/*"],"keywords":["schema","validation"],"dependencies":{"@hapi/hoek":"^9.3.0","@hapi/topo":"^5.1.0","@sideway/address":"^4.1.5","@sideway/formula":"^3.0.1","@sideway/pinpoint":"^2.0.0"},"devDependencies":{"@hapi/bourne":"2.x.x","@hapi/code":"8.x.x","@hapi/joi-legacy-test":"npm:@hapi/joi@15.x.x","@hapi/lab":"^25.1.3","@types/node":"^14.18.63","typescript":"4.3.x"},"scripts":{"prepublishOnly":"cd browser && npm install && npm run build","test":"lab -t 100 -a @hapi/code -L -Y","test-cov-html":"lab -r html -o coverage.html -a @hapi/code"},"license":"BSD-3-Clause"}');

/***/ })

};
;